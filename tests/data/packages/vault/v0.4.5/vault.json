{"buildDependencies":{"openzeppelin":"https://github.com/OpenZeppelin/openzeppelin-contracts/releases/tag/v4.7.1"},"compilers":[{"contractTypes":[],"name":"vyper","settings":{"optimize":true,"outputSelection":{"Registry.vy":["*"]}},"version":"0.2.11"},{"contractTypes":[],"name":"vyper","settings":{"optimize":true,"outputSelection":{"Vault.vy":["*"]}},"version":"0.3.3"},{"contractTypes":[],"name":"solidity","settings":{"optimizer":{"enabled":true,"runs":200},"outputSelection":{"AccessControl.sol":{"AccessControl":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"AccessControlCrossChain.sol":{"AccessControlCrossChain":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"AccessControlCrossChainMock.sol":{"AccessControlCrossChainMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"AccessControlEnumerable.sol":{"AccessControlEnumerable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"AccessControlEnumerableMock.sol":{"AccessControlEnumerableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"AccessControlMock.sol":{"AccessControlMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Address.sol":{"Address":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"AddressImpl.sol":{"AddressImpl":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Arrays.sol":{"Arrays":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ArraysImpl.sol":{"ArraysImpl":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"BadBeacon.sol":{"BadBeacon":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Base64.sol":{"Base64":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Base64Mock.sol":{"Base64Mock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"BaseFeeOracle.sol":{"BaseFeeOracle":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"BaseStrategy.sol":{"BaseStrategy":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"BeaconProxy.sol":{"BeaconProxy":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"BitMaps.sol":{"BitMaps":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"BitmapMock.sol":{"BitmapMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"CallReceiverMock.sol":{"CallReceiverMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Checkpoints.sol":{"Checkpoints":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"CheckpointsImpl.sol":{"CheckpointsImpl":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ClashingImplementation.sol":{"ClashingImplementation":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Clones.sol":{"Clones":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ClonesMock.sol":{"ClonesMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"CommonHealthCheck.sol":{"CommonHealthCheck":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"CompTimelock.sol":{"CompTimelock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ConditionalEscrow.sol":{"ConditionalEscrow":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ConditionalEscrowMock.sol":{"ConditionalEscrowMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Context.sol":{"Context":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ContextMock.sol":{"ContextMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Counters.sol":{"Counters":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"CountersImpl.sol":{"CountersImpl":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Create2.sol":{"Create2":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Create2Impl.sol":{"Create2Impl":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"CrossChainEnabled.sol":{"CrossChainEnabled":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"CrossChainEnabledAMB.sol":{"CrossChainEnabledAMB":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"CrossChainEnabledArbitrumL1.sol":{"CrossChainEnabledArbitrumL1":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"CrossChainEnabledArbitrumL2.sol":{"CrossChainEnabledArbitrumL2":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"CrossChainEnabledOptimism.sol":{"CrossChainEnabledOptimism":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"CrossChainEnabledPolygonChild.sol":{"CrossChainEnabledPolygonChild":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"DoubleEndedQueue.sol":{"DoubleEndedQueue":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"DoubleEndedQueueMock.sol":{"DoubleEndedQueueMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"DummyImplementation.sol":{"DummyImplementation":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ECDSA.sol":{"ECDSA":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ECDSAMock.sol":{"ECDSAMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"EIP712External.sol":{"EIP712External":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155.sol":{"ERC1155":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155Burnable.sol":{"ERC1155Burnable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155BurnableMock.sol":{"ERC1155BurnableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155Holder.sol":{"ERC1155Holder":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155Mock.sol":{"ERC1155Mock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155Pausable.sol":{"ERC1155Pausable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155PausableMock.sol":{"ERC1155PausableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155PresetMinterPauser.sol":{"ERC1155PresetMinterPauser":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155Receiver.sol":{"ERC1155Receiver":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155ReceiverMock.sol":{"ERC1155ReceiverMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155Supply.sol":{"ERC1155Supply":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155SupplyMock.sol":{"ERC1155SupplyMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155URIStorage.sol":{"ERC1155URIStorage":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155URIStorageMock.sol":{"ERC1155URIStorageMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1271WalletMock.sol":{"ERC1271WalletMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC165.sol":{"ERC165":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC165Checker.sol":{"ERC165Checker":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC165CheckerMock.sol":{"ERC165CheckerMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC165InterfacesSupported.sol":{"ERC165InterfacesSupported":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC165MaliciousData.sol":{"ERC165MaliciousData":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC165MissingData.sol":{"ERC165MissingData":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC165Mock.sol":{"ERC165Mock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC165NotSupported.sol":{"ERC165NotSupported":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC165Storage.sol":{"ERC165Storage":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC165StorageMock.sol":{"ERC165StorageMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1820Implementer.sol":{"ERC1820Implementer":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1820ImplementerMock.sol":{"ERC1820ImplementerMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1967Proxy.sol":{"ERC1967Proxy":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1967Upgrade.sol":{"ERC1967Upgrade":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20.sol":{"ERC20":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20Burnable.sol":{"ERC20Burnable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20BurnableMock.sol":{"ERC20BurnableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20Capped.sol":{"ERC20Capped":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20CappedMock.sol":{"ERC20CappedMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20DecimalsMock.sol":{"ERC20DecimalsMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20FlashMint.sol":{"ERC20FlashMint":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20FlashMintMock.sol":{"ERC20FlashMintMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20Mock.sol":{"ERC20Mock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20Pausable.sol":{"ERC20Pausable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20PausableMock.sol":{"ERC20PausableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20PermitMock.sol":{"ERC20PermitMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20PresetFixedSupply.sol":{"ERC20PresetFixedSupply":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20PresetMinterPauser.sol":{"ERC20PresetMinterPauser":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20Snapshot.sol":{"ERC20Snapshot":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20SnapshotMock.sol":{"ERC20SnapshotMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20Votes.sol":{"ERC20Votes":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20VotesComp.sol":{"ERC20VotesComp":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20VotesCompMock.sol":{"ERC20VotesCompMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20VotesMock.sol":{"ERC20VotesMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20Wrapper.sol":{"ERC20Wrapper":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20WrapperMock.sol":{"ERC20WrapperMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC2771Context.sol":{"ERC2771Context":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC2771ContextMock.sol":{"ERC2771ContextMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC2981.sol":{"ERC2981":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC3156FlashBorrowerMock.sol":{"ERC3156FlashBorrowerMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC4626.sol":{"ERC4626":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC4626Mock.sol":{"ERC4626Mock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721.sol":{"ERC721":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721Burnable.sol":{"ERC721Burnable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721BurnableMock.sol":{"ERC721BurnableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721Enumerable.sol":{"ERC721Enumerable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721EnumerableMock.sol":{"ERC721EnumerableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721Holder.sol":{"ERC721Holder":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721Mock.sol":{"ERC721Mock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721Pausable.sol":{"ERC721Pausable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721PausableMock.sol":{"ERC721PausableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721PresetMinterPauserAutoId.sol":{"ERC721PresetMinterPauserAutoId":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721ReceiverMock.sol":{"ERC721ReceiverMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721Royalty.sol":{"ERC721Royalty":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721RoyaltyMock.sol":{"ERC721RoyaltyMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721URIStorage.sol":{"ERC721URIStorage":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721URIStorageMock.sol":{"ERC721URIStorageMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721VotesMock.sol":{"ERC721VotesMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC777.sol":{"ERC777":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC777Mock.sol":{"ERC777Mock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC777PresetFixedSupply.sol":{"ERC777PresetFixedSupply":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC777SenderRecipientMock.sol":{"ERC777SenderRecipientMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"EnumerableMap.sol":{"EnumerableMap":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"EnumerableMapMock.sol":{"EnumerableMapMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"EnumerableSet.sol":{"EnumerableSet":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"EnumerableSetMock.sol":{"EnumerableSetMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Escrow.sol":{"Escrow":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"EtherReceiverMock.sol":{"EtherReceiverMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Governor.sol":{"Governor":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorCompMock.sol":{"GovernorCompMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorCompatibilityBravo.sol":{"GovernorCompatibilityBravo":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorCompatibilityBravoMock.sol":{"GovernorCompatibilityBravoMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorCountingSimple.sol":{"GovernorCountingSimple":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorMock.sol":{"GovernorMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorPreventLateQuorum.sol":{"GovernorPreventLateQuorum":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorPreventLateQuorumMock.sol":{"GovernorPreventLateQuorumMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorProposalThreshold.sol":{"GovernorProposalThreshold":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorSettings.sol":{"GovernorSettings":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorTimelockCompound.sol":{"GovernorTimelockCompound":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorTimelockCompoundMock.sol":{"GovernorTimelockCompoundMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorTimelockControl.sol":{"GovernorTimelockControl":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorTimelockControlMock.sol":{"GovernorTimelockControlMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorVoteMock.sol":{"GovernorVoteMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorVotes.sol":{"GovernorVotes":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorVotesComp.sol":{"GovernorVotesComp":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorVotesQuorumFraction.sol":{"GovernorVotesQuorumFraction":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorWithParamsMock.sol":{"GovernorWithParamsMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IAMB.sol":{"IAMB":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IAccessControl.sol":{"IAccessControl":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IAccessControlEnumerable.sol":{"IAccessControlEnumerable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IArbSys.sol":{"IArbSys":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IBeacon.sol":{"IBeacon":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IBridge.sol":{"IBridge":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ICompoundTimelock.sol":{"ICompoundTimelock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ICrossDomainMessenger.sol":{"ICrossDomainMessenger":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC1155.sol":{"IERC1155":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC1155MetadataURI.sol":{"IERC1155MetadataURI":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC1155Receiver.sol":{"IERC1155Receiver":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC1271.sol":{"IERC1271":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC1363.sol":{"IERC1363":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC1363Receiver.sol":{"IERC1363Receiver":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC1363Spender.sol":{"IERC1363Spender":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC165.sol":{"IERC165":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC1820Implementer.sol":{"IERC1820Implementer":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC1820Registry.sol":{"IERC1820Registry":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC20.sol":{"IERC20":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC20Metadata.sol":{"IERC20Metadata":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC2981.sol":{"IERC2981":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC3156.sol":{"IERC3156":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC3156FlashBorrower.sol":{"IERC3156FlashBorrower":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC3156FlashLender.sol":{"IERC3156FlashLender":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC4626.sol":{"IERC4626":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC721.sol":{"IERC721":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC721Enumerable.sol":{"IERC721Enumerable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC721Metadata.sol":{"IERC721Metadata":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC721Receiver.sol":{"IERC721Receiver":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC777.sol":{"IERC777":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC777Recipient.sol":{"IERC777Recipient":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC777Sender.sol":{"IERC777Sender":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IFxMessageProcessor.sol":{"IFxMessageProcessor":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IGovernor.sol":{"IGovernor":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IGovernorCompatibilityBravo.sol":{"IGovernorCompatibilityBravo":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IGovernorTimelock.sol":{"IGovernorTimelock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IInbox.sol":{"IInbox":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IMessageProvider.sol":{"IMessageProvider":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IOutbox.sol":{"IOutbox":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IVotes.sol":{"IVotes":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Initializable.sol":{"Initializable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"InitializableMock.sol":{"InitializableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"LibAMB.sol":{"LibAMB":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"LibArbitrumL1.sol":{"LibArbitrumL1":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"LibArbitrumL2.sol":{"LibArbitrumL2":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"LibOptimism.sol":{"LibOptimism":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Math.sol":{"Math":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"MathMock.sol":{"MathMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"MerkleProof.sol":{"MerkleProof":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"MerkleProofWrapper.sol":{"MerkleProofWrapper":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"MinimalForwarder.sol":{"MinimalForwarder":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Multicall.sol":{"Multicall":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"MulticallTest.sol":{"MulticallTest":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"MulticallTokenMock.sol":{"MulticallTokenMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"MultipleInheritanceInitializableMocks.sol":{"MultipleInheritanceInitializableMocks":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"MyGovernor1.sol":{"MyGovernor1":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"MyGovernor2.sol":{"MyGovernor2":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"MyGovernor3.sol":{"MyGovernor3":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Ownable.sol":{"Ownable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"OwnableMock.sol":{"OwnableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Pausable.sol":{"Pausable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"PausableMock.sol":{"PausableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"PaymentSplitter.sol":{"PaymentSplitter":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Proxy.sol":{"Proxy":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ProxyAdmin.sol":{"ProxyAdmin":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"PullPayment.sol":{"PullPayment":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"PullPaymentMock.sol":{"PullPaymentMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ReentrancyAttack.sol":{"ReentrancyAttack":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ReentrancyGuard.sol":{"ReentrancyGuard":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ReentrancyMock.sol":{"ReentrancyMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"RefundEscrow.sol":{"RefundEscrow":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"RegressionImplementation.sol":{"RegressionImplementation":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SafeCast.sol":{"SafeCast":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SafeCastMock.sol":{"SafeCastMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SafeERC20.sol":{"SafeERC20":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SafeERC20Helper.sol":{"SafeERC20Helper":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SafeMath.sol":{"SafeMath":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SafeMathMock.sol":{"SafeMathMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SignatureChecker.sol":{"SignatureChecker":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SignatureCheckerMock.sol":{"SignatureCheckerMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SignedMath.sol":{"SignedMath":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SignedMathMock.sol":{"SignedMathMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SignedSafeMath.sol":{"SignedSafeMath":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SignedSafeMathMock.sol":{"SignedSafeMathMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SingleInheritanceInitializableMocks.sol":{"SingleInheritanceInitializableMocks":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"StorageSlot.sol":{"StorageSlot":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"StorageSlotMock.sol":{"StorageSlotMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Strings.sol":{"Strings":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"StringsMock.sol":{"StringsMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"TestStrategy.sol":{"TestStrategy":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"TimelockController.sol":{"TimelockController":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Timers.sol":{"Timers":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"TimersBlockNumberImpl.sol":{"TimersBlockNumberImpl":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"TimersTimestampImpl.sol":{"TimersTimestampImpl":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Token.sol":{"Token":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"TokenTimelock.sol":{"TokenTimelock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"TransparentUpgradeableProxy.sol":{"TransparentUpgradeableProxy":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"UUPSLegacy.sol":{"UUPSLegacy":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"UUPSUpgradeable.sol":{"UUPSUpgradeable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"UUPSUpgradeableMock.sol":{"UUPSUpgradeableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"UpgradeableBeacon.sol":{"UpgradeableBeacon":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"VestingWallet.sol":{"VestingWallet":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Votes.sol":{"Votes":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"VotesMock.sol":{"VotesMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"bridges.sol":{"bridges":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"draft-EIP712.sol":{"draft-EIP712":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"draft-ERC20Permit.sol":{"draft-ERC20Permit":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"draft-ERC721Votes.sol":{"draft-ERC721Votes":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"draft-IERC1822.sol":{"draft-IERC1822":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"draft-IERC20Permit.sol":{"draft-IERC20Permit":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"draft-IERC2612.sol":{"draft-IERC2612":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"errors.sol":{"errors":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"receivers.sol":{"receivers":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]}},"remappings":["@openzeppelin/contracts=.cache/OpenZeppelin/v4.7.1"]},"version":"0.8.15+commit.e14f2714"}],"contractTypes":{},"manifest":"ethpm/3","name":"vault","sources":{"BaseFeeOracle.sol":{"checksum":{"algorithm":"md5","hash":"0x7b8681a7881d54a945ddfc11e0fae558"},"content":"// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.15;\n\ninterface IBaseFee {\n    function basefee_global() external view returns (uint256);\n}\n\n/**\n * @dev Interprets the base fee from our base fee provider\n *  contract to determine if a harvest is permissable.\n *\n * Version 0.1.0\n */\n\ncontract BaseFeeOracle {\n    address public baseFeeProvider; /// @notice Provider to read current block's base fee. This will vary based on network.\n    uint256 public maxAcceptableBaseFee; /// @notice Max acceptable base fee for the operation\n\n    address public governance; /// @notice Governance can grant and revoke access to the setter\n    address public pendingGovernance; /// @notice New address must be set by current gov and then accept to transfer power.\n    mapping(address => bool) public authorizedAddresses; /// @notice Addresses that can set the max acceptable base fee\n\n    bool public manualBaseFeeBool; /// @notice Use this if our network hasn't implemented the base fee method yet\n\n    constructor() {\n        governance = msg.sender; // our deployer should be gov, they can set up the rest\n        manualBaseFeeBool = true; // start as permissive\n    }\n\n    // events for subgraph\n    event NewGovernance(address indexed governance);\n\n    event NewProvider(address indexed provider);\n\n    event UpdatedMaxBaseFee(uint256 baseFee);\n\n    event UpdatedManualBaseFee(bool manualFee);\n\n    event UpdatedAuthorization(address indexed target, bool authorized);\n\n    /// @notice Returns whether we should allow harvests based on current base fee.\n    function isCurrentBaseFeeAcceptable() public view returns (bool) {\n        if (baseFeeProvider == address(0)) {\n            return manualBaseFeeBool;\n        } else {\n            uint256 baseFee = IBaseFee(baseFeeProvider).basefee_global();\n            return baseFee <= maxAcceptableBaseFee;\n        }\n    }\n\n    /**\n     * @notice Set the maximum base fee we want for our keepers to accept.\n     *  Gwei is 1e9.\n     * @dev Throws if the caller is not authorized or gov.\n     * @param _maxAcceptableBaseFee The acceptable maximum price to pay in wei.\n     */\n    function setMaxAcceptableBaseFee(uint256 _maxAcceptableBaseFee) external {\n        _onlyAuthorized();\n        maxAcceptableBaseFee = _maxAcceptableBaseFee;\n        emit UpdatedMaxBaseFee(_maxAcceptableBaseFee);\n    }\n\n    /**\n     * @notice If we don't have a provider, then manually determine if true or not.\n     *  Useful in testing as well.\n     * @dev Throws if the caller is not authorized or gov.\n     * @param _manualBaseFeeBool Boolean to allow/block harvests if we don't\n     *  have a provider set up.\n     */\n    function setManualBaseFeeBool(bool _manualBaseFeeBool) external {\n        _onlyAuthorized();\n        manualBaseFeeBool = _manualBaseFeeBool;\n        emit UpdatedManualBaseFee(_manualBaseFeeBool);\n    }\n\n    /**\n     * @notice Controls whether a non-gov address can adjust certain params.\n     * @dev Throws if the caller is not current governance.\n     * @param _target The address to add/remove authorization for.\n     * @param _value Boolean to grant or revoke access.\n     */\n    function setAuthorized(address _target, bool _value) external {\n        _onlyGovernance();\n        authorizedAddresses[_target] = _value;\n        emit UpdatedAuthorization(_target, _value);\n    }\n\n    /**\n     * @notice Starts the 1st phase of the governance transfer.\n     * @dev Throws if the caller is not current governance.\n     * @param _governance The next governance address\n     */\n    function setPendingGovernance(address _governance) external {\n        _onlyGovernance();\n        pendingGovernance = _governance;\n    }\n\n    /**\n     * @notice Completes the 2nd phase of the governance transfer.\n     * @dev Throws if the caller is not the pending caller.\n     *  Emits a `NewGovernance` event.\n     */\n    function acceptGovernance() external {\n        require(msg.sender == pendingGovernance, \"!authorized\");\n        governance = msg.sender;\n        emit NewGovernance(msg.sender);\n    }\n\n    /**\n     * @notice Sets the address used to pull the current network base fee.\n     * @dev Throws if the caller is not current governance.\n     * @param _baseFeeProvider The network's baseFeeProvider address\n     */\n    function setBaseFeeProvider(address _baseFeeProvider) external {\n        _onlyGovernance();\n        baseFeeProvider = _baseFeeProvider;\n        emit NewProvider(_baseFeeProvider);\n    }\n\n    function _onlyAuthorized() internal view {\n        require(authorizedAddresses[msg.sender] == true || msg.sender == governance, \"!authorized\");\n    }\n\n    function _onlyGovernance() internal view {\n        require(msg.sender == governance, \"!governance\");\n    }\n}\n","imports":[],"references":[],"urls":[]},"BaseStrategy.sol":{"checksum":{"algorithm":"md5","hash":"0xb38fd2f357db45db8751818a6f7b725f"},"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.15;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nstruct StrategyParams {\n    uint256 performanceFee;\n    uint256 activation;\n    uint256 debtRatio;\n    uint256 minDebtPerHarvest;\n    uint256 maxDebtPerHarvest;\n    uint256 lastReport;\n    uint256 totalDebt;\n    uint256 totalGain;\n    uint256 totalLoss;\n}\n\ninterface VaultAPI is IERC20 {\n    function name() external view returns (string calldata);\n\n    function symbol() external view returns (string calldata);\n\n    function decimals() external view returns (uint256);\n\n    function apiVersion() external pure returns (string memory);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 expiry,\n        bytes calldata signature\n    ) external returns (bool);\n\n    // NOTE: Vyper produces multiple signatures for a given function with \"default\" args\n    function deposit() external returns (uint256);\n\n    function deposit(uint256 amount) external returns (uint256);\n\n    function deposit(uint256 amount, address recipient) external returns (uint256);\n\n    // NOTE: Vyper produces multiple signatures for a given function with \"default\" args\n    function withdraw() external returns (uint256);\n\n    function withdraw(uint256 maxShares) external returns (uint256);\n\n    function withdraw(uint256 maxShares, address recipient) external returns (uint256);\n\n    function token() external view returns (address);\n\n    function strategies(address _strategy) external view returns (StrategyParams memory);\n\n    function pricePerShare() external view returns (uint256);\n\n    function totalAssets() external view returns (uint256);\n\n    function depositLimit() external view returns (uint256);\n\n    function maxAvailableShares() external view returns (uint256);\n\n    /**\n     * View how much the Vault would increase this Strategy's borrow limit,\n     * based on its present performance (since its last report). Can be used to\n     * determine expectedReturn in your Strategy.\n     */\n    function creditAvailable() external view returns (uint256);\n\n    /**\n     * View how much the Vault would like to pull back from the Strategy,\n     * based on its present performance (since its last report). Can be used to\n     * determine expectedReturn in your Strategy.\n     */\n    function debtOutstanding() external view returns (uint256);\n\n    /**\n     * View how much the Vault expect this Strategy to return at the current\n     * block, based on its present performance (since its last report). Can be\n     * used to determine expectedReturn in your Strategy.\n     */\n    function expectedReturn() external view returns (uint256);\n\n    /**\n     * This is the main contact point where the Strategy interacts with the\n     * Vault. It is critical that this call is handled as intended by the\n     * Strategy. Therefore, this function will be called by BaseStrategy to\n     * make sure the integration is correct.\n     */\n    function report(\n        uint256 _gain,\n        uint256 _loss,\n        uint256 _debtPayment\n    ) external returns (uint256);\n\n    /**\n     * This function should only be used in the scenario where the Strategy is\n     * being retired but no migration of the positions are possible, or in the\n     * extreme scenario that the Strategy needs to be put into \"Emergency Exit\"\n     * mode in order for it to exit as quickly as possible. The latter scenario\n     * could be for any reason that is considered \"critical\" that the Strategy\n     * exits its position as fast as possible, such as a sudden change in\n     * market conditions leading to losses, or an imminent failure in an\n     * external dependency.\n     */\n    function revokeStrategy() external;\n\n    /**\n     * View the governance address of the Vault to assert privileged functions\n     * can only be called by governance. The Strategy serves the Vault, so it\n     * is subject to governance defined by the Vault.\n     */\n    function governance() external view returns (address);\n\n    /**\n     * View the management address of the Vault to assert privileged functions\n     * can only be called by management. The Strategy serves the Vault, so it\n     * is subject to management defined by the Vault.\n     */\n    function management() external view returns (address);\n\n    /**\n     * View the guardian address of the Vault to assert privileged functions\n     * can only be called by guardian. The Strategy serves the Vault, so it\n     * is subject to guardian defined by the Vault.\n     */\n    function guardian() external view returns (address);\n}\n\n/**\n * This interface is here for the keeper bot to use.\n */\ninterface StrategyAPI {\n    function name() external view returns (string memory);\n\n    function vault() external view returns (address);\n\n    function want() external view returns (address);\n\n    function apiVersion() external pure returns (string memory);\n\n    function keeper() external view returns (address);\n\n    function isActive() external view returns (bool);\n\n    function delegatedAssets() external view returns (uint256);\n\n    function estimatedTotalAssets() external view returns (uint256);\n\n    function tendTrigger(uint256 callCost) external view returns (bool);\n\n    function tend() external;\n\n    function harvestTrigger(uint256 callCost) external view returns (bool);\n\n    function harvest() external;\n\n    event Harvested(uint256 profit, uint256 loss, uint256 debtPayment, uint256 debtOutstanding);\n}\n\ninterface HealthCheck {\n    function check(\n        uint256 profit,\n        uint256 loss,\n        uint256 debtPayment,\n        uint256 debtOutstanding,\n        uint256 totalDebt\n    ) external view returns (bool);\n}\n\ninterface IBaseFee {\n    function isCurrentBaseFeeAcceptable() external view returns (bool);\n}\n\n/**\n * @title Yearn Base Strategy\n * @author yearn.finance\n * @notice\n *  BaseStrategy implements all of the required functionality to interoperate\n *  closely with the Vault contract. This contract should be inherited and the\n *  abstract methods implemented to adapt the Strategy to the particular needs\n *  it has to create a return.\n *\n *  Of special interest is the relationship between `harvest()` and\n *  `vault.report()'. `harvest()` may be called simply because enough time has\n *  elapsed since the last report, and not because any funds need to be moved\n *  or positions adjusted. This is critical so that the Vault may maintain an\n *  accurate picture of the Strategy's performance. See  `vault.report()`,\n *  `harvest()`, and `harvestTrigger()` for further details.\n */\n\nabstract contract BaseStrategy {\n    using SafeERC20 for IERC20;\n    string public metadataURI;\n\n    // health checks\n    bool public doHealthCheck;\n    address public healthCheck;\n\n    /**\n     * @notice\n     *  Used to track which version of `StrategyAPI` this Strategy\n     *  implements.\n     * @dev The Strategy's version must match the Vault's `API_VERSION`.\n     * @return A string which holds the current API version of this contract.\n     */\n    function apiVersion() public pure returns (string memory) {\n        return \"0.4.5\";\n    }\n\n    /**\n     * @notice This Strategy's name.\n     * @dev\n     *  You can use this field to manage the \"version\" of this Strategy, e.g.\n     *  `StrategySomethingOrOtherV1`. However, \"API Version\" is managed by\n     *  `apiVersion()` function above.\n     * @return This Strategy's name.\n     */\n    function name() external view virtual returns (string memory);\n\n    /**\n     * @notice\n     *  The amount (priced in want) of the total assets managed by this strategy should not count\n     *  towards Yearn's TVL calculations.\n     * @dev\n     *  You can override this field to set it to a non-zero value if some of the assets of this\n     *  Strategy is somehow delegated inside another part of of Yearn's ecosystem e.g. another Vault.\n     *  Note that this value must be strictly less than or equal to the amount provided by\n     *  `estimatedTotalAssets()` below, as the TVL calc will be total assets minus delegated assets.\n     *  Also note that this value is used to determine the total assets under management by this\n     *  strategy, for the purposes of computing the management fee in `Vault`\n     * @return\n     *  The amount of assets this strategy manages that should not be included in Yearn's Total Value\n     *  Locked (TVL) calculation across it's ecosystem.\n     */\n    function delegatedAssets() external view virtual returns (uint256) {\n        return 0;\n    }\n\n    VaultAPI public vault;\n    address public strategist;\n    address public rewards;\n    address public keeper;\n\n    IERC20 public want;\n\n    // So indexers can keep track of this\n    event Harvested(uint256 profit, uint256 loss, uint256 debtPayment, uint256 debtOutstanding);\n\n    event UpdatedStrategist(address newStrategist);\n\n    event UpdatedKeeper(address newKeeper);\n\n    event UpdatedRewards(address rewards);\n\n    event UpdatedMinReportDelay(uint256 delay);\n\n    event UpdatedMaxReportDelay(uint256 delay);\n\n    event UpdatedBaseFeeOracle(address baseFeeOracle);\n\n    event UpdatedCreditThreshold(uint256 creditThreshold);\n\n    event ForcedHarvestTrigger(bool triggerState);\n\n    event EmergencyExitEnabled();\n\n    event UpdatedMetadataURI(string metadataURI);\n\n    event SetHealthCheck(address);\n    event SetDoHealthCheck(bool);\n\n    // The minimum number of seconds between harvest calls. See\n    // `setMinReportDelay()` for more details.\n    uint256 public minReportDelay;\n\n    // The maximum number of seconds between harvest calls. See\n    // `setMaxReportDelay()` for more details.\n    uint256 public maxReportDelay;\n\n    // See note on `setEmergencyExit()`.\n    bool public emergencyExit;\n\n    // See note on `isBaseFeeOracleAcceptable()`.\n    address public baseFeeOracle;\n\n    // See note on `setCreditThreshold()`\n    uint256 public creditThreshold;\n\n    // See note on `setForceHarvestTriggerOnce`\n    bool public forceHarvestTriggerOnce;\n\n    // modifiers\n    modifier onlyAuthorized() {\n        _onlyAuthorized();\n        _;\n    }\n\n    modifier onlyEmergencyAuthorized() {\n        _onlyEmergencyAuthorized();\n        _;\n    }\n\n    modifier onlyStrategist() {\n        _onlyStrategist();\n        _;\n    }\n\n    modifier onlyGovernance() {\n        _onlyGovernance();\n        _;\n    }\n\n    modifier onlyRewarder() {\n        _onlyRewarder();\n        _;\n    }\n\n    modifier onlyKeepers() {\n        _onlyKeepers();\n        _;\n    }\n\n    modifier onlyVaultManagers() {\n        _onlyVaultManagers();\n        _;\n    }\n\n    function _onlyAuthorized() internal {\n        require(msg.sender == strategist || msg.sender == governance());\n    }\n\n    function _onlyEmergencyAuthorized() internal {\n        require(msg.sender == strategist || msg.sender == governance() || msg.sender == vault.guardian() || msg.sender == vault.management());\n    }\n\n    function _onlyStrategist() internal {\n        require(msg.sender == strategist);\n    }\n\n    function _onlyGovernance() internal {\n        require(msg.sender == governance());\n    }\n\n    function _onlyRewarder() internal {\n        require(msg.sender == governance() || msg.sender == strategist);\n    }\n\n    function _onlyKeepers() internal {\n        require(\n            msg.sender == keeper ||\n                msg.sender == strategist ||\n                msg.sender == governance() ||\n                msg.sender == vault.guardian() ||\n                msg.sender == vault.management()\n        );\n    }\n\n    function _onlyVaultManagers() internal {\n        require(msg.sender == vault.management() || msg.sender == governance());\n    }\n\n    constructor(address _vault) {\n        _initialize(_vault, msg.sender, msg.sender, msg.sender);\n    }\n\n    /**\n     * @notice\n     *  Initializes the Strategy, this is called only once, when the\n     *  contract is deployed.\n     * @dev `_vault` should implement `VaultAPI`.\n     * @param _vault The address of the Vault responsible for this Strategy.\n     * @param _strategist The address to assign as `strategist`.\n     * The strategist is able to change the reward address\n     * @param _rewards  The address to use for pulling rewards.\n     * @param _keeper The adddress of the _keeper. _keeper\n     * can harvest and tend a strategy.\n     */\n    function _initialize(\n        address _vault,\n        address _strategist,\n        address _rewards,\n        address _keeper\n    ) internal {\n        require(address(want) == address(0), \"Strategy already initialized\");\n\n        vault = VaultAPI(_vault);\n        want = IERC20(vault.token());\n        want.safeApprove(_vault, type(uint256).max); // Give Vault unlimited access (might save gas)\n        strategist = _strategist;\n        rewards = _rewards;\n        keeper = _keeper;\n\n        // initialize variables\n        maxReportDelay = 30 days;\n        creditThreshold = 1_000_000 * 10**vault.decimals(); // set this high by default so we don't get tons of false triggers if not changed\n\n        vault.approve(rewards, type(uint256).max); // Allow rewards to be pulled\n    }\n\n    function setHealthCheck(address _healthCheck) external onlyVaultManagers {\n        emit SetHealthCheck(_healthCheck);\n        healthCheck = _healthCheck;\n    }\n\n    function setDoHealthCheck(bool _doHealthCheck) external onlyVaultManagers {\n        emit SetDoHealthCheck(_doHealthCheck);\n        doHealthCheck = _doHealthCheck;\n    }\n\n    /**\n     * @notice\n     *  Used to change `strategist`.\n     *\n     *  This may only be called by governance or the existing strategist.\n     * @param _strategist The new address to assign as `strategist`.\n     */\n    function setStrategist(address _strategist) external onlyAuthorized {\n        require(_strategist != address(0));\n        strategist = _strategist;\n        emit UpdatedStrategist(_strategist);\n    }\n\n    /**\n     * @notice\n     *  Used to change `keeper`.\n     *\n     *  `keeper` is the only address that may call `tend()` or `harvest()`,\n     *  other than `governance()` or `strategist`. However, unlike\n     *  `governance()` or `strategist`, `keeper` may *only* call `tend()`\n     *  and `harvest()`, and no other authorized functions, following the\n     *  principle of least privilege.\n     *\n     *  This may only be called by governance or the strategist.\n     * @param _keeper The new address to assign as `keeper`.\n     */\n    function setKeeper(address _keeper) external onlyAuthorized {\n        require(_keeper != address(0));\n        keeper = _keeper;\n        emit UpdatedKeeper(_keeper);\n    }\n\n    /**\n     * @notice\n     *  Used to change `rewards`. EOA or smart contract which has the permission\n     *  to pull rewards from the vault.\n     *\n     *  This may only be called by the strategist.\n     * @param _rewards The address to use for pulling rewards.\n     */\n    function setRewards(address _rewards) external onlyRewarder {\n        require(_rewards != address(0));\n        vault.approve(rewards, 0);\n        rewards = _rewards;\n        vault.approve(rewards, type(uint256).max);\n        emit UpdatedRewards(_rewards);\n    }\n\n    /**\n     * @notice\n     *  Used to change `minReportDelay`. `minReportDelay` is the minimum number\n     *  of blocks that should pass for `harvest()` to be called.\n     *\n     *  For external keepers (such as the Keep3r network), this is the minimum\n     *  time between jobs to wait. (see `harvestTrigger()`\n     *  for more details.)\n     *\n     *  This may only be called by governance or the strategist.\n     * @param _delay The minimum number of seconds to wait between harvests.\n     */\n    function setMinReportDelay(uint256 _delay) external onlyAuthorized {\n        minReportDelay = _delay;\n        emit UpdatedMinReportDelay(_delay);\n    }\n\n    /**\n     * @notice\n     *  Used to change `maxReportDelay`. `maxReportDelay` is the maximum number\n     *  of blocks that should pass for `harvest()` to be called.\n     *\n     *  For external keepers (such as the Keep3r network), this is the maximum\n     *  time between jobs to wait. (see `harvestTrigger()`\n     *  for more details.)\n     *\n     *  This may only be called by governance or the strategist.\n     * @param _delay The maximum number of seconds to wait between harvests.\n     */\n    function setMaxReportDelay(uint256 _delay) external onlyAuthorized {\n        maxReportDelay = _delay;\n        emit UpdatedMaxReportDelay(_delay);\n    }\n\n    /**\n     * @notice\n     *  Used to ensure that any significant credit a strategy has from the\n     *  vault will be automatically harvested.\n     *\n     *  This may only be called by governance or management.\n     * @param _creditThreshold The number of want tokens that will\n     *  automatically trigger a harvest.\n     */\n    function setCreditThreshold(uint256 _creditThreshold) external onlyVaultManagers {\n        creditThreshold = _creditThreshold;\n        emit UpdatedCreditThreshold(_creditThreshold);\n    }\n\n    /**\n     * @notice\n     *  Used to automatically trigger a harvest by our keepers. Can be\n     *  useful if gas prices are too high now, and we want to harvest\n     *  later once prices have lowered.\n     *\n     *  This may only be called by governance or management.\n     * @param _forceHarvestTriggerOnce Value of true tells keepers to harvest\n     *  our strategy\n     */\n    function setForceHarvestTriggerOnce(bool _forceHarvestTriggerOnce) external onlyVaultManagers {\n        forceHarvestTriggerOnce = _forceHarvestTriggerOnce;\n        emit ForcedHarvestTrigger(_forceHarvestTriggerOnce);\n    }\n\n    /**\n     * @notice\n     *  Used to set our baseFeeOracle, which checks the network's current base\n     *  fee price to determine whether it is an optimal time to harvest or tend.\n     *\n     *  This may only be called by governance or management.\n     * @param _baseFeeOracle Address of our baseFeeOracle\n     */\n    function setBaseFeeOracle(address _baseFeeOracle) external onlyVaultManagers {\n        baseFeeOracle = _baseFeeOracle;\n        emit UpdatedBaseFeeOracle(_baseFeeOracle);\n    }\n\n    /**\n     * @notice\n     *  Used to change `metadataURI`. `metadataURI` is used to store the URI\n     * of the file describing the strategy.\n     *\n     *  This may only be called by governance or the strategist.\n     * @param _metadataURI The URI that describe the strategy.\n     */\n    function setMetadataURI(string calldata _metadataURI) external onlyAuthorized {\n        metadataURI = _metadataURI;\n        emit UpdatedMetadataURI(_metadataURI);\n    }\n\n    /**\n     * Resolve governance address from Vault contract, used to make assertions\n     * on protected functions in the Strategy.\n     */\n    function governance() internal view returns (address) {\n        return vault.governance();\n    }\n\n    /**\n     * @notice\n     *  Provide an accurate conversion from `_amtInWei` (denominated in wei)\n     *  to `want` (using the native decimal characteristics of `want`).\n     * @dev\n     *  Care must be taken when working with decimals to assure that the conversion\n     *  is compatible. As an example:\n     *\n     *      given 1e17 wei (0.1 ETH) as input, and want is USDC (6 decimals),\n     *      with USDC/ETH = 1800, this should give back 1800000000 (180 USDC)\n     *\n     * @param _amtInWei The amount (in wei/1e-18 ETH) to convert to `want`\n     * @return The amount in `want` of `_amtInEth` converted to `want`\n     **/\n    function ethToWant(uint256 _amtInWei) public view virtual returns (uint256);\n\n    /**\n     * @notice\n     *  Provide an accurate estimate for the total amount of assets\n     *  (principle + return) that this Strategy is currently managing,\n     *  denominated in terms of `want` tokens.\n     *\n     *  This total should be \"realizable\" e.g. the total value that could\n     *  *actually* be obtained from this Strategy if it were to divest its\n     *  entire position based on current on-chain conditions.\n     * @dev\n     *  Care must be taken in using this function, since it relies on external\n     *  systems, which could be manipulated by the attacker to give an inflated\n     *  (or reduced) value produced by this function, based on current on-chain\n     *  conditions (e.g. this function is possible to influence through\n     *  flashloan attacks, oracle manipulations, or other DeFi attack\n     *  mechanisms).\n     *\n     *  It is up to governance to use this function to correctly order this\n     *  Strategy relative to its peers in the withdrawal queue to minimize\n     *  losses for the Vault based on sudden withdrawals. This value should be\n     *  higher than the total debt of the Strategy and higher than its expected\n     *  value to be \"safe\".\n     * @return The estimated total assets in this Strategy.\n     */\n    function estimatedTotalAssets() public view virtual returns (uint256);\n\n    /*\n     * @notice\n     *  Provide an indication of whether this strategy is currently \"active\"\n     *  in that it is managing an active position, or will manage a position in\n     *  the future. This should correlate to `harvest()` activity, so that Harvest\n     *  events can be tracked externally by indexing agents.\n     * @return True if the strategy is actively managing a position.\n     */\n    function isActive() public view returns (bool) {\n        return vault.strategies(address(this)).debtRatio > 0 || estimatedTotalAssets() > 0;\n    }\n\n    /**\n     * Perform any Strategy unwinding or other calls necessary to capture the\n     * \"free return\" this Strategy has generated since the last time its core\n     * position(s) were adjusted. Examples include unwrapping extra rewards.\n     * This call is only used during \"normal operation\" of a Strategy, and\n     * should be optimized to minimize losses as much as possible.\n     *\n     * This method returns any realized profits and/or realized losses\n     * incurred, and should return the total amounts of profits/losses/debt\n     * payments (in `want` tokens) for the Vault's accounting (e.g.\n     * `want.balanceOf(this) >= _debtPayment + _profit`).\n     *\n     * `_debtOutstanding` will be 0 if the Strategy is not past the configured\n     * debt limit, otherwise its value will be how far past the debt limit\n     * the Strategy is. The Strategy's debt limit is configured in the Vault.\n     *\n     * NOTE: `_debtPayment` should be less than or equal to `_debtOutstanding`.\n     *       It is okay for it to be less than `_debtOutstanding`, as that\n     *       should only used as a guide for how much is left to pay back.\n     *       Payments should be made to minimize loss from slippage, debt,\n     *       withdrawal fees, etc.\n     *\n     * See `vault.debtOutstanding()`.\n     */\n    function prepareReturn(uint256 _debtOutstanding)\n        internal\n        virtual\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        );\n\n    /**\n     * Perform any adjustments to the core position(s) of this Strategy given\n     * what change the Vault made in the \"investable capital\" available to the\n     * Strategy. Note that all \"free capital\" in the Strategy after the report\n     * was made is available for reinvestment. Also note that this number\n     * could be 0, and you should handle that scenario accordingly.\n     *\n     * See comments regarding `_debtOutstanding` on `prepareReturn()`.\n     */\n    function adjustPosition(uint256 _debtOutstanding) internal virtual;\n\n    /**\n     * Liquidate up to `_amountNeeded` of `want` of this strategy's positions,\n     * irregardless of slippage. Any excess will be re-invested with `adjustPosition()`.\n     * This function should return the amount of `want` tokens made available by the\n     * liquidation. If there is a difference between them, `_loss` indicates whether the\n     * difference is due to a realized loss, or if there is some other sitution at play\n     * (e.g. locked funds) where the amount made available is less than what is needed.\n     *\n     * NOTE: The invariant `_liquidatedAmount + _loss <= _amountNeeded` should always be maintained\n     */\n    function liquidatePosition(uint256 _amountNeeded) internal virtual returns (uint256 _liquidatedAmount, uint256 _loss);\n\n    /**\n     * Liquidate everything and returns the amount that got freed.\n     * This function is used during emergency exit instead of `prepareReturn()` to\n     * liquidate all of the Strategy's positions back to the Vault.\n     */\n\n    function liquidateAllPositions() internal virtual returns (uint256 _amountFreed);\n\n    /**\n     * @notice\n     *  Provide a signal to the keeper that `tend()` should be called. The\n     *  keeper will provide the estimated gas cost that they would pay to call\n     *  `tend()`, and this function should use that estimate to make a\n     *  determination if calling it is \"worth it\" for the keeper. This is not\n     *  the only consideration into issuing this trigger, for example if the\n     *  position would be negatively affected if `tend()` is not called\n     *  shortly, then this can return `true` even if the keeper might be\n     *  \"at a loss\" (keepers are always reimbursed by Yearn).\n     * @dev\n     *  `callCostInWei` must be priced in terms of `wei` (1e-18 ETH).\n     *\n     *  This call and `harvestTrigger()` should never return `true` at the same\n     *  time.\n     * @param callCostInWei The keeper's estimated gas cost to call `tend()` (in wei).\n     * @return `true` if `tend()` should be called, `false` otherwise.\n     */\n    function tendTrigger(uint256 callCostInWei) public view virtual returns (bool) {\n        // We usually don't need tend, but if there are positions that need\n        // active maintainence, overriding this function is how you would\n        // signal for that.\n        // If your implementation uses the cost of the call in want, you can\n        // use uint256 callCost = ethToWant(callCostInWei);\n        // It is highly suggested to use the baseFeeOracle here as well.\n\n        return false;\n    }\n\n    /**\n     * @notice\n     *  Adjust the Strategy's position. The purpose of tending isn't to\n     *  realize gains, but to maximize yield by reinvesting any returns.\n     *\n     *  See comments on `adjustPosition()`.\n     *\n     *  This may only be called by governance, the strategist, or the keeper.\n     */\n    function tend() external onlyKeepers {\n        // Don't take profits with this call, but adjust for better gains\n        adjustPosition(vault.debtOutstanding());\n    }\n\n    /**\n     * @notice\n     *  Provide a signal to the keeper that `harvest()` should be called. The\n     *  keeper will provide the estimated gas cost that they would pay to call\n     *  `harvest()`, and this function should use that estimate to make a\n     *  determination if calling it is \"worth it\" for the keeper. This is not\n     *  the only consideration into issuing this trigger, for example if the\n     *  position would be negatively affected if `harvest()` is not called\n     *  shortly, then this can return `true` even if the keeper might be \"at a\n     *  loss\" (keepers are always reimbursed by Yearn).\n     * @dev\n     *  `callCostInWei` must be priced in terms of `wei` (1e-18 ETH).\n     *\n     *  This call and `tendTrigger` should never return `true` at the\n     *  same time.\n     *\n     *  See `maxReportDelay`, `creditThreshold` to adjust the\n     *  strategist-controlled parameters that will influence whether this call\n     *  returns `true` or not. These parameters will be used in conjunction\n     *  with the parameters reported to the Vault (see `params`) to determine\n     *  if calling `harvest()` is merited.\n     *\n     *  This trigger also checks the network's base fee to avoid harvesting during\n     *  times of high network congestion.\n     *\n     *  Consider use of super.harvestTrigger() in any override to build on top\n     *  of this logic instead of replacing it. For example, if using `minReportDelay`.\n     *\n     *  It is expected that an external system will check `harvestTrigger()`.\n     *  This could be a script run off a desktop or cloud bot (e.g.\n     *  https://github.com/iearn-finance/yearn-vaults/blob/main/scripts/keep.py),\n     *  or via an integration with the Keep3r network (e.g.\n     *  https://github.com/Macarse/GenericKeep3rV2/blob/master/contracts/keep3r/GenericKeep3rV2.sol).\n     * @param callCostInWei The keeper's estimated gas cost to call `harvest()` (in wei).\n     * @return `true` if `harvest()` should be called, `false` otherwise.\n     */\n    function harvestTrigger(uint256 callCostInWei) public view virtual returns (bool) {\n        // Should not trigger if strategy is not active (no assets or no debtRatio)\n        if (!isActive()) return false;\n\n        // check if the base fee gas price is higher than we allow. if it is, block harvests.\n        if (!isBaseFeeAcceptable()) return false;\n\n        // trigger if we want to manually harvest, but only if our gas price is acceptable\n        if (forceHarvestTriggerOnce) return true;\n\n        // Should trigger if hasn't been called in a while\n        StrategyParams memory params = vault.strategies(address(this));\n        if ((block.timestamp - params.lastReport) >= maxReportDelay) return true;\n\n        // harvest our credit if it's above our threshold or return false\n        return (vault.creditAvailable() > creditThreshold);\n    }\n\n    /**\n     * @notice\n     *  Check if the current network base fee is below our external target. If\n     *  not, then harvestTrigger will return false.\n     * @return `true` if `harvest()` should be allowed, `false` otherwise.\n     */\n    function isBaseFeeAcceptable() public view returns (bool) {\n        if (baseFeeOracle == address(0)) return true;\n        else return IBaseFee(baseFeeOracle).isCurrentBaseFeeAcceptable();\n    }\n\n    /**\n     * @notice\n     *  Harvests the Strategy, recognizing any profits or losses and adjusting\n     *  the Strategy's position.\n     *\n     *  In the rare case the Strategy is in emergency shutdown, this will exit\n     *  the Strategy's position.\n     *\n     *  This may only be called by governance, the strategist, or the keeper.\n     * @dev\n     *  When `harvest()` is called, the Strategy reports to the Vault (via\n     *  `vault.report()`), so in some cases `harvest()` must be called in order\n     *  to take in profits, to borrow newly available funds from the Vault, or\n     *  otherwise adjust its position. In other cases `harvest()` must be\n     *  called to report to the Vault on the Strategy's position, especially if\n     *  any losses have occurred.\n     */\n    function harvest() external onlyKeepers {\n        uint256 profit = 0;\n        uint256 loss = 0;\n        uint256 debtOutstanding = vault.debtOutstanding();\n        uint256 debtPayment = 0;\n        if (emergencyExit) {\n            // Free up as much capital as possible\n            uint256 amountFreed = liquidateAllPositions();\n            if (amountFreed < debtOutstanding) {\n                loss = debtOutstanding - amountFreed;\n            } else if (amountFreed > debtOutstanding) {\n                profit = amountFreed - debtOutstanding;\n            }\n            debtPayment = debtOutstanding - loss;\n        } else {\n            // Free up returns for Vault to pull\n            (profit, loss, debtPayment) = prepareReturn(debtOutstanding);\n        }\n\n        // we're done harvesting, so reset our trigger if we used it\n        forceHarvestTriggerOnce = false;\n        emit ForcedHarvestTrigger(false);\n\n        // Allow Vault to take up to the \"harvested\" balance of this contract,\n        // which is the amount it has earned since the last time it reported to\n        // the Vault.\n        uint256 totalDebt = vault.strategies(address(this)).totalDebt;\n        debtOutstanding = vault.report(profit, loss, debtPayment);\n\n        // Check if free returns are left, and re-invest them\n        adjustPosition(debtOutstanding);\n\n        // call healthCheck contract\n        if (doHealthCheck && healthCheck != address(0)) {\n            require(HealthCheck(healthCheck).check(profit, loss, debtPayment, debtOutstanding, totalDebt), \"!healthcheck\");\n        } else {\n            emit SetDoHealthCheck(true);\n            doHealthCheck = true;\n        }\n\n        emit Harvested(profit, loss, debtPayment, debtOutstanding);\n    }\n\n    /**\n     * @notice\n     *  Withdraws `_amountNeeded` to `vault`.\n     *\n     *  This may only be called by the Vault.\n     * @param _amountNeeded How much `want` to withdraw.\n     * @return _loss Any realized losses\n     */\n    function withdraw(uint256 _amountNeeded) external returns (uint256 _loss) {\n        require(msg.sender == address(vault), \"!vault\");\n        // Liquidate as much as possible to `want`, up to `_amountNeeded`\n        uint256 amountFreed;\n        (amountFreed, _loss) = liquidatePosition(_amountNeeded);\n        // Send it directly back (NOTE: Using `msg.sender` saves some gas here)\n        want.safeTransfer(msg.sender, amountFreed);\n        // NOTE: Reinvest anything leftover on next `tend`/`harvest`\n    }\n\n    /**\n     * Do anything necessary to prepare this Strategy for migration, such as\n     * transferring any reserve or LP tokens, CDPs, or other tokens or stores of\n     * value.\n     */\n    function prepareMigration(address _newStrategy) internal virtual;\n\n    /**\n     * @notice\n     *  Transfers all `want` from this Strategy to `_newStrategy`.\n     *\n     *  This may only be called by the Vault.\n     * @dev\n     * The new Strategy's Vault must be the same as this Strategy's Vault.\n     *  The migration process should be carefully performed to make sure all\n     * the assets are migrated to the new address, which should have never\n     * interacted with the vault before.\n     * @param _newStrategy The Strategy to migrate to.\n     */\n    function migrate(address _newStrategy) external {\n        require(msg.sender == address(vault));\n        require(BaseStrategy(_newStrategy).vault() == vault);\n        prepareMigration(_newStrategy);\n        want.safeTransfer(_newStrategy, want.balanceOf(address(this)));\n    }\n\n    /**\n     * @notice\n     *  Activates emergency exit. Once activated, the Strategy will exit its\n     *  position upon the next harvest, depositing all funds into the Vault as\n     *  quickly as is reasonable given on-chain conditions.\n     *\n     *  This may only be called by governance or the strategist.\n     * @dev\n     *  See `vault.setEmergencyShutdown()` and `harvest()` for further details.\n     */\n    function setEmergencyExit() external onlyEmergencyAuthorized {\n        emergencyExit = true;\n        if (vault.strategies(address(this)).debtRatio != 0) {\n            vault.revokeStrategy();\n        }\n\n        emit EmergencyExitEnabled();\n    }\n\n    /**\n     * Override this to add all tokens/tokenized positions this contract\n     * manages on a *persistent* basis (e.g. not just for swapping back to\n     * want ephemerally).\n     *\n     * NOTE: Do *not* include `want`, already included in `sweep` below.\n     *\n     * Example:\n     * ```\n     *    function protectedTokens() internal override view returns (address[] memory) {\n     *      address[] memory protected = new address[](3);\n     *      protected[0] = tokenA;\n     *      protected[1] = tokenB;\n     *      protected[2] = tokenC;\n     *      return protected;\n     *    }\n     * ```\n     */\n    function protectedTokens() internal view virtual returns (address[] memory);\n\n    /**\n     * @notice\n     *  Removes tokens from this Strategy that are not the type of tokens\n     *  managed by this Strategy. This may be used in case of accidentally\n     *  sending the wrong kind of token to this Strategy.\n     *\n     *  Tokens will be sent to `governance()`.\n     *\n     *  This will fail if an attempt is made to sweep `want`, or any tokens\n     *  that are protected by this Strategy.\n     *\n     *  This may only be called by governance.\n     * @dev\n     *  Implement `protectedTokens()` to specify any additional tokens that\n     *  should be protected from sweeping in addition to `want`.\n     * @param _token The token to transfer out of this vault.\n     */\n    function sweep(address _token) external onlyGovernance {\n        require(_token != address(want), \"!want\");\n        require(_token != address(vault), \"!shares\");\n\n        address[] memory _protectedTokens = protectedTokens();\n        for (uint256 i; i < _protectedTokens.length; i++) require(_token != _protectedTokens[i], \"!protected\");\n\n        IERC20(_token).safeTransfer(governance(), IERC20(_token).balanceOf(address(this)));\n    }\n}\n\nabstract contract BaseStrategyInitializable is BaseStrategy {\n    bool public isOriginal = true;\n    event Cloned(address indexed clone);\n\n    constructor(address _vault) BaseStrategy(_vault) {}\n\n    function initialize(\n        address _vault,\n        address _strategist,\n        address _rewards,\n        address _keeper\n    ) external virtual {\n        _initialize(_vault, _strategist, _rewards, _keeper);\n    }\n\n    function clone(address _vault) external returns (address) {\n        return clone(_vault, msg.sender, msg.sender, msg.sender);\n    }\n\n    function clone(\n        address _vault,\n        address _strategist,\n        address _rewards,\n        address _keeper\n    ) public returns (address newStrategy) {\n        require(isOriginal, \"!clone\");\n        // Copied from https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.sol\n        bytes20 addressBytes = bytes20(address(this));\n\n        assembly {\n            // EIP-1167 bytecode\n            let clone_code := mload(0x40)\n            mstore(clone_code, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone_code, 0x14), addressBytes)\n            mstore(add(clone_code, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            newStrategy := create(0, clone_code, 0x37)\n        }\n\n        BaseStrategyInitializable(newStrategy).initialize(_vault, _strategist, _rewards, _keeper);\n\n        emit Cloned(newStrategy);\n    }\n}\n","imports":[".cache/OpenZeppelin/v4.7.1/token/ERC20/ERC20.sol",".cache/OpenZeppelin/v4.7.1/token/ERC20/IERC20.sol",".cache/OpenZeppelin/v4.7.1/token/ERC20/utils/SafeERC20.sol"],"references":["test/TestStrategy.sol"],"urls":[]},"CommonHealthCheck.sol":{"checksum":{"algorithm":"md5","hash":"0x87833dd9b39aec31e476d2c4105932c1"},"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.15;\npragma experimental ABIEncoderV2;\n\ninterface CustomHealthCheck {\n    function check(\n        uint256 profit,\n        uint256 loss,\n        uint256 debtPayment,\n        uint256 debtOutstanding,\n        address callerStrategy\n    ) external view returns (bool);\n}\n\n// LEGACY INTERFACES PRE 0.3.2\nstruct LegacyStrategyParams {\n    uint256 performanceFee;\n    uint256 activation;\n    uint256 debtRatio;\n    uint256 rateLimit;\n    uint256 lastReport;\n    uint256 totalDebt;\n    uint256 totalGain;\n    uint256 totalLoss;\n}\n\nstruct Limits {\n    uint256 profitLimitRatio;\n    uint256 lossLimitRatio;\n    bool exists;\n}\n\ncontract CommonHealthCheck {\n    // Default Settings for all strategies\n    uint256 constant MAX_BPS = 10_000;\n    uint256 public profitLimitRatio;\n    uint256 public lossLimitRatio;\n    mapping(address => Limits) public strategiesLimits;\n\n    address public governance;\n    address public management;\n\n    mapping(address => address) public checks;\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"!authorized\");\n        _;\n    }\n\n    modifier onlyAuthorized() {\n        require(msg.sender == governance || msg.sender == management, \"!authorized\");\n        _;\n    }\n\n    constructor() {\n        governance = msg.sender;\n        management = msg.sender;\n        profitLimitRatio = 300;\n        lossLimitRatio = 100;\n    }\n\n    function setGovernance(address _governance) external onlyGovernance {\n        require(_governance != address(0));\n        governance = _governance;\n    }\n\n    function setManagement(address _management) external onlyGovernance {\n        require(_management != address(0));\n        management = _management;\n    }\n\n    function setProfitLimitRatio(uint256 _profitLimitRatio) external onlyAuthorized {\n        require(_profitLimitRatio < MAX_BPS);\n        profitLimitRatio = _profitLimitRatio;\n    }\n\n    function setlossLimitRatio(uint256 _lossLimitRatio) external onlyAuthorized {\n        require(_lossLimitRatio < MAX_BPS);\n        lossLimitRatio = _lossLimitRatio;\n    }\n\n    function setStrategyLimits(\n        address _strategy,\n        uint256 _profitLimitRatio,\n        uint256 _lossLimitRatio\n    ) external onlyAuthorized {\n        require(_lossLimitRatio < MAX_BPS);\n        require(_profitLimitRatio < MAX_BPS);\n        strategiesLimits[_strategy] = Limits(_profitLimitRatio, _lossLimitRatio, true);\n    }\n\n    function setCheck(address _strategy, address _check) external onlyAuthorized {\n        checks[_strategy] = _check;\n    }\n\n    function check(\n        uint256 profit,\n        uint256 loss,\n        uint256 debtPayment,\n        uint256 debtOutstanding,\n        uint256 totalDebt\n    ) external view returns (bool) {\n        return _runChecks(profit, loss, debtPayment, debtOutstanding, totalDebt);\n    }\n\n    function _runChecks(\n        uint256 profit,\n        uint256 loss,\n        uint256 debtPayment,\n        uint256 debtOutstanding,\n        uint256 totalDebt\n    ) internal view returns (bool) {\n        address customCheck = checks[msg.sender];\n\n        if (customCheck == address(0)) {\n            return _executeDefaultCheck(profit, loss, totalDebt);\n        }\n\n        return CustomHealthCheck(customCheck).check(profit, loss, debtPayment, debtOutstanding, msg.sender);\n    }\n\n    function _executeDefaultCheck(\n        uint256 _profit,\n        uint256 _loss,\n        uint256 _totalDebt\n    ) internal view returns (bool) {\n        Limits memory limits = strategiesLimits[msg.sender];\n        uint256 _profitLimitRatio;\n        uint256 _lossLimitRatio;\n        if (limits.exists) {\n            _profitLimitRatio = limits.profitLimitRatio;\n            _lossLimitRatio = limits.lossLimitRatio;\n        } else {\n            _profitLimitRatio = profitLimitRatio;\n            _lossLimitRatio = lossLimitRatio;\n        }\n\n        if (_profit > ((_totalDebt * _profitLimitRatio) / MAX_BPS)) {\n            return false;\n        }\n        if (_loss > ((_totalDebt * _lossLimitRatio) / MAX_BPS)) {\n            return false;\n        }\n        return true;\n    }\n}\n","imports":[],"references":[],"urls":[]},"Registry.vy":{"checksum":{"algorithm":"md5","hash":"0x3841f3debce6088c8c520e438e59d458"},"content":"# @version 0.2.11\n\n\ninterface Vault:\n    def token() -> address: view\n    def apiVersion() -> String[28]: view\n    def governance() -> address: view\n    def initialize(\n        token: address,\n        governance: address,\n        rewards: address,\n        name: String[64],\n        symbol: String[32],\n        guardian: address,\n    ): nonpayable\n\n\n# len(releases)\nnumReleases: public(uint256)\nreleases: public(HashMap[uint256, address])\n\n# Token => len(vaults)\nnumVaults: public(HashMap[address, uint256])\nvaults: public(HashMap[address, HashMap[uint256, address]])\n\n# Index of token added => token address\ntokens: public(HashMap[uint256, address])\n# len(tokens)\nnumTokens: public(uint256)\n# Inclusion check for token\nisRegistered: public(HashMap[address, bool])\n\n# 2-phase commit\ngovernance: public(address)\npendingGovernance: public(address)\n\ntags: public(HashMap[address, String[120]])\nbanksy: public(HashMap[address, bool])  # could be anyone\n\nevent NewRelease:\n    release_id: indexed(uint256)\n    template: address\n    api_version: String[28]\n\nevent NewVault:\n    token: indexed(address)\n    vault_id: indexed(uint256)\n    vault: address\n    api_version: String[28]\n\nevent NewExperimentalVault:\n    token: indexed(address)\n    deployer: indexed(address)\n    vault: address\n    api_version: String[28]\n\nevent NewGovernance:\n    governance: address\n\nevent VaultTagged:\n    vault: address\n    tag: String[120]\n\n@external\ndef __init__():\n    self.governance = msg.sender\n\n\n@external\ndef setGovernance(governance: address):\n    \"\"\"\n    @notice Starts the 1st phase of the governance transfer.\n    @dev Throws if the caller is not current governance.\n    @param governance The next governance address\n    \"\"\"\n    assert msg.sender == self.governance  # dev: unauthorized\n    self.pendingGovernance = governance\n\n\n@external\ndef acceptGovernance():\n    \"\"\"\n    @notice Completes the 2nd phase of the governance transfer.\n    @dev\n        Throws if the caller is not the pending caller.\n        Emits a `NewGovernance` event.\n    \"\"\"\n    assert msg.sender == self.pendingGovernance  # dev: unauthorized\n    self.governance = msg.sender\n    log NewGovernance(msg.sender)\n\n\n@view\n@external\ndef latestRelease() -> String[28]:\n    \"\"\"\n    @notice Returns the api version of the latest release.\n    @dev Throws if no releases are registered yet.\n    @return The api version of the latest release.\n    \"\"\"\n    # NOTE: Throws if there has not been a release yet\n    return Vault(self.releases[self.numReleases - 1]).apiVersion()  # dev: no release\n\n\n@view\n@external\ndef latestVault(token: address) -> address:\n    \"\"\"\n    @notice Returns the latest deployed vault for the given token.\n    @dev Throws if no vaults are endorsed yet for the given token.\n    @param token The token address to find the latest vault for.\n    @return The address of the latest vault for the given token.\n    \"\"\"\n    # NOTE: Throws if there has not been a deployed vault yet for this token\n    return self.vaults[token][self.numVaults[token] - 1]  # dev: no vault for token\n\n\n@external\ndef newRelease(vault: address):\n    \"\"\"\n    @notice\n        Add a previously deployed Vault as the template contract for the latest release,\n        to be used by further \"forwarder-style\" delegatecall proxy contracts that can be\n        deployed from the registry throw other methods (to save gas).\n    @dev\n        Throws if caller isn't `self.governance`.\n        Throws if `vault`'s governance isn't `self.governance`.\n        Throws if the api version is the same as the previous release.\n        Emits a `NewVault` event.\n    @param vault The vault that will be used as the template contract for the next release.\n    \"\"\"\n    assert msg.sender == self.governance  # dev: unauthorized\n\n    # Check if the release is different from the current one\n    # NOTE: This doesn't check for strict semver-style linearly increasing release versions\n    release_id: uint256 = self.numReleases  # Next id in series\n    if release_id > 0:\n        assert (\n            Vault(self.releases[release_id - 1]).apiVersion()\n            != Vault(vault).apiVersion()\n        )  # dev: same api version\n    # else: we are adding the first release to the Registry!\n\n    # Update latest release\n    self.releases[release_id] = vault\n    self.numReleases = release_id + 1\n\n    # Log the release for external listeners (e.g. Graph)\n    log NewRelease(release_id, vault, Vault(vault).apiVersion())\n\n\n@internal\ndef _newProxyVault(\n    token: address,\n    governance: address,\n    rewards: address,\n    guardian: address,\n    name: String[64],\n    symbol: String[32],\n    releaseTarget: uint256,\n) -> address:\n    release: address = self.releases[releaseTarget]\n    assert release != ZERO_ADDRESS  # dev: unknown release\n    vault: address = create_forwarder_to(release)\n\n    # NOTE: Must initialize the Vault atomically with deploying it\n    Vault(vault).initialize(token, governance, rewards, name, symbol, guardian)\n\n    return vault\n\n\n@internal\ndef _registerVault(token: address, vault: address):\n    # Check if there is an existing deployment for this token at the particular api version\n    # NOTE: This doesn't check for strict semver-style linearly increasing release versions\n    vault_id: uint256 = self.numVaults[token]  # Next id in series\n    if vault_id > 0:\n        assert (\n            Vault(self.vaults[token][vault_id - 1]).apiVersion()\n            != Vault(vault).apiVersion()\n        )  # dev: same api version\n    # else: we are adding a new token to the Registry\n\n    # Update the latest deployment\n    self.vaults[token][vault_id] = vault\n    self.numVaults[token] = vault_id + 1\n\n    # Register tokens for endorsed vaults\n    if not self.isRegistered[token]:\n        self.isRegistered[token] = True\n        self.tokens[self.numTokens] = token\n        self.numTokens += 1\n\n    # Log the deployment for external listeners (e.g. Graph)\n    log NewVault(token, vault_id, vault, Vault(vault).apiVersion())\n\n\n@external\ndef newVault(\n    token: address,\n    guardian: address,\n    rewards: address,\n    name: String[64],\n    symbol: String[32],\n    releaseDelta: uint256 = 0,  # NOTE: Uses latest by default\n) -> address:\n    \"\"\"\n    @notice\n        Create a new vault for the given token using the latest release in the registry,\n        as a simple \"forwarder-style\" delegatecall proxy to the latest release. Also adds\n        the new vault to the list of \"endorsed\" vaults for that token.\n    @dev\n        `governance` is set in the new vault as `self.governance`, with no ability to override.\n        Throws if caller isn't `self.governance`.\n        Throws if no releases are registered yet.\n        Throws if there already is a registered vault for the given token with the latest api version.\n        Emits a `NewVault` event.\n    @param token The token that may be deposited into the new Vault.\n    @param guardian The address authorized for guardian interactions in the new Vault.\n    @param rewards The address to use for collecting rewards in the new Vault\n    @param name Specify a custom Vault name. Set to empty string for default choice.\n    @param symbol Specify a custom Vault symbol name. Set to empty string for default choice.\n    @param releaseDelta Specify the number of releases prior to the latest to use as a target. Default is latest.\n    @return The address of the newly-deployed vault\n    \"\"\"\n    assert msg.sender == self.governance  # dev: unauthorized\n\n    # NOTE: Underflow if no releases created yet, or targeting prior to release history\n    releaseTarget: uint256 = self.numReleases - 1 - releaseDelta  # dev: no releases\n    vault: address = self._newProxyVault(token, msg.sender, rewards, guardian, name, symbol, releaseTarget)\n\n    self._registerVault(token, vault)\n\n    return vault\n\n\n@external\ndef newExperimentalVault(\n    token: address,\n    governance: address,\n    guardian: address,\n    rewards: address,\n    name: String[64],\n    symbol: String[32],\n    releaseDelta: uint256 = 0,  # NOTE: Uses latest by default\n) -> address:\n    \"\"\"\n    @notice\n        Create a new vault for the given token using the latest release in the registry,\n        as a simple \"forwarder-style\" delegatecall proxy to the latest release. Does not add\n        the new vault to the list of \"endorsed\" vaults for that token.\n    @dev\n        Throws if no releases are registered yet.\n        Emits a `NewExperimentalVault` event.\n    @param token The token that may be deposited into the new Vault.\n    @param governance The address authorized for governance interactions in the new Vault.\n    @param guardian The address authorized for guardian interactions in the new Vault.\n    @param rewards The address to use for collecting rewards in the new Vault\n    @param name Specify a custom Vault name. Set to empty string for default choice.\n    @param symbol Specify a custom Vault symbol name. Set to empty string for default choice.\n    @param releaseDelta Specify the number of releases prior to the latest to use as a target. Default is latest.\n    @return The address of the newly-deployed vault\n    \"\"\"\n    # NOTE: Underflow if no releases created yet, or targeting prior to release history\n    releaseTarget: uint256 = self.numReleases - 1 - releaseDelta  # dev: no releases\n    # NOTE: Anyone can call this method, as a convenience to Strategist' experiments\n    vault: address = self._newProxyVault(token, governance, rewards, guardian, name, symbol, releaseTarget)\n\n    # NOTE: Not registered, so emit an \"experiment\" event here instead\n    log NewExperimentalVault(token, msg.sender, vault, Vault(vault).apiVersion())\n\n    return vault\n\n\n@external\ndef endorseVault(vault: address, releaseDelta: uint256 = 0):\n    \"\"\"\n    @notice\n        Adds an existing vault to the list of \"endorsed\" vaults for that token.\n    @dev\n        `governance` is set in the new vault as `self.governance`, with no ability to override.\n        Throws if caller isn't `self.governance`.\n        Throws if `vault`'s governance isn't `self.governance`.\n        Throws if no releases are registered yet.\n        Throws if `vault`'s api version does not match latest release.\n        Throws if there already is a deployment for the vault's token with the latest api version.\n        Emits a `NewVault` event.\n    @param vault The vault that will be endorsed by the Registry.\n    @param releaseDelta Specify the number of releases prior to the latest to use as a target. Default is latest.\n    \"\"\"\n    assert msg.sender == self.governance  # dev: unauthorized\n    assert Vault(vault).governance() == msg.sender  # dev: not governed\n\n    # NOTE: Underflow if no releases created yet, or targeting prior to release history\n    releaseTarget: uint256 = self.numReleases - 1 - releaseDelta  # dev: no releases\n    api_version: String[28] = Vault(self.releases[releaseTarget]).apiVersion()\n    assert Vault(vault).apiVersion() == api_version  # dev: not target release\n\n    # Add to the end of the list of vaults for token\n    self._registerVault(Vault(vault).token(), vault)\n\n\n@external\ndef setBanksy(tagger: address, allowed: bool = True):\n    \"\"\"\n    @notice Set the ability of a particular tagger to tag current vaults.\n    @dev Throws if caller is not `self.governance`.\n    @param tagger The address to approve or deny access to tagging.\n    @param allowed Whether to approve or deny `tagger`. Defaults to approve.\n    \"\"\"\n    assert msg.sender == self.governance  # dev: unauthorized\n    self.banksy[tagger] = allowed\n\n\n@external\ndef tagVault(vault: address, tag: String[120]):\n    \"\"\"\n    @notice Tag a Vault with a message.\n    @dev\n        Throws if caller is not `self.governance` or an approved tagger.\n        Emits a `VaultTagged` event.\n    @param vault The address to tag with the given `tag` message.\n    @param tag The message to tag `vault` with.\n    \"\"\"\n    if msg.sender != self.governance:\n        assert self.banksy[msg.sender]  # dev: not banksy\n    # else: we are governance, we can do anything banksy can do\n\n    self.tags[vault] = tag\n    log VaultTagged(vault, tag)\n","imports":[],"references":[],"urls":[]},"Vault.vy":{"checksum":{"algorithm":"md5","hash":"0xfbe847f7a2556d4033c4b1b5bb7bb27e"},"content":"# @version 0.3.3\n\"\"\"\n@title Yearn Token Vault\n@license GNU AGPLv3\n@author yearn.finance\n@notice\n    Yearn Token Vault. Holds an underlying token, and allows users to interact\n    with the Yearn ecosystem through Strategies connected to the Vault.\n    Vaults are not limited to a single Strategy, they can have as many Strategies\n    as can be designed (however the withdrawal queue is capped at 20.)\n\n    Deposited funds are moved into the most impactful strategy that has not\n    already reached its limit for assets under management, regardless of which\n    Strategy a user's funds end up in, they receive their portion of yields\n    generated across all Strategies.\n\n    When a user withdraws, if there are no funds sitting undeployed in the\n    Vault, the Vault withdraws funds from Strategies in the order of least\n    impact. (Funds are taken from the Strategy that will disturb everyone's\n    gains the least, then the next least, etc.) In order to achieve this, the\n    withdrawal queue's order must be properly set and managed by the community\n    (through governance).\n\n    Vault Strategies are parameterized to pursue the highest risk-adjusted yield.\n\n    There is an \"Emergency Shutdown\" mode. When the Vault is put into emergency\n    shutdown, assets will be recalled from the Strategies as quickly as is\n    practical (given on-chain conditions), minimizing loss. Deposits are\n    halted, new Strategies may not be added, and each Strategy exits with the\n    minimum possible damage to position, while opening up deposits to be\n    withdrawn by users. There are no restrictions on withdrawals above what is\n    expected under Normal Operation.\n\n    For further details, please refer to the specification:\n    https://github.com/iearn-finance/yearn-vaults/blob/main/SPECIFICATION.md\n\"\"\"\n\nAPI_VERSION: constant(String[28]) = \"0.4.5\"\n\nfrom vyper.interfaces import ERC20\n\nimplements: ERC20\n\n\ninterface DetailedERC20:\n    def name() -> String[42]: view\n    def symbol() -> String[20]: view\n    def decimals() -> uint256: view\n\n\ninterface Strategy:\n    def want() -> address: view\n    def vault() -> address: view\n    def isActive() -> bool: view\n    def delegatedAssets() -> uint256: view\n    def estimatedTotalAssets() -> uint256: view\n    def withdraw(_amount: uint256) -> uint256: nonpayable\n    def migrate(_newStrategy: address): nonpayable\n    def emergencyExit() -> bool: view\n\nname: public(String[64])\nsymbol: public(String[32])\ndecimals: public(uint256)\n\nbalanceOf: public(HashMap[address, uint256])\nallowance: public(HashMap[address, HashMap[address, uint256]])\ntotalSupply: public(uint256)\n\ntoken: public(ERC20)\ngovernance: public(address)\nmanagement: public(address)\nguardian: public(address)\npendingGovernance: address\n\nstruct StrategyParams:\n    performanceFee: uint256  # Strategist's fee (basis points)\n    activation: uint256  # Activation block.timestamp\n    debtRatio: uint256  # Maximum borrow amount (in BPS of total assets)\n    minDebtPerHarvest: uint256  # Lower limit on the increase of debt since last harvest\n    maxDebtPerHarvest: uint256  # Upper limit on the increase of debt since last harvest\n    lastReport: uint256  # block.timestamp of the last time a report occured\n    totalDebt: uint256  # Total outstanding debt that Strategy has\n    totalGain: uint256  # Total returns that Strategy has realized for Vault\n    totalLoss: uint256  # Total losses that Strategy has realized for Vault\n\nevent Transfer:\n    sender: indexed(address)\n    receiver: indexed(address)\n    value: uint256\n\n\nevent Approval:\n    owner: indexed(address)\n    spender: indexed(address)\n    value: uint256\n\nevent Deposit:\n    recipient: indexed(address)\n    shares: uint256\n    amount: uint256\n\nevent Withdraw:\n    recipient: indexed(address)\n    shares: uint256\n    amount: uint256\n\nevent Sweep:\n    token: indexed(address)\n    amount: uint256\n\nevent LockedProfitDegradationUpdated:\n    value: uint256\n\nevent StrategyAdded:\n    strategy: indexed(address)\n    debtRatio: uint256  # Maximum borrow amount (in BPS of total assets)\n    minDebtPerHarvest: uint256  # Lower limit on the increase of debt since last harvest\n    maxDebtPerHarvest: uint256  # Upper limit on the increase of debt since last harvest\n    performanceFee: uint256  # Strategist's fee (basis points)\n\n\nevent StrategyReported:\n    strategy: indexed(address)\n    gain: uint256\n    loss: uint256\n    debtPaid: uint256\n    totalGain: uint256\n    totalLoss: uint256\n    totalDebt: uint256\n    debtAdded: uint256\n    debtRatio: uint256\n\nevent FeeReport:\n    management_fee: uint256\n    performance_fee: uint256\n    strategist_fee: uint256\n    duration: uint256\n\nevent WithdrawFromStrategy:\n    strategy: indexed(address)\n    totalDebt: uint256\n    loss: uint256\n\nevent UpdateGovernance:\n    governance: address # New active governance\n\n\nevent UpdateManagement:\n    management: address # New active manager\n\nevent UpdateRewards:\n    rewards: address # New active rewards recipient\n\n\nevent UpdateDepositLimit:\n    depositLimit: uint256 # New active deposit limit\n\n\nevent UpdatePerformanceFee:\n    performanceFee: uint256 # New active performance fee\n\n\nevent UpdateManagementFee:\n    managementFee: uint256 # New active management fee\n\n\nevent UpdateGuardian:\n    guardian: address # Address of the active guardian\n\n\nevent EmergencyShutdown:\n    active: bool # New emergency shutdown state (if false, normal operation enabled)\n\n\nevent UpdateWithdrawalQueue:\n    queue: address[MAXIMUM_STRATEGIES] # New active withdrawal queue\n\n\nevent StrategyUpdateDebtRatio:\n    strategy: indexed(address) # Address of the strategy for the debt ratio adjustment\n    debtRatio: uint256 # The new debt limit for the strategy (in BPS of total assets)\n\n\nevent StrategyUpdateMinDebtPerHarvest:\n    strategy: indexed(address) # Address of the strategy for the rate limit adjustment\n    minDebtPerHarvest: uint256  # Lower limit on the increase of debt since last harvest\n\n\nevent StrategyUpdateMaxDebtPerHarvest:\n    strategy: indexed(address) # Address of the strategy for the rate limit adjustment\n    maxDebtPerHarvest: uint256  # Upper limit on the increase of debt since last harvest\n\n\nevent StrategyUpdatePerformanceFee:\n    strategy: indexed(address) # Address of the strategy for the performance fee adjustment\n    performanceFee: uint256 # The new performance fee for the strategy\n\n\nevent StrategyMigrated:\n    oldVersion: indexed(address) # Old version of the strategy to be migrated\n    newVersion: indexed(address) # New version of the strategy\n\n\nevent StrategyRevoked:\n    strategy: indexed(address) # Address of the strategy that is revoked\n\n\nevent StrategyRemovedFromQueue:\n    strategy: indexed(address) # Address of the strategy that is removed from the withdrawal queue\n\n\nevent StrategyAddedToQueue:\n    strategy: indexed(address) # Address of the strategy that is added to the withdrawal queue\n\nevent NewPendingGovernance:\n    pendingGovernance: indexed(address)\n\n# NOTE: Track the total for overhead targeting purposes\nstrategies: public(HashMap[address, StrategyParams])\nMAXIMUM_STRATEGIES: constant(uint256) = 20\nDEGRADATION_COEFFICIENT: constant(uint256) = 10 ** 18\n\n# Ordering that `withdraw` uses to determine which strategies to pull funds from\n# NOTE: Does *NOT* have to match the ordering of all the current strategies that\n#       exist, but it is recommended that it does or else withdrawal depth is\n#       limited to only those inside the queue.\n# NOTE: Ordering is determined by governance, and should be balanced according\n#       to risk, slippage, and/or volatility. Can also be ordered to increase the\n#       withdrawal speed of a particular Strategy.\n# NOTE: The first time a ZERO_ADDRESS is encountered, it stops withdrawing\nwithdrawalQueue: public(address[MAXIMUM_STRATEGIES])\n\nemergencyShutdown: public(bool)\n\ndepositLimit: public(uint256)  # Limit for totalAssets the Vault can hold\ndebtRatio: public(uint256)  # Debt ratio for the Vault across all strategies (in BPS, <= 10k)\ntotalIdle: public(uint256)  # Amount of tokens that are in the vault\ntotalDebt: public(uint256)  # Amount of tokens that all strategies have borrowed\nlastReport: public(uint256)  # block.timestamp of last report\nactivation: public(uint256)  # block.timestamp of contract deployment\nlockedProfit: public(uint256) # how much profit is locked and cant be withdrawn\nlockedProfitDegradation: public(uint256) # rate per block of degradation. DEGRADATION_COEFFICIENT is 100% per block\nrewards: public(address)  # Rewards contract where Governance fees are sent to\n# Governance Fee for management of Vault (given to `rewards`)\nmanagementFee: public(uint256)\n# Governance Fee for performance of Vault (given to `rewards`)\nperformanceFee: public(uint256)\nMAX_BPS: constant(uint256) = 10_000  # 100%, or 10k basis points\n# NOTE: A four-century period will be missing 3 of its 100 Julian leap years, leaving 97.\n#       So the average year has 365 + 97/400 = 365.2425 days\n#       ERROR(Julian): -0.0078\n#       ERROR(Gregorian): -0.0003\n#       A day = 24 * 60 * 60 sec = 86400 sec\n#       365.2425 * 86400 = 31556952.0\nSECS_PER_YEAR: constant(uint256) = 31_556_952  # 365.2425 days\n# `nonces` track `permit` approvals with signature.\nnonces: public(HashMap[address, uint256])\nDOMAIN_TYPE_HASH: constant(bytes32) = keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\nPERMIT_TYPE_HASH: constant(bytes32) = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n\n\n@external\ndef initialize(\n    token: address,\n    governance: address,\n    rewards: address,\n    nameOverride: String[64],\n    symbolOverride: String[32],\n    guardian: address = msg.sender,\n    management: address =  msg.sender,\n):\n    \"\"\"\n    @notice\n        Initializes the Vault, this is called only once, when the contract is\n        deployed.\n        The performance fee is set to 10% of yield, per Strategy.\n        The management fee is set to 2%, per year.\n        The initial deposit limit is set to 0 (deposits disabled); it must be\n        updated after initialization.\n    @dev\n        If `nameOverride` is not specified, the name will be 'yearn'\n        combined with the name of `token`.\n\n        If `symbolOverride` is not specified, the symbol will be 'yv'\n        combined with the symbol of `token`.\n\n        The token used by the vault should not change balances outside transfers and \n        it must transfer the exact amount requested. Fee on transfer and rebasing are not supported.\n    @param token The token that may be deposited into this Vault.\n    @param governance The address authorized for governance interactions.\n    @param rewards The address to distribute rewards to.\n    @param management The address of the vault manager.\n    @param nameOverride Specify a custom Vault name. Leave empty for default choice.\n    @param symbolOverride Specify a custom Vault symbol name. Leave empty for default choice.\n    @param guardian The address authorized for guardian interactions. Defaults to caller.\n    \"\"\"\n    assert self.activation == 0  # dev: no devops199\n    self.token = ERC20(token)\n    if nameOverride == \"\":\n        self.name = concat(DetailedERC20(token).symbol(), \" yVault\")\n    else:\n        self.name = nameOverride\n    if symbolOverride == \"\":\n        self.symbol = concat(\"yv\", DetailedERC20(token).symbol())\n    else:\n        self.symbol = symbolOverride\n    decimals: uint256 = DetailedERC20(token).decimals()\n    self.decimals = decimals\n    assert decimals < 256 # dev: see VVE-2020-0001\n\n    self.governance = governance\n    log UpdateGovernance(governance)\n    self.management = management\n    log UpdateManagement(management)\n    self.rewards = rewards\n    log UpdateRewards(rewards)\n    self.guardian = guardian\n    log UpdateGuardian(guardian)\n    self.performanceFee = 1000  # 10% of yield (per Strategy)\n    log UpdatePerformanceFee(convert(1000, uint256))\n    self.managementFee = 200  # 2% per year\n    log UpdateManagementFee(convert(200, uint256))\n    self.lastReport = block.timestamp\n    self.activation = block.timestamp\n    self.lockedProfitDegradation = convert(DEGRADATION_COEFFICIENT * 46 / 10 ** 6 , uint256) # 6 hours in blocks\n    # EIP-712\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    \"\"\"\n    @notice\n        Used to track the deployed version of this contract. In practice you\n        can use this version number to compare with Yearn's GitHub and\n        determine which version of the source matches this deployed contract.\n    @dev\n        All strategies must have an `apiVersion()` that matches the Vault's\n        `API_VERSION`.\n    @return API_VERSION which holds the current version of this contract.\n    \"\"\"\n    return API_VERSION\n\n@view\n@internal\ndef domain_separator() -> bytes32:\n    return keccak256(\n        concat(\n            DOMAIN_TYPE_HASH,\n            keccak256(convert(\"Yearn Vault\", Bytes[11])),\n            keccak256(convert(API_VERSION, Bytes[28])),\n            convert(chain.id, bytes32),\n            convert(self, bytes32)\n        )\n    )\n\n@view\n@external\ndef DOMAIN_SEPARATOR() -> bytes32:\n    return self.domain_separator()\n\n@external\ndef setName(name: String[42]):\n    \"\"\"\n    @notice\n        Used to change the value of `name`.\n\n        This may only be called by governance.\n    @param name The new name to use.\n    \"\"\"\n    assert msg.sender == self.governance\n    self.name = name\n\n\n@external\ndef setSymbol(symbol: String[20]):\n    \"\"\"\n    @notice\n        Used to change the value of `symbol`.\n\n        This may only be called by governance.\n    @param symbol The new symbol to use.\n    \"\"\"\n    assert msg.sender == self.governance\n    self.symbol = symbol\n\n\n# 2-phase commit for a change in governance\n@external\ndef setGovernance(governance: address):\n    \"\"\"\n    @notice\n        Nominate a new address to use as governance.\n\n        The change does not go into effect immediately. This function sets a\n        pending change, and the governance address is not updated until\n        the proposed governance address has accepted the responsibility.\n\n        This may only be called by the current governance address.\n    @param governance The address requested to take over Vault governance.\n    \"\"\"\n    assert msg.sender == self.governance\n    log NewPendingGovernance(governance)\n    self.pendingGovernance = governance\n\n\n@external\ndef acceptGovernance():\n    \"\"\"\n    @notice\n        Once a new governance address has been proposed using setGovernance(),\n        this function may be called by the proposed address to accept the\n        responsibility of taking over governance for this contract.\n\n        This may only be called by the proposed governance address.\n    @dev\n        setGovernance() should be called by the existing governance address,\n        prior to calling this function.\n    \"\"\"\n    assert msg.sender == self.pendingGovernance\n    self.governance = msg.sender\n    log UpdateGovernance(msg.sender)\n\n\n@external\ndef setManagement(management: address):\n    \"\"\"\n    @notice\n        Changes the management address.\n        Management is able to make some investment decisions adjusting parameters.\n\n        This may only be called by governance.\n    @param management The address to use for managing.\n    \"\"\"\n    assert msg.sender == self.governance\n    self.management = management\n    log UpdateManagement(management)\n\n\n@external\ndef setRewards(rewards: address):\n    \"\"\"\n    @notice\n        Changes the rewards address. Any distributed rewards\n        will cease flowing to the old address and begin flowing\n        to this address once the change is in effect.\n\n        This will not change any Strategy reports in progress, only\n        new reports made after this change goes into effect.\n\n        This may only be called by governance.\n    @param rewards The address to use for collecting rewards.\n    \"\"\"\n    assert msg.sender == self.governance\n    assert not (rewards in [self, ZERO_ADDRESS])\n    self.rewards = rewards\n    log UpdateRewards(rewards)\n\n\n@external\ndef setLockedProfitDegradation(degradation: uint256):\n    \"\"\"\n    @notice\n        Changes the locked profit degradation.\n    @param degradation The rate of degradation in percent per second scaled to 1e18.\n    \"\"\"\n    assert msg.sender == self.governance\n    # Since \"degradation\" is of type uint256 it can never be less than zero\n    assert degradation <= DEGRADATION_COEFFICIENT\n    self.lockedProfitDegradation = degradation\n    log LockedProfitDegradationUpdated(degradation) \n\n\n@external\ndef setDepositLimit(limit: uint256):\n    \"\"\"\n    @notice\n        Changes the maximum amount of tokens that can be deposited in this Vault.\n\n        Note, this is not how much may be deposited by a single depositor,\n        but the maximum amount that may be deposited across all depositors.\n\n        This may only be called by governance.\n    @param limit The new deposit limit to use.\n    \"\"\"\n    assert msg.sender == self.governance\n    self.depositLimit = limit\n    log UpdateDepositLimit(limit)\n\n\n@external\ndef setPerformanceFee(fee: uint256):\n    \"\"\"\n    @notice\n        Used to change the value of `performanceFee`.\n\n        Should set this value below the maximum strategist performance fee.\n\n        This may only be called by governance.\n    @param fee The new performance fee to use.\n    \"\"\"\n    assert msg.sender == self.governance\n    assert fee <= MAX_BPS / 2\n    self.performanceFee = fee\n    log UpdatePerformanceFee(fee)\n\n\n@external\ndef setManagementFee(fee: uint256):\n    \"\"\"\n    @notice\n        Used to change the value of `managementFee`.\n\n        This may only be called by governance.\n    @param fee The new management fee to use.\n    \"\"\"\n    assert msg.sender == self.governance\n    assert fee <= MAX_BPS\n    self.managementFee = fee\n    log UpdateManagementFee(fee)\n\n\n@external\ndef setGuardian(guardian: address):\n    \"\"\"\n    @notice\n        Used to change the address of `guardian`.\n\n        This may only be called by governance or the existing guardian.\n    @param guardian The new guardian address to use.\n    \"\"\"\n    assert msg.sender in [self.guardian, self.governance]\n    self.guardian = guardian\n    log UpdateGuardian(guardian)\n\n\n@external\ndef setEmergencyShutdown(active: bool):\n    \"\"\"\n    @notice\n        Activates or deactivates Vault mode where all Strategies go into full\n        withdrawal.\n\n        During Emergency Shutdown:\n        1. No Users may deposit into the Vault (but may withdraw as usual.)\n        2. Governance may not add new Strategies.\n        3. Each Strategy must pay back their debt as quickly as reasonable to\n            minimally affect their position.\n        4. Only Governance may undo Emergency Shutdown.\n\n        See contract level note for further details.\n\n        This may only be called by governance or the guardian.\n    @param active\n        If true, the Vault goes into Emergency Shutdown. If false, the Vault\n        goes back into Normal Operation.\n    \"\"\"\n    if active:\n        assert msg.sender in [self.guardian, self.governance]\n    else:\n        assert msg.sender == self.governance\n    self.emergencyShutdown = active\n    log EmergencyShutdown(active)\n\n\n@external\ndef setWithdrawalQueue(queue: address[MAXIMUM_STRATEGIES]):\n    \"\"\"\n    @notice\n        Updates the withdrawalQueue to match the addresses and order specified\n        by `queue`.\n\n        There can be fewer strategies than the maximum, as well as fewer than\n        the total number of strategies active in the vault. `withdrawalQueue`\n        will be updated in a gas-efficient manner, assuming the input is well-\n        ordered with 0x0 only at the end.\n\n        This may only be called by governance or management.\n    @dev\n        This is order sensitive, specify the addresses in the order in which\n        funds should be withdrawn (so `queue`[0] is the first Strategy withdrawn\n        from, `queue`[1] is the second, etc.)\n\n        This means that the least impactful Strategy (the Strategy that will have\n        its core positions impacted the least by having funds removed) should be\n        at `queue`[0], then the next least impactful at `queue`[1], and so on.\n    @param queue\n        The array of addresses to use as the new withdrawal queue. This is\n        order sensitive.\n    \"\"\"\n    assert msg.sender in [self.management, self.governance]\n\n    # HACK: Temporary until Vyper adds support for Dynamic arrays\n    old_queue: address[MAXIMUM_STRATEGIES] = empty(address[MAXIMUM_STRATEGIES])\n    for i in range(MAXIMUM_STRATEGIES):\n        old_queue[i] = self.withdrawalQueue[i] \n        if queue[i] == ZERO_ADDRESS:\n            # NOTE: Cannot use this method to remove entries from the queue\n            assert old_queue[i] == ZERO_ADDRESS\n            break\n        # NOTE: Cannot use this method to add more entries to the queue\n        assert old_queue[i] != ZERO_ADDRESS\n\n        assert self.strategies[queue[i]].activation > 0\n\n        existsInOldQueue: bool = False\n        for j in range(MAXIMUM_STRATEGIES):\n            if queue[j] == ZERO_ADDRESS:\n                existsInOldQueue = True\n                break\n            if queue[i] == old_queue[j]:\n                # NOTE: Ensure that every entry in queue prior to reordering exists now\n                existsInOldQueue = True\n\n            if j <= i:\n                # NOTE: This will only check for duplicate entries in queue after `i`\n                continue\n            assert queue[i] != queue[j]  # dev: do not add duplicate strategies\n\n        assert existsInOldQueue # dev: do not add new strategies\n\n        self.withdrawalQueue[i] = queue[i]\n    log UpdateWithdrawalQueue(queue)\n\n\n@internal\ndef erc20_safe_transfer(token: address, receiver: address, amount: uint256):\n    # Used only to send tokens that are not the type managed by this Vault.\n    # HACK: Used to handle non-compliant tokens like USDT\n    response: Bytes[32] = raw_call(\n        token,\n        concat(\n            method_id(\"transfer(address,uint256)\"),\n            convert(receiver, bytes32),\n            convert(amount, bytes32),\n        ),\n        max_outsize=32,\n    )\n    if len(response) > 0:\n        assert convert(response, bool), \"Transfer failed!\"\n\n\n@internal\ndef erc20_safe_transferFrom(token: address, sender: address, receiver: address, amount: uint256):\n    # Used only to send tokens that are not the type managed by this Vault.\n    # HACK: Used to handle non-compliant tokens like USDT\n    response: Bytes[32] = raw_call(\n        token,\n        concat(\n            method_id(\"transferFrom(address,address,uint256)\"),\n            convert(sender, bytes32),\n            convert(receiver, bytes32),\n            convert(amount, bytes32),\n        ),\n        max_outsize=32,\n    )\n    if len(response) > 0:\n        assert convert(response, bool), \"Transfer failed!\"\n\n\n@internal\ndef _transfer(sender: address, receiver: address, amount: uint256):\n    # See note on `transfer()`.\n\n    # Protect people from accidentally sending their shares to bad places\n    assert receiver not in [self, ZERO_ADDRESS]\n    self.balanceOf[sender] -= amount\n    self.balanceOf[receiver] += amount\n    log Transfer(sender, receiver, amount)\n\n\n@external\ndef transfer(receiver: address, amount: uint256) -> bool:\n    \"\"\"\n    @notice\n        Transfers shares from the caller's address to `receiver`. This function\n        will always return true, unless the user is attempting to transfer\n        shares to this contract's address, or to 0x0.\n    @param receiver\n        The address shares are being transferred to. Must not be this contract's\n        address, must not be 0x0.\n    @param amount The quantity of shares to transfer.\n    @return\n        True if transfer is sent to an address other than this contract's or\n        0x0, otherwise the transaction will fail.\n    \"\"\"\n    self._transfer(msg.sender, receiver, amount)\n    return True\n\n\n@external\ndef transferFrom(sender: address, receiver: address, amount: uint256) -> bool:\n    \"\"\"\n    @notice\n        Transfers `amount` shares from `sender` to `receiver`. This operation will\n        always return true, unless the user is attempting to transfer shares\n        to this contract's address, or to 0x0.\n\n        Unless the caller has given this contract unlimited approval,\n        transfering shares will decrement the caller's `allowance` by `amount`.\n    @param sender The address shares are being transferred from.\n    @param receiver\n        The address shares are being transferred to. Must not be this contract's\n        address, must not be 0x0.\n    @param amount The quantity of shares to transfer.\n    @return\n        True if transfer is sent to an address other than this contract's or\n        0x0, otherwise the transaction will fail.\n    \"\"\"\n    # Unlimited approval (saves an SSTORE)\n    if (self.allowance[sender][msg.sender] < MAX_UINT256):\n        allowance: uint256 = self.allowance[sender][msg.sender] - amount\n        self.allowance[sender][msg.sender] = allowance\n        # NOTE: Allows log filters to have a full accounting of allowance changes\n        log Approval(sender, msg.sender, allowance)\n    self._transfer(sender, receiver, amount)\n    return True\n\n\n@external\ndef approve(spender: address, amount: uint256) -> bool:\n    \"\"\"\n    @dev Approve the passed address to spend the specified amount of tokens on behalf of\n         `msg.sender`. Beware that changing an allowance with this method brings the risk\n         that someone may use both the old and the new allowance by unfortunate transaction\n         ordering. See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    @param spender The address which will spend the funds.\n    @param amount The amount of tokens to be spent.\n    \"\"\"\n    self.allowance[msg.sender][spender] = amount\n    log Approval(msg.sender, spender, amount)\n    return True\n\n\n@external\ndef increaseAllowance(spender: address, amount: uint256) -> bool:\n    \"\"\"\n    @dev Increase the allowance of the passed address to spend the total amount of tokens\n         on behalf of msg.sender. This method mitigates the risk that someone may use both\n         the old and the new allowance by unfortunate transaction ordering.\n         See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    @param spender The address which will spend the funds.\n    @param amount The amount of tokens to increase the allowance by.\n    \"\"\"\n    self.allowance[msg.sender][spender] += amount\n    log Approval(msg.sender, spender, self.allowance[msg.sender][spender])\n    return True\n\n\n@external\ndef decreaseAllowance(spender: address, amount: uint256) -> bool:\n    \"\"\"\n    @dev Decrease the allowance of the passed address to spend the total amount of tokens\n         on behalf of msg.sender. This method mitigates the risk that someone may use both\n         the old and the new allowance by unfortunate transaction ordering.\n         See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    @param spender The address which will spend the funds.\n    @param amount The amount of tokens to decrease the allowance by.\n    \"\"\"\n    self.allowance[msg.sender][spender] -= amount\n    log Approval(msg.sender, spender, self.allowance[msg.sender][spender])\n    return True\n\n\n@external\ndef permit(owner: address, spender: address, amount: uint256, expiry: uint256, signature: Bytes[65]) -> bool:\n    \"\"\"\n    @notice\n        Approves spender by owner's signature to expend owner's tokens.\n        See https://eips.ethereum.org/EIPS/eip-2612.\n\n    @param owner The address which is a source of funds and has signed the Permit.\n    @param spender The address which is allowed to spend the funds.\n    @param amount The amount of tokens to be spent.\n    @param expiry The timestamp after which the Permit is no longer valid.\n    @param signature A valid secp256k1 signature of Permit by owner encoded as r, s, v.\n    @return True, if transaction completes successfully\n    \"\"\"\n    assert owner != ZERO_ADDRESS  # dev: invalid owner\n    assert expiry >= block.timestamp  # dev: permit expired\n    nonce: uint256 = self.nonces[owner]\n    digest: bytes32 = keccak256(\n        concat(\n            b'\\x19\\x01',\n            self.domain_separator(),\n            keccak256(\n                concat(\n                    PERMIT_TYPE_HASH,\n                    convert(owner, bytes32),\n                    convert(spender, bytes32),\n                    convert(amount, bytes32),\n                    convert(nonce, bytes32),\n                    convert(expiry, bytes32),\n                )\n            )\n        )\n    )\n    # NOTE: signature is packed as r, s, v\n    r: uint256 = convert(slice(signature, 0, 32), uint256)\n    s: uint256 = convert(slice(signature, 32, 32), uint256)\n    v: uint256 = convert(slice(signature, 64, 1), uint256)\n    assert ecrecover(digest, v, r, s) == owner  # dev: invalid signature\n    self.allowance[owner][spender] = amount\n    self.nonces[owner] = nonce + 1\n    log Approval(owner, spender, amount)\n    return True\n\n\n@view\n@internal\ndef _totalAssets() -> uint256:\n    # See note on `totalAssets()`.\n    return self.totalIdle + self.totalDebt\n\n\n@view\n@external\ndef totalAssets() -> uint256:\n    \"\"\"\n    @notice\n        Returns the total quantity of all assets under control of this\n        Vault, whether they're loaned out to a Strategy, or currently held in\n        the Vault.\n    @return The total assets under control of this Vault.\n    \"\"\"\n    return self._totalAssets()\n\n\n@view\n@internal\ndef _calculateLockedProfit() -> uint256:\n    lockedFundsRatio: uint256 = (block.timestamp - self.lastReport) * self.lockedProfitDegradation\n\n    if(lockedFundsRatio < DEGRADATION_COEFFICIENT):\n        lockedProfit: uint256 = self.lockedProfit\n        return lockedProfit - (\n                lockedFundsRatio\n                * lockedProfit\n                / DEGRADATION_COEFFICIENT\n            )\n    else:        \n        return 0\n\n@view\n@internal\ndef _freeFunds() -> uint256:\n    return self._totalAssets() - self._calculateLockedProfit()\n\n@internal\ndef _issueSharesForAmount(to: address, amount: uint256) -> uint256:\n    # Issues `amount` Vault shares to `to`.\n    # Shares must be issued prior to taking on new collateral, or\n    # calculation will be wrong. This means that only *trusted* tokens\n    # (with no capability for exploitative behavior) can be used.\n    shares: uint256 = 0\n    # HACK: Saves 2 SLOADs (~200 gas, post-Berlin)\n    totalSupply: uint256 = self.totalSupply\n    if totalSupply > 0:\n        # Mint amount of shares based on what the Vault is managing overall\n        # NOTE: if sqrt(token.totalSupply()) > 1e39, this could potentially revert\n        shares =  amount * totalSupply / self._freeFunds()  # dev: no free funds\n    else:\n        # No existing shares, so mint 1:1\n        shares = amount\n    assert shares != 0 # dev: division rounding resulted in zero\n\n    # Mint new shares\n    self.totalSupply = totalSupply + shares\n    self.balanceOf[to] += shares\n    log Transfer(ZERO_ADDRESS, to, shares)\n\n    return shares\n\n\n@external\n@nonreentrant(\"withdraw\")\ndef deposit(_amount: uint256 = MAX_UINT256, recipient: address = msg.sender) -> uint256:\n    \"\"\"\n    @notice\n        Deposits `_amount` `token`, issuing shares to `recipient`. If the\n        Vault is in Emergency Shutdown, deposits will not be accepted and this\n        call will fail.\n    @dev\n        Measuring quantity of shares to issues is based on the total\n        outstanding debt that this contract has (\"expected value\") instead\n        of the total balance sheet it has (\"estimated value\") has important\n        security considerations, and is done intentionally. If this value were\n        measured against external systems, it could be purposely manipulated by\n        an attacker to withdraw more assets than they otherwise should be able\n        to claim by redeeming their shares.\n\n        On deposit, this means that shares are issued against the total amount\n        that the deposited capital can be given in service of the debt that\n        Strategies assume. If that number were to be lower than the \"expected\n        value\" at some future point, depositing shares via this method could\n        entitle the depositor to *less* than the deposited value once the\n        \"realized value\" is updated from further reports by the Strategies\n        to the Vaults.\n\n        Care should be taken by integrators to account for this discrepancy,\n        by using the view-only methods of this contract (both off-chain and\n        on-chain) to determine if depositing into the Vault is a \"good idea\".\n    @param _amount The quantity of tokens to deposit, defaults to all.\n    @param recipient\n        The address to issue the shares in this Vault to. Defaults to the\n        caller's address.\n    @return The issued Vault shares.\n    \"\"\"\n    assert not self.emergencyShutdown  # Deposits are locked out\n    assert recipient not in [self, ZERO_ADDRESS]\n\n    amount: uint256 = _amount\n\n    # If _amount not specified, transfer the full token balance,\n    # up to deposit limit\n    if amount == MAX_UINT256:\n        amount = min(\n            self.depositLimit - self._totalAssets(),\n            self.token.balanceOf(msg.sender),\n        )\n    else:\n        # Ensure deposit limit is respected\n        assert self._totalAssets() + amount <= self.depositLimit\n\n    # Ensure we are depositing something\n    assert amount > 0\n\n    # Issue new shares (needs to be done before taking deposit to be accurate)\n    # Shares are issued to recipient (may be different from msg.sender)\n    # See @dev note, above.\n    shares: uint256 = self._issueSharesForAmount(recipient, amount)\n\n    # Tokens are transferred from msg.sender (may be different from _recipient)\n    self.erc20_safe_transferFrom(self.token.address, msg.sender, self, amount)\n    self.totalIdle += amount\n\n    log Deposit(recipient, shares, amount)\n\n    return shares  # Just in case someone wants them\n\n\n@view\n@internal\ndef _shareValue(shares: uint256) -> uint256:\n    # Returns price = 1:1 if vault is empty\n    if self.totalSupply == 0:\n        return shares\n\n    # Determines the current value of `shares`.\n    # NOTE: if sqrt(Vault.totalAssets()) >>> 1e39, this could potentially revert\n\n    return (\n        shares\n        * self._freeFunds()\n        / self.totalSupply\n    )\n\n\n@view\n@internal\ndef _sharesForAmount(amount: uint256) -> uint256:\n    # Determines how many shares `amount` of token would receive.\n    # See dev note on `deposit`.\n    _freeFunds: uint256 = self._freeFunds()\n    if _freeFunds > 0:\n        # NOTE: if sqrt(token.totalSupply()) > 1e37, this could potentially revert\n        return  (\n            amount\n            * self.totalSupply\n            / _freeFunds \n        )\n    else:\n        return 0\n\n\n@view\n@external\ndef maxAvailableShares() -> uint256:\n    \"\"\"\n    @notice\n        Determines the maximum quantity of shares this Vault can facilitate a\n        withdrawal for, factoring in assets currently residing in the Vault,\n        as well as those deployed to strategies on the Vault's balance sheet.\n    @dev\n        Regarding how shares are calculated, see dev note on `deposit`.\n\n        If you want to calculated the maximum a user could withdraw up to,\n        you want to use this function.\n\n        Note that the amount provided by this function is the theoretical\n        maximum possible from withdrawing, the real amount depends on the\n        realized losses incurred during withdrawal.\n    @return The total quantity of shares this Vault can provide.\n    \"\"\"\n    shares: uint256 = self._sharesForAmount(self.totalIdle)\n\n    for strategy in self.withdrawalQueue:\n        if strategy == ZERO_ADDRESS:\n            break\n        shares += self._sharesForAmount(self.strategies[strategy].totalDebt)\n\n    return shares\n\n\n@internal\ndef _reportLoss(strategy: address, loss: uint256):\n    # Loss can only be up the amount of debt issued to strategy\n    totalDebt: uint256 = self.strategies[strategy].totalDebt\n    assert totalDebt >= loss\n\n    # Also, make sure we reduce our trust with the strategy by the amount of loss\n    if self.debtRatio != 0: # if vault with single strategy that is set to EmergencyOne\n        # NOTE: The context to this calculation is different than the calculation in `_reportLoss`,\n        # this calculation intentionally approximates via `totalDebt` to avoid manipulatable results\n        ratio_change: uint256 = min(\n            # NOTE: This calculation isn't 100% precise, the adjustment is ~10%-20% more severe due to EVM math\n            loss * self.debtRatio / self.totalDebt,\n            self.strategies[strategy].debtRatio,\n        )\n        self.strategies[strategy].debtRatio -= ratio_change\n        self.debtRatio -= ratio_change\n    # Finally, adjust our strategy's parameters by the loss\n    self.strategies[strategy].totalLoss += loss\n    self.strategies[strategy].totalDebt = totalDebt - loss\n    self.totalDebt -= loss\n\n\n@external\n@nonreentrant(\"withdraw\")\ndef withdraw(\n    maxShares: uint256 = MAX_UINT256,\n    recipient: address = msg.sender,\n    maxLoss: uint256 = 1,  # 0.01% [BPS]\n) -> uint256:\n    \"\"\"\n    @notice\n        Withdraws the calling account's tokens from this Vault, redeeming\n        amount `_shares` for an appropriate amount of tokens.\n\n        See note on `setWithdrawalQueue` for further details of withdrawal\n        ordering and behavior.\n    @dev\n        Measuring the value of shares is based on the total outstanding debt\n        that this contract has (\"expected value\") instead of the total balance\n        sheet it has (\"estimated value\") has important security considerations,\n        and is done intentionally. If this value were measured against external\n        systems, it could be purposely manipulated by an attacker to withdraw\n        more assets than they otherwise should be able to claim by redeeming\n        their shares.\n\n        On withdrawal, this means that shares are redeemed against the total\n        amount that the deposited capital had \"realized\" since the point it\n        was deposited, up until the point it was withdrawn. If that number\n        were to be higher than the \"expected value\" at some future point,\n        withdrawing shares via this method could entitle the depositor to\n        *more* than the expected value once the \"realized value\" is updated\n        from further reports by the Strategies to the Vaults.\n\n        Under exceptional scenarios, this could cause earlier withdrawals to\n        earn \"more\" of the underlying assets than Users might otherwise be\n        entitled to, if the Vault's estimated value were otherwise measured\n        through external means, accounting for whatever exceptional scenarios\n        exist for the Vault (that aren't covered by the Vault's own design.)\n\n        In the situation where a large withdrawal happens, it can empty the \n        vault balance and the strategies in the withdrawal queue. \n        Strategies not in the withdrawal queue will have to be harvested to \n        rebalance the funds and make the funds available again to withdraw.\n    @param maxShares\n        How many shares to try and redeem for tokens, defaults to all.\n    @param recipient\n        The address to issue the shares in this Vault to. Defaults to the\n        caller's address.\n    @param maxLoss\n        The maximum acceptable loss to sustain on withdrawal. Defaults to 0.01%.\n        If a loss is specified, up to that amount of shares may be burnt to cover losses on withdrawal.\n    @return The quantity of tokens redeemed for `_shares`.\n    \"\"\"\n    shares: uint256 = maxShares  # May reduce this number below\n\n    # Max Loss is <=100%, revert otherwise\n    assert maxLoss <= MAX_BPS\n\n    # If _shares not specified, transfer full share balance\n    if shares == MAX_UINT256:\n        shares = self.balanceOf[msg.sender]\n\n    # Limit to only the shares they own\n    assert shares <= self.balanceOf[msg.sender]\n\n    # Ensure we are withdrawing something\n    assert shares > 0\n\n    # See @dev note, above.\n    value: uint256 = self._shareValue(shares)\n    vault_balance: uint256 = self.totalIdle\n\n    if value > vault_balance:\n        totalLoss: uint256 = 0\n        # We need to go get some from our strategies in the withdrawal queue\n        # NOTE: This performs forced withdrawals from each Strategy. During\n        #       forced withdrawal, a Strategy may realize a loss. That loss\n        #       is reported back to the Vault, and the will affect the amount\n        #       of tokens that the withdrawer receives for their shares. They\n        #       can optionally specify the maximum acceptable loss (in BPS)\n        #       to prevent excessive losses on their withdrawals (which may\n        #       happen in certain edge cases where Strategies realize a loss)\n        for strategy in self.withdrawalQueue:\n            if strategy == ZERO_ADDRESS:\n                break  # We've exhausted the queue\n\n            if value <= vault_balance:\n                break  # We're done withdrawing\n\n            amountNeeded: uint256 = value - vault_balance\n\n            # NOTE: Don't withdraw more than the debt so that Strategy can still\n            #       continue to work based on the profits it has\n            # NOTE: This means that user will lose out on any profits that each\n            #       Strategy in the queue would return on next harvest, benefiting others\n            amountNeeded = min(amountNeeded, self.strategies[strategy].totalDebt)\n            if amountNeeded == 0:\n                continue  # Nothing to withdraw from this Strategy, try the next one\n\n            # Force withdraw amount from each Strategy in the order set by governance\n            preBalance: uint256 = self.token.balanceOf(self)\n            loss: uint256 = Strategy(strategy).withdraw(amountNeeded)\n            withdrawn: uint256 = self.token.balanceOf(self) - preBalance\n            vault_balance += withdrawn\n\n            # NOTE: Withdrawer incurs any losses from liquidation\n            if loss > 0:\n                value -= loss\n                totalLoss += loss\n                self._reportLoss(strategy, loss)\n\n            # Reduce the Strategy's debt by the amount withdrawn (\"realized returns\")\n            # NOTE: This doesn't add to returns as it's not earned by \"normal means\"\n            self.strategies[strategy].totalDebt -= withdrawn\n            self.totalDebt -= withdrawn\n            log WithdrawFromStrategy(strategy, self.strategies[strategy].totalDebt, loss)\n\n        self.totalIdle = vault_balance\n        # NOTE: We have withdrawn everything possible out of the withdrawal queue\n        #       but we still don't have enough to fully pay them back, so adjust\n        #       to the total amount we've freed up through forced withdrawals\n        if value > vault_balance:\n            value = vault_balance\n            # NOTE: Burn # of shares that corresponds to what Vault has on-hand,\n            #       including the losses that were incurred above during withdrawals\n            shares = self._sharesForAmount(value + totalLoss)\n\n        # NOTE: This loss protection is put in place to revert if losses from\n        #       withdrawing are more than what is considered acceptable.\n        assert totalLoss <= maxLoss * (value + totalLoss) / MAX_BPS\n\n    # Burn shares (full value of what is being withdrawn)\n    self.totalSupply -= shares\n    self.balanceOf[msg.sender] -= shares\n    log Transfer(msg.sender, ZERO_ADDRESS, shares)\n    \n    self.totalIdle -= value\n    # Withdraw remaining balance to _recipient (may be different to msg.sender) (minus fee)\n    self.erc20_safe_transfer(self.token.address, recipient, value)\n    log Withdraw(recipient, shares, value)\n    \n    return value\n\n\n@view\n@external\ndef pricePerShare() -> uint256:\n    \"\"\"\n    @notice Gives the price for a single Vault share.\n    @dev See dev note on `withdraw`.\n    @return The value of a single share.\n    \"\"\"\n    return self._shareValue(10 ** self.decimals)\n\n\n@internal\ndef _organizeWithdrawalQueue():\n    # Reorganize `withdrawalQueue` based on premise that if there is an\n    # empty value between two actual values, then the empty value should be\n    # replaced by the later value.\n    # NOTE: Relative ordering of non-zero values is maintained.\n    offset: uint256 = 0\n    for idx in range(MAXIMUM_STRATEGIES):\n        strategy: address = self.withdrawalQueue[idx]\n        if strategy == ZERO_ADDRESS:\n            offset += 1  # how many values we need to shift, always `<= idx`\n        elif offset > 0:\n            self.withdrawalQueue[idx - offset] = strategy\n            self.withdrawalQueue[idx] = ZERO_ADDRESS\n\n\n@external\ndef addStrategy(\n    strategy: address,\n    debtRatio: uint256,\n    minDebtPerHarvest: uint256,\n    maxDebtPerHarvest: uint256,\n    performanceFee: uint256,\n):\n    \"\"\"\n    @notice\n        Add a Strategy to the Vault.\n\n        This may only be called by governance.\n    @dev\n        The Strategy will be appended to `withdrawalQueue`, call\n        `setWithdrawalQueue` to change the order.\n    @param strategy The address of the Strategy to add.\n    @param debtRatio\n        The share of the total assets in the `vault that the `strategy` has access to.\n    @param minDebtPerHarvest\n        Lower limit on the increase of debt since last harvest\n    @param maxDebtPerHarvest\n        Upper limit on the increase of debt since last harvest\n    @param performanceFee\n        The fee the strategist will receive based on this Vault's performance.\n    \"\"\"\n    # Check if queue is full\n    assert self.withdrawalQueue[MAXIMUM_STRATEGIES - 1] == ZERO_ADDRESS\n\n    # Check calling conditions\n    assert not self.emergencyShutdown\n    assert msg.sender == self.governance\n\n    # Check strategy configuration\n    assert strategy != ZERO_ADDRESS\n    assert self.strategies[strategy].activation == 0\n    assert self == Strategy(strategy).vault()\n    assert self.token.address == Strategy(strategy).want()\n\n    # Check strategy parameters\n    assert self.debtRatio + debtRatio <= MAX_BPS\n    assert minDebtPerHarvest <= maxDebtPerHarvest\n    assert performanceFee <= MAX_BPS / 2 \n\n    # Add strategy to approved strategies\n    self.strategies[strategy] = StrategyParams({\n        performanceFee: performanceFee,\n        activation: block.timestamp,\n        debtRatio: debtRatio,\n        minDebtPerHarvest: minDebtPerHarvest,\n        maxDebtPerHarvest: maxDebtPerHarvest,\n        lastReport: block.timestamp,\n        totalDebt: 0,\n        totalGain: 0,\n        totalLoss: 0,\n    })\n    log StrategyAdded(strategy, debtRatio, minDebtPerHarvest, maxDebtPerHarvest, performanceFee)\n\n    # Update Vault parameters\n    self.debtRatio += debtRatio\n\n    # Add strategy to the end of the withdrawal queue\n    self.withdrawalQueue[MAXIMUM_STRATEGIES - 1] = strategy\n    self._organizeWithdrawalQueue()\n\n\n@external\ndef updateStrategyDebtRatio(\n    strategy: address,\n    debtRatio: uint256,\n):\n    \"\"\"\n    @notice\n        Change the quantity of assets `strategy` may manage.\n\n        This may be called by governance or management.\n    @param strategy The Strategy to update.\n    @param debtRatio The quantity of assets `strategy` may now manage.\n    \"\"\"\n    assert msg.sender in [self.management, self.governance]\n    assert self.strategies[strategy].activation > 0\n    assert Strategy(strategy).emergencyExit() == False # dev: strategy in emergency\n    self.debtRatio -= self.strategies[strategy].debtRatio\n    self.strategies[strategy].debtRatio = debtRatio\n    self.debtRatio += debtRatio\n    assert self.debtRatio <= MAX_BPS\n    log StrategyUpdateDebtRatio(strategy, debtRatio)\n\n\n@external\ndef updateStrategyMinDebtPerHarvest(\n    strategy: address,\n    minDebtPerHarvest: uint256,\n):\n    \"\"\"\n    @notice\n        Change the quantity assets per block this Vault may deposit to or\n        withdraw from `strategy`.\n\n        This may only be called by governance or management.\n    @param strategy The Strategy to update.\n    @param minDebtPerHarvest\n        Lower limit on the increase of debt since last harvest\n    \"\"\"\n    assert msg.sender in [self.management, self.governance]\n    assert self.strategies[strategy].activation > 0\n    assert self.strategies[strategy].maxDebtPerHarvest >= minDebtPerHarvest\n    self.strategies[strategy].minDebtPerHarvest = minDebtPerHarvest\n    log StrategyUpdateMinDebtPerHarvest(strategy, minDebtPerHarvest)\n\n\n@external\ndef updateStrategyMaxDebtPerHarvest(\n    strategy: address,\n    maxDebtPerHarvest: uint256,\n):\n    \"\"\"\n    @notice\n        Change the quantity assets per block this Vault may deposit to or\n        withdraw from `strategy`.\n\n        This may only be called by governance or management.\n    @param strategy The Strategy to update.\n    @param maxDebtPerHarvest\n        Upper limit on the increase of debt since last harvest\n    \"\"\"\n    assert msg.sender in [self.management, self.governance]\n    assert self.strategies[strategy].activation > 0\n    assert self.strategies[strategy].minDebtPerHarvest <= maxDebtPerHarvest\n    self.strategies[strategy].maxDebtPerHarvest = maxDebtPerHarvest\n    log StrategyUpdateMaxDebtPerHarvest(strategy, maxDebtPerHarvest)\n\n\n@external\ndef updateStrategyPerformanceFee(\n    strategy: address,\n    performanceFee: uint256,\n):\n    \"\"\"\n    @notice\n        Change the fee the strategist will receive based on this Vault's\n        performance.\n\n        This may only be called by governance.\n    @param strategy The Strategy to update.\n    @param performanceFee The new fee the strategist will receive.\n    \"\"\"\n    assert msg.sender == self.governance\n    assert performanceFee <= MAX_BPS / 2\n    assert self.strategies[strategy].activation > 0\n    self.strategies[strategy].performanceFee = performanceFee\n    log StrategyUpdatePerformanceFee(strategy, performanceFee)\n\n\n@internal\ndef _revokeStrategy(strategy: address):\n    self.debtRatio -= self.strategies[strategy].debtRatio\n    self.strategies[strategy].debtRatio = 0\n    log StrategyRevoked(strategy)\n\n\n@external\ndef migrateStrategy(oldVersion: address, newVersion: address):\n    \"\"\"\n    @notice\n        Migrates a Strategy, including all assets from `oldVersion` to\n        `newVersion`.\n\n        This may only be called by governance.\n    @dev\n        Strategy must successfully migrate all capital and positions to new\n        Strategy, or else this will upset the balance of the Vault.\n\n        The new Strategy should be \"empty\" e.g. have no prior commitments to\n        this Vault, otherwise it could have issues.\n    @param oldVersion The existing Strategy to migrate from.\n    @param newVersion The new Strategy to migrate to.\n    \"\"\"\n    assert msg.sender == self.governance\n    assert newVersion != ZERO_ADDRESS\n    assert self.strategies[oldVersion].activation > 0\n    assert self.strategies[newVersion].activation == 0\n\n    strategy: StrategyParams = self.strategies[oldVersion]\n\n    self._revokeStrategy(oldVersion)\n    # _revokeStrategy will lower the debtRatio\n    self.debtRatio += strategy.debtRatio\n    # Debt is migrated to new strategy\n    self.strategies[oldVersion].totalDebt = 0\n\n    self.strategies[newVersion] = StrategyParams({\n        performanceFee: strategy.performanceFee,\n        # NOTE: use last report for activation time, so E[R] calc works\n        activation: strategy.lastReport,\n        debtRatio: strategy.debtRatio,\n        minDebtPerHarvest: strategy.minDebtPerHarvest,\n        maxDebtPerHarvest: strategy.maxDebtPerHarvest,\n        lastReport: strategy.lastReport,\n        totalDebt: strategy.totalDebt,\n        totalGain: 0,\n        totalLoss: 0,\n    })\n\n    Strategy(oldVersion).migrate(newVersion)\n    log StrategyMigrated(oldVersion, newVersion)\n\n    for idx in range(MAXIMUM_STRATEGIES):\n        if self.withdrawalQueue[idx] == oldVersion:\n            self.withdrawalQueue[idx] = newVersion\n            return  # Don't need to reorder anything because we swapped\n\n\n@external\ndef revokeStrategy(strategy: address = msg.sender):\n    \"\"\"\n    @notice\n        Revoke a Strategy, setting its debt limit to 0 and preventing any\n        future deposits.\n\n        This function should only be used in the scenario where the Strategy is\n        being retired but no migration of the positions are possible, or in the\n        extreme scenario that the Strategy needs to be put into \"Emergency Exit\"\n        mode in order for it to exit as quickly as possible. The latter scenario\n        could be for any reason that is considered \"critical\" that the Strategy\n        exits its position as fast as possible, such as a sudden change in market\n        conditions leading to losses, or an imminent failure in an external\n        dependency.\n\n        This may only be called by governance, the guardian, or the Strategy\n        itself. Note that a Strategy will only revoke itself during emergency\n        shutdown.\n    @param strategy The Strategy to revoke.\n    \"\"\"\n    assert msg.sender in [strategy, self.governance, self.guardian]\n    assert self.strategies[strategy].debtRatio != 0 # dev: already zero\n\n    self._revokeStrategy(strategy)\n\n\n@external\ndef addStrategyToQueue(strategy: address):\n    \"\"\"\n    @notice\n        Adds `strategy` to `withdrawalQueue`.\n\n        This may only be called by governance or management.\n    @dev\n        The Strategy will be appended to `withdrawalQueue`, call\n        `setWithdrawalQueue` to change the order.\n    @param strategy The Strategy to add.\n    \"\"\"\n    assert msg.sender in [self.management, self.governance]\n    # Must be a current Strategy\n    assert self.strategies[strategy].activation > 0\n    # Can't already be in the queue\n    last_idx: uint256 = 0\n    for s in self.withdrawalQueue:\n        if s == ZERO_ADDRESS:\n            break\n        assert s != strategy\n        last_idx += 1\n    # Check if queue is full\n    assert last_idx < MAXIMUM_STRATEGIES\n\n    self.withdrawalQueue[MAXIMUM_STRATEGIES - 1] = strategy\n    self._organizeWithdrawalQueue()\n    log StrategyAddedToQueue(strategy)\n\n\n@external\ndef removeStrategyFromQueue(strategy: address):\n    \"\"\"\n    @notice\n        Remove `strategy` from `withdrawalQueue`.\n\n        This may only be called by governance or management.\n    @dev\n        We don't do this with revokeStrategy because it should still\n        be possible to withdraw from the Strategy if it's unwinding.\n    @param strategy The Strategy to remove.\n    \"\"\"\n    assert msg.sender in [self.management, self.governance]\n    for idx in range(MAXIMUM_STRATEGIES):\n        if self.withdrawalQueue[idx] == strategy:\n            self.withdrawalQueue[idx] = ZERO_ADDRESS\n            self._organizeWithdrawalQueue()\n            log StrategyRemovedFromQueue(strategy)\n            return  # We found the right location and cleared it\n    raise  # We didn't find the Strategy in the queue\n\n\n@view\n@internal\ndef _debtOutstanding(strategy: address) -> uint256:\n    # See note on `debtOutstanding()`.\n    if self.debtRatio == 0:\n        return self.strategies[strategy].totalDebt\n\n    strategy_debtLimit: uint256 = (\n        self.strategies[strategy].debtRatio\n        * self._totalAssets()\n        / MAX_BPS\n    )\n    strategy_totalDebt: uint256 = self.strategies[strategy].totalDebt\n\n    if self.emergencyShutdown:\n        return strategy_totalDebt\n    elif strategy_totalDebt <= strategy_debtLimit:\n        return 0\n    else:\n        return strategy_totalDebt - strategy_debtLimit\n\n\n@view\n@external\ndef debtOutstanding(strategy: address = msg.sender) -> uint256:\n    \"\"\"\n    @notice\n        Determines if `strategy` is past its debt limit and if any tokens\n        should be withdrawn to the Vault.\n    @param strategy The Strategy to check. Defaults to the caller.\n    @return The quantity of tokens to withdraw.\n    \"\"\"\n    return self._debtOutstanding(strategy)\n\n\n@view\n@internal\ndef _creditAvailable(strategy: address) -> uint256:\n    # See note on `creditAvailable()`.\n    if self.emergencyShutdown:\n        return 0\n    vault_totalAssets: uint256 = self._totalAssets()\n    vault_debtLimit: uint256 =  self.debtRatio * vault_totalAssets / MAX_BPS \n    vault_totalDebt: uint256 = self.totalDebt\n    strategy_debtLimit: uint256 = self.strategies[strategy].debtRatio * vault_totalAssets / MAX_BPS\n    strategy_totalDebt: uint256 = self.strategies[strategy].totalDebt\n    strategy_minDebtPerHarvest: uint256 = self.strategies[strategy].minDebtPerHarvest\n    strategy_maxDebtPerHarvest: uint256 = self.strategies[strategy].maxDebtPerHarvest\n\n    # Exhausted credit line\n    if strategy_debtLimit <= strategy_totalDebt or vault_debtLimit <= vault_totalDebt:\n        return 0\n\n    # Start with debt limit left for the Strategy\n    available: uint256 = strategy_debtLimit - strategy_totalDebt\n\n    # Adjust by the global debt limit left\n    available = min(available, vault_debtLimit - vault_totalDebt)\n\n    # Can only borrow up to what the contract has in reserve\n    # NOTE: Running near 100% is discouraged\n    available = min(available, self.totalIdle)\n\n    # Adjust by min and max borrow limits (per harvest)\n    # NOTE: min increase can be used to ensure that if a strategy has a minimum\n    #       amount of capital needed to purchase a position, it's not given capital\n    #       it can't make use of yet.\n    # NOTE: max increase is used to make sure each harvest isn't bigger than what\n    #       is authorized. This combined with adjusting min and max periods in\n    #       `BaseStrategy` can be used to effect a \"rate limit\" on capital increase.\n    if available < strategy_minDebtPerHarvest:\n        return 0\n    else:\n        return min(available, strategy_maxDebtPerHarvest)\n\n@view\n@external\ndef creditAvailable(strategy: address = msg.sender) -> uint256:\n    \"\"\"\n    @notice\n        Amount of tokens in Vault a Strategy has access to as a credit line.\n\n        This will check the Strategy's debt limit, as well as the tokens\n        available in the Vault, and determine the maximum amount of tokens\n        (if any) the Strategy may draw on.\n\n        In the rare case the Vault is in emergency shutdown this will return 0.\n    @param strategy The Strategy to check. Defaults to caller.\n    @return The quantity of tokens available for the Strategy to draw on.\n    \"\"\"\n    return self._creditAvailable(strategy)\n\n\n@view\n@internal\ndef _expectedReturn(strategy: address) -> uint256:\n    # See note on `expectedReturn()`.\n    strategy_lastReport: uint256 = self.strategies[strategy].lastReport\n    timeSinceLastHarvest: uint256 = block.timestamp - strategy_lastReport\n    totalHarvestTime: uint256 = strategy_lastReport - self.strategies[strategy].activation\n\n    # NOTE: If either `timeSinceLastHarvest` or `totalHarvestTime` is 0, we can short-circuit to `0`\n    if timeSinceLastHarvest > 0 and totalHarvestTime > 0 and Strategy(strategy).isActive():\n        # NOTE: Unlikely to throw unless strategy accumalates >1e68 returns\n        # NOTE: Calculate average over period of time where harvests have occured in the past\n        return (\n            self.strategies[strategy].totalGain\n            * timeSinceLastHarvest\n            / totalHarvestTime\n        )\n    else:\n        return 0  # Covers the scenario when block.timestamp == activation\n\n\n@view\n@external\ndef availableDepositLimit() -> uint256:\n    if self.depositLimit > self._totalAssets():\n        return self.depositLimit - self._totalAssets()\n    else:\n        return 0\n\n\n@view\n@external\ndef expectedReturn(strategy: address = msg.sender) -> uint256:\n    \"\"\"\n    @notice\n        Provide an accurate expected value for the return this `strategy`\n        would provide to the Vault the next time `report()` is called\n        (since the last time it was called).\n    @param strategy The Strategy to determine the expected return for. Defaults to caller.\n    @return\n        The anticipated amount `strategy` should make on its investment\n        since its last report.\n    \"\"\"\n    return self._expectedReturn(strategy)\n\n\n@internal\ndef _assessFees(strategy: address, gain: uint256) -> uint256:\n    # Issue new shares to cover fees\n    # NOTE: In effect, this reduces overall share price by the combined fee\n    # NOTE: may throw if Vault.totalAssets() > 1e64, or not called for more than a year\n    if self.strategies[strategy].activation == block.timestamp:\n        return 0  # NOTE: Just added, no fees to assess\n\n    duration: uint256 = block.timestamp - self.strategies[strategy].lastReport\n    assert duration != 0 # can't assessFees twice within the same block\n\n    if gain == 0:\n        # NOTE: The fees are not charged if there hasn't been any gains reported\n        return 0\n\n    management_fee: uint256 = (\n        (\n            (self.strategies[strategy].totalDebt - Strategy(strategy).delegatedAssets())\n            * duration \n            * self.managementFee\n        )\n        / MAX_BPS\n        / SECS_PER_YEAR\n    )\n\n    # NOTE: Applies if Strategy is not shutting down, or it is but all debt paid off\n    # NOTE: No fee is taken when a Strategy is unwinding it's position, until all debt is paid\n    strategist_fee: uint256 = (\n        gain\n        * self.strategies[strategy].performanceFee\n        / MAX_BPS\n    )\n    # NOTE: Unlikely to throw unless strategy reports >1e72 harvest profit\n    performance_fee: uint256 = gain * self.performanceFee / MAX_BPS\n\n    # NOTE: This must be called prior to taking new collateral,\n    #       or the calculation will be wrong!\n    # NOTE: This must be done at the same time, to ensure the relative\n    #       ratio of governance_fee : strategist_fee is kept intact\n    total_fee: uint256 = performance_fee + strategist_fee + management_fee\n    # ensure total_fee is not more than gain\n    if total_fee > gain:\n        total_fee = gain\n    if total_fee > 0:  # NOTE: If mgmt fee is 0% and no gains were realized, skip\n        reward: uint256 = self._issueSharesForAmount(self, total_fee)\n\n        # Send the rewards out as new shares in this Vault\n        if strategist_fee > 0:  # NOTE: Guard against DIV/0 fault\n            # NOTE: Unlikely to throw unless sqrt(reward) >>> 1e39\n            strategist_reward: uint256 = (\n                strategist_fee\n                * reward\n                / total_fee\n            )\n            self._transfer(self, strategy, strategist_reward)\n            # NOTE: Strategy distributes rewards at the end of harvest()\n        # NOTE: Governance earns any dust leftover from flooring math above\n        if self.balanceOf[self] > 0:\n            self._transfer(self, self.rewards, self.balanceOf[self])\n    log FeeReport(management_fee, performance_fee, strategist_fee, duration)\n    return total_fee\n\n\n@external\ndef report(gain: uint256, loss: uint256, _debtPayment: uint256) -> uint256:\n    \"\"\"\n    @notice\n        Reports the amount of assets the calling Strategy has free (usually in\n        terms of ROI).\n\n        The performance fee is determined here, off of the strategy's profits\n        (if any), and sent to governance.\n\n        The strategist's fee is also determined here (off of profits), to be\n        handled according to the strategist on the next harvest.\n\n        This may only be called by a Strategy managed by this Vault.\n    @dev\n        For approved strategies, this is the most efficient behavior.\n        The Strategy reports back what it has free, then Vault \"decides\"\n        whether to take some back or give it more. Note that the most it can\n        take is `gain + _debtPayment`, and the most it can give is all of the\n        remaining reserves. Anything outside of those bounds is abnormal behavior.\n\n        All approved strategies must have increased diligence around\n        calling this function, as abnormal behavior could become catastrophic.\n    @param gain\n        Amount Strategy has realized as a gain on it's investment since its\n        last report, and is free to be given back to Vault as earnings\n    @param loss\n        Amount Strategy has realized as a loss on it's investment since its\n        last report, and should be accounted for on the Vault's balance sheet.\n        The loss will reduce the debtRatio. The next time the strategy will harvest,\n        it will pay back the debt in an attempt to adjust to the new debt limit.\n    @param _debtPayment\n        Amount Strategy has made available to cover outstanding debt\n    @return Amount of debt outstanding (if totalDebt > debtLimit or emergency shutdown).\n    \"\"\"\n\n    # Only approved strategies can call this function\n    assert self.strategies[msg.sender].activation > 0\n    # No lying about total available to withdraw!\n    assert self.token.balanceOf(msg.sender) >= gain + _debtPayment\n\n    # We have a loss to report, do it before the rest of the calculations\n    if loss > 0:\n        self._reportLoss(msg.sender, loss)\n\n    # Assess both management fee and performance fee, and issue both as shares of the vault\n    totalFees: uint256 = self._assessFees(msg.sender, gain)\n\n    # Returns are always \"realized gains\"\n    self.strategies[msg.sender].totalGain += gain\n\n    # Compute the line of credit the Vault is able to offer the Strategy (if any)\n    credit: uint256 = self._creditAvailable(msg.sender)\n\n    # Outstanding debt the Strategy wants to take back from the Vault (if any)\n    # NOTE: debtOutstanding <= StrategyParams.totalDebt\n    debt: uint256 = self._debtOutstanding(msg.sender)\n    debtPayment: uint256 = min(_debtPayment, debt)\n\n    if debtPayment > 0:\n        self.strategies[msg.sender].totalDebt -= debtPayment\n        self.totalDebt -= debtPayment\n        debt -= debtPayment\n        # NOTE: `debt` is being tracked for later\n\n    # Update the actual debt based on the full credit we are extending to the Strategy\n    # or the returns if we are taking funds back\n    # NOTE: credit + self.strategies[msg.sender].totalDebt is always < self.debtLimit\n    # NOTE: At least one of `credit` or `debt` is always 0 (both can be 0)\n    if credit > 0:\n        self.strategies[msg.sender].totalDebt += credit\n        self.totalDebt += credit\n\n    # Give/take balance to Strategy, based on the difference between the reported gains\n    # (if any), the debt payment (if any), the credit increase we are offering (if any),\n    # and the debt needed to be paid off (if any)\n    # NOTE: This is just used to adjust the balance of tokens between the Strategy and\n    #       the Vault based on the Strategy's debt limit (as well as the Vault's).\n    totalAvail: uint256 = gain + debtPayment\n    if totalAvail < credit:  # credit surplus, give to Strategy\n        self.totalIdle -= credit - totalAvail\n        self.erc20_safe_transfer(self.token.address, msg.sender, credit - totalAvail)\n    elif totalAvail > credit:  # credit deficit, take from Strategy\n        self.totalIdle += totalAvail - credit\n        self.erc20_safe_transferFrom(self.token.address, msg.sender, self, totalAvail - credit)\n    # else, don't do anything because it is balanced\n\n    # Profit is locked and gradually released per block\n    # NOTE: compute current locked profit and replace with sum of current and new\n    lockedProfitBeforeLoss: uint256 = self._calculateLockedProfit() + gain - totalFees\n    if lockedProfitBeforeLoss > loss: \n        self.lockedProfit = lockedProfitBeforeLoss - loss\n    else:\n        self.lockedProfit = 0\n\n    # Update reporting time\n    self.strategies[msg.sender].lastReport = block.timestamp\n    self.lastReport = block.timestamp\n\n    log StrategyReported(\n        msg.sender,\n        gain,\n        loss,\n        debtPayment,\n        self.strategies[msg.sender].totalGain,\n        self.strategies[msg.sender].totalLoss,\n        self.strategies[msg.sender].totalDebt,\n        credit,\n        self.strategies[msg.sender].debtRatio,\n    )\n\n    if self.strategies[msg.sender].debtRatio == 0 or self.emergencyShutdown:\n        # Take every last penny the Strategy has (Emergency Exit/revokeStrategy)\n        # NOTE: This is different than `debt` in order to extract *all* of the returns\n        return Strategy(msg.sender).estimatedTotalAssets()\n    else:\n        # Otherwise, just return what we have as debt outstanding\n        return debt\n\n\n@external\ndef sweep(token: address, amount: uint256 = MAX_UINT256):\n    \"\"\"\n    @notice\n        Removes tokens from this Vault that are not the type of token managed\n        by this Vault. This may be used in case of accidentally sending the\n        wrong kind of token to this Vault.\n\n        Tokens will be sent to `governance`.\n\n        This will fail if an attempt is made to sweep the tokens that this\n        Vault manages.\n\n        This may only be called by governance.\n    @param token The token to transfer out of this vault.\n    @param amount The quantity or tokenId to transfer out.\n    \"\"\"\n    assert msg.sender == self.governance\n    # Can't be used to steal what this Vault is protecting\n    value: uint256 = amount\n    if value == MAX_UINT256:\n        value = ERC20(token).balanceOf(self)\n\n    if token == self.token.address:\n        value = self.token.balanceOf(self) - self.totalIdle\n\n    log Sweep(token, value)\n    self.erc20_safe_transfer(token, self.governance, value)\n","imports":["vyper/interfaces/ERC20.json"],"references":[],"urls":[]},"test/TestStrategy.sol":{"checksum":{"algorithm":"md5","hash":"0xc53c6e771abce6d42a2b0148408ee8cd"},"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {BaseStrategyInitializable, StrategyParams, VaultAPI} from \"../BaseStrategy.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/*\n * This Strategy serves as both a mock Strategy for testing, and an example\n * for integrators on how to use BaseStrategy\n */\n\ncontract TestStrategy is BaseStrategyInitializable {\n    bool public doReentrancy;\n    bool public delegateEverything;\n\n    // Some token that needs to be protected for some reason\n    // Initialize this to some fake address, because we're just using it\n    // to test `BaseStrategy.protectedTokens()`\n    address public constant protectedToken = address(0xbad);\n\n    constructor(address _vault) BaseStrategyInitializable(_vault) {}\n\n    function name() external view override returns (string memory) {\n        return string(abi.encodePacked(\"TestStrategy \", apiVersion()));\n    }\n\n    // NOTE: This is a test-only function to simulate delegation\n    function _toggleDelegation() public {\n        delegateEverything = !delegateEverything;\n    }\n\n    function delegatedAssets() external view override returns (uint256) {\n        if (delegateEverything) {\n            return vault.strategies(address(this)).totalDebt;\n        } else {\n            return 0;\n        }\n    }\n\n    // NOTE: This is a test-only function to simulate losses\n    function _takeFunds(uint256 amount) public {\n        SafeERC20.safeTransfer(want, msg.sender, amount);\n    }\n\n    // NOTE: This is a test-only function to enable reentrancy on withdraw\n    function _toggleReentrancyExploit() public {\n        doReentrancy = !doReentrancy;\n    }\n\n    // NOTE: This is a test-only function to simulate a wrong want token\n    function _setWant(IERC20 _want) public {\n        want = _want;\n    }\n\n    function ethToWant(uint256 amtInWei) public view override returns (uint256) {\n        return amtInWei; // 1:1 conversion for testing\n    }\n\n    function estimatedTotalAssets() public view override returns (uint256) {\n        // For mock, this is just everything we have\n        return want.balanceOf(address(this));\n    }\n\n    function prepareReturn(uint256 _debtOutstanding)\n        internal\n        override\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        )\n    {\n        // During testing, send this contract some tokens to simulate \"Rewards\"\n        uint256 totalAssets = want.balanceOf(address(this));\n        uint256 totalDebt = vault.strategies(address(this)).totalDebt;\n        if (totalAssets > _debtOutstanding) {\n            _debtPayment = _debtOutstanding;\n            totalAssets = totalAssets - _debtOutstanding;\n        } else {\n            _debtPayment = totalAssets;\n            totalAssets = 0;\n        }\n        totalDebt = totalDebt - _debtPayment;\n\n        if (totalAssets > totalDebt) {\n            _profit = totalAssets - totalDebt;\n        } else {\n            _loss = totalDebt - totalAssets;\n        }\n    }\n\n    function adjustPosition(uint256 _debtOutstanding) internal override {\n        // Whatever we have \"free\", consider it \"invested\" now\n    }\n\n    function liquidatePosition(uint256 _amountNeeded) internal override returns (uint256 _liquidatedAmount, uint256 _loss) {\n        if (doReentrancy) {\n            // simulate a malicious protocol or reentrancy situation triggered by strategy withdraw interactions\n            uint256 stratBalance = VaultAPI(address(vault)).balanceOf(address(this));\n            VaultAPI(address(vault)).withdraw(stratBalance, address(this));\n        }\n\n        uint256 totalDebt = vault.strategies(address(this)).totalDebt;\n        uint256 totalAssets = want.balanceOf(address(this));\n        if (_amountNeeded > totalAssets) {\n            _liquidatedAmount = totalAssets;\n            _loss = _amountNeeded - totalAssets;\n        } else {\n            // NOTE: Just in case something was stolen from this contract\n            if (totalDebt > totalAssets) {\n                _loss = totalDebt - totalAssets;\n                if (_loss > _amountNeeded) _loss = _amountNeeded;\n            }\n            _liquidatedAmount = _amountNeeded;\n        }\n    }\n\n    function prepareMigration(address _newStrategy) internal override {\n        // Nothing needed here because no additional tokens/tokenized positions for mock\n    }\n\n    function protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](1);\n        protected[0] = protectedToken;\n        return protected;\n    }\n\n    function liquidateAllPositions() internal override returns (uint256 amountFreed) {\n        uint256 totalAssets = want.balanceOf(address(this));\n        amountFreed = totalAssets;\n    }\n}\n","imports":["BaseStrategy.sol",".cache/OpenZeppelin/v4.7.1/token/ERC20/IERC20.sol",".cache/OpenZeppelin/v4.7.1/token/ERC20/utils/SafeERC20.sol"],"references":[],"urls":[]},"test/Token.sol":{"checksum":{"algorithm":"md5","hash":"0x499dd41cebf0e9c4ba4a627789b3d2a5"},"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract Token is ERC20 {\n    mapping(address => bool) public _blocked;\n    uint8 private immutable _decimals;\n\n    constructor(uint8 decimals_) ERC20(\"yearn.finance test token\", \"TEST\") {\n        _decimals = decimals_;\n        _mint(msg.sender, 30000 * 10**uint256(decimals_));\n    }\n\n    function _setBlocked(address user, bool value) public virtual {\n        _blocked[user] = value;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20) {\n        require(!_blocked[to], \"Token transfer refused. Receiver is on blacklist\");\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n}\n\ncontract TokenNoReturn {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    mapping(address => bool) public _blocked;\n\n    constructor(uint8 _decimals) {\n        name = \"yearn.finance test token\";\n        symbol = \"TEST\";\n        decimals = _decimals;\n        balanceOf[msg.sender] = 30000 * 10**uint256(_decimals);\n        totalSupply = 30000 * 10**uint256(_decimals);\n    }\n\n    function _setBlocked(address user, bool value) public virtual {\n        _blocked[user] = value;\n    }\n\n    function transfer(address receiver, uint256 amount) external {\n        require(!_blocked[receiver], \"Token transfer refused. Receiver is on blacklist\");\n        balanceOf[msg.sender] = balanceOf[msg.sender] - amount;\n        balanceOf[receiver] = balanceOf[receiver] + amount;\n        emit Transfer(msg.sender, receiver, amount);\n    }\n\n    function approve(address spender, uint256 amount) external {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n    }\n\n    function transferFrom(\n        address sender,\n        address receiver,\n        uint256 amount\n    ) external {\n        require(!_blocked[receiver], \"Token transfer refused. Receiver is on blacklist\");\n        allowance[sender][msg.sender] = allowance[sender][msg.sender] - amount;\n        balanceOf[sender] = balanceOf[sender] - amount;\n        balanceOf[receiver] = balanceOf[receiver] + amount;\n        emit Transfer(sender, receiver, amount);\n    }\n}\n\ncontract TokenFalseReturn is Token {\n    constructor(uint8 _decimals) Token(_decimals) {}\n\n    function transfer(address receiver, uint256 amount) public virtual override returns (bool) {\n        return false;\n    }\n\n    function transferFrom(\n        address sender,\n        address receiver,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        return false;\n    }\n}\n","imports":[".cache/OpenZeppelin/v4.7.1/token/ERC20/ERC20.sol"],"references":[],"urls":[]}},"version":"0.4.5"}