{"compilers":[{"contractTypes":[],"name":"solidity","settings":{"optimizer":{"enabled":true,"runs":200},"outputSelection":{"AccessControl.sol":{"AccessControl":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"AccessControlCrossChain.sol":{"AccessControlCrossChain":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"AccessControlCrossChainMock.sol":{"AccessControlCrossChainMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"AccessControlEnumerable.sol":{"AccessControlEnumerable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"AccessControlEnumerableMock.sol":{"AccessControlEnumerableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"AccessControlMock.sol":{"AccessControlMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Address.sol":{"Address":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"AddressImpl.sol":{"AddressImpl":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Arrays.sol":{"Arrays":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ArraysImpl.sol":{"ArraysImpl":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"BadBeacon.sol":{"BadBeacon":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Base64.sol":{"Base64":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Base64Mock.sol":{"Base64Mock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"BeaconProxy.sol":{"BeaconProxy":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"BitMaps.sol":{"BitMaps":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"BitmapMock.sol":{"BitmapMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"CallReceiverMock.sol":{"CallReceiverMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Checkpoints.sol":{"Checkpoints":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"CheckpointsImpl.sol":{"CheckpointsImpl":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ClashingImplementation.sol":{"ClashingImplementation":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Clones.sol":{"Clones":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ClonesMock.sol":{"ClonesMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"CompTimelock.sol":{"CompTimelock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ConditionalEscrow.sol":{"ConditionalEscrow":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ConditionalEscrowMock.sol":{"ConditionalEscrowMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Context.sol":{"Context":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ContextMock.sol":{"ContextMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Counters.sol":{"Counters":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"CountersImpl.sol":{"CountersImpl":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Create2.sol":{"Create2":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Create2Impl.sol":{"Create2Impl":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"CrossChainEnabled.sol":{"CrossChainEnabled":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"CrossChainEnabledAMB.sol":{"CrossChainEnabledAMB":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"CrossChainEnabledArbitrumL1.sol":{"CrossChainEnabledArbitrumL1":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"CrossChainEnabledArbitrumL2.sol":{"CrossChainEnabledArbitrumL2":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"CrossChainEnabledOptimism.sol":{"CrossChainEnabledOptimism":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"CrossChainEnabledPolygonChild.sol":{"CrossChainEnabledPolygonChild":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"DoubleEndedQueue.sol":{"DoubleEndedQueue":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"DoubleEndedQueueMock.sol":{"DoubleEndedQueueMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"DummyImplementation.sol":{"DummyImplementation":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ECDSA.sol":{"ECDSA":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ECDSAMock.sol":{"ECDSAMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"EIP712External.sol":{"EIP712External":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155.sol":{"ERC1155":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155Burnable.sol":{"ERC1155Burnable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155BurnableMock.sol":{"ERC1155BurnableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155Holder.sol":{"ERC1155Holder":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155Mock.sol":{"ERC1155Mock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155Pausable.sol":{"ERC1155Pausable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155PausableMock.sol":{"ERC1155PausableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155PresetMinterPauser.sol":{"ERC1155PresetMinterPauser":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155Receiver.sol":{"ERC1155Receiver":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155ReceiverMock.sol":{"ERC1155ReceiverMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155Supply.sol":{"ERC1155Supply":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155SupplyMock.sol":{"ERC1155SupplyMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155URIStorage.sol":{"ERC1155URIStorage":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1155URIStorageMock.sol":{"ERC1155URIStorageMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1271WalletMock.sol":{"ERC1271WalletMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC165.sol":{"ERC165":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC165Checker.sol":{"ERC165Checker":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC165CheckerMock.sol":{"ERC165CheckerMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC165InterfacesSupported.sol":{"ERC165InterfacesSupported":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC165MaliciousData.sol":{"ERC165MaliciousData":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC165MissingData.sol":{"ERC165MissingData":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC165Mock.sol":{"ERC165Mock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC165NotSupported.sol":{"ERC165NotSupported":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC165Storage.sol":{"ERC165Storage":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC165StorageMock.sol":{"ERC165StorageMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1820Implementer.sol":{"ERC1820Implementer":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1820ImplementerMock.sol":{"ERC1820ImplementerMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1967Proxy.sol":{"ERC1967Proxy":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC1967Upgrade.sol":{"ERC1967Upgrade":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20.sol":{"ERC20":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20Burnable.sol":{"ERC20Burnable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20BurnableMock.sol":{"ERC20BurnableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20Capped.sol":{"ERC20Capped":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20CappedMock.sol":{"ERC20CappedMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20DecimalsMock.sol":{"ERC20DecimalsMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20FlashMint.sol":{"ERC20FlashMint":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20FlashMintMock.sol":{"ERC20FlashMintMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20Mock.sol":{"ERC20Mock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20Pausable.sol":{"ERC20Pausable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20PausableMock.sol":{"ERC20PausableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20PermitMock.sol":{"ERC20PermitMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20PresetFixedSupply.sol":{"ERC20PresetFixedSupply":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20PresetMinterPauser.sol":{"ERC20PresetMinterPauser":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20Snapshot.sol":{"ERC20Snapshot":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20SnapshotMock.sol":{"ERC20SnapshotMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20Votes.sol":{"ERC20Votes":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20VotesComp.sol":{"ERC20VotesComp":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20VotesCompMock.sol":{"ERC20VotesCompMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20VotesMock.sol":{"ERC20VotesMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20Wrapper.sol":{"ERC20Wrapper":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC20WrapperMock.sol":{"ERC20WrapperMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC2771Context.sol":{"ERC2771Context":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC2771ContextMock.sol":{"ERC2771ContextMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC2981.sol":{"ERC2981":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC3156FlashBorrowerMock.sol":{"ERC3156FlashBorrowerMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC4626.sol":{"ERC4626":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC4626Mock.sol":{"ERC4626Mock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721.sol":{"ERC721":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721Burnable.sol":{"ERC721Burnable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721BurnableMock.sol":{"ERC721BurnableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721Enumerable.sol":{"ERC721Enumerable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721EnumerableMock.sol":{"ERC721EnumerableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721Holder.sol":{"ERC721Holder":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721Mock.sol":{"ERC721Mock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721Pausable.sol":{"ERC721Pausable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721PausableMock.sol":{"ERC721PausableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721PresetMinterPauserAutoId.sol":{"ERC721PresetMinterPauserAutoId":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721ReceiverMock.sol":{"ERC721ReceiverMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721Royalty.sol":{"ERC721Royalty":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721RoyaltyMock.sol":{"ERC721RoyaltyMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721URIStorage.sol":{"ERC721URIStorage":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721URIStorageMock.sol":{"ERC721URIStorageMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC721VotesMock.sol":{"ERC721VotesMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC777.sol":{"ERC777":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC777Mock.sol":{"ERC777Mock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC777PresetFixedSupply.sol":{"ERC777PresetFixedSupply":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ERC777SenderRecipientMock.sol":{"ERC777SenderRecipientMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"EnumerableMap.sol":{"EnumerableMap":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"EnumerableMapMock.sol":{"EnumerableMapMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"EnumerableSet.sol":{"EnumerableSet":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"EnumerableSetMock.sol":{"EnumerableSetMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Escrow.sol":{"Escrow":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"EtherReceiverMock.sol":{"EtherReceiverMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Governor.sol":{"Governor":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorCompMock.sol":{"GovernorCompMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorCompatibilityBravo.sol":{"GovernorCompatibilityBravo":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorCompatibilityBravoMock.sol":{"GovernorCompatibilityBravoMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorCountingSimple.sol":{"GovernorCountingSimple":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorMock.sol":{"GovernorMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorPreventLateQuorum.sol":{"GovernorPreventLateQuorum":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorPreventLateQuorumMock.sol":{"GovernorPreventLateQuorumMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorProposalThreshold.sol":{"GovernorProposalThreshold":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorSettings.sol":{"GovernorSettings":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorTimelockCompound.sol":{"GovernorTimelockCompound":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorTimelockCompoundMock.sol":{"GovernorTimelockCompoundMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorTimelockControl.sol":{"GovernorTimelockControl":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorTimelockControlMock.sol":{"GovernorTimelockControlMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorVoteMock.sol":{"GovernorVoteMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorVotes.sol":{"GovernorVotes":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorVotesComp.sol":{"GovernorVotesComp":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorVotesQuorumFraction.sol":{"GovernorVotesQuorumFraction":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"GovernorWithParamsMock.sol":{"GovernorWithParamsMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IAMB.sol":{"IAMB":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IAccessControl.sol":{"IAccessControl":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IAccessControlEnumerable.sol":{"IAccessControlEnumerable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IArbSys.sol":{"IArbSys":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IBeacon.sol":{"IBeacon":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IBridge.sol":{"IBridge":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ICompoundTimelock.sol":{"ICompoundTimelock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ICrossDomainMessenger.sol":{"ICrossDomainMessenger":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC1155.sol":{"IERC1155":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC1155MetadataURI.sol":{"IERC1155MetadataURI":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC1155Receiver.sol":{"IERC1155Receiver":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC1271.sol":{"IERC1271":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC1363.sol":{"IERC1363":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC1363Receiver.sol":{"IERC1363Receiver":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC1363Spender.sol":{"IERC1363Spender":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC165.sol":{"IERC165":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC1820Implementer.sol":{"IERC1820Implementer":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC1820Registry.sol":{"IERC1820Registry":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC20.sol":{"IERC20":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC20Metadata.sol":{"IERC20Metadata":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC2981.sol":{"IERC2981":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC3156.sol":{"IERC3156":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC3156FlashBorrower.sol":{"IERC3156FlashBorrower":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC3156FlashLender.sol":{"IERC3156FlashLender":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC4626.sol":{"IERC4626":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC721.sol":{"IERC721":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC721Enumerable.sol":{"IERC721Enumerable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC721Metadata.sol":{"IERC721Metadata":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC721Receiver.sol":{"IERC721Receiver":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC777.sol":{"IERC777":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC777Recipient.sol":{"IERC777Recipient":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IERC777Sender.sol":{"IERC777Sender":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IFxMessageProcessor.sol":{"IFxMessageProcessor":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IGovernor.sol":{"IGovernor":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IGovernorCompatibilityBravo.sol":{"IGovernorCompatibilityBravo":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IGovernorTimelock.sol":{"IGovernorTimelock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IInbox.sol":{"IInbox":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IMessageProvider.sol":{"IMessageProvider":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IOutbox.sol":{"IOutbox":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"IVotes.sol":{"IVotes":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Initializable.sol":{"Initializable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"InitializableMock.sol":{"InitializableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"LibAMB.sol":{"LibAMB":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"LibArbitrumL1.sol":{"LibArbitrumL1":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"LibArbitrumL2.sol":{"LibArbitrumL2":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"LibOptimism.sol":{"LibOptimism":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Math.sol":{"Math":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"MathMock.sol":{"MathMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"MerkleProof.sol":{"MerkleProof":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"MerkleProofWrapper.sol":{"MerkleProofWrapper":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"MinimalForwarder.sol":{"MinimalForwarder":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Multicall.sol":{"Multicall":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"MulticallTest.sol":{"MulticallTest":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"MulticallTokenMock.sol":{"MulticallTokenMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"MultipleInheritanceInitializableMocks.sol":{"MultipleInheritanceInitializableMocks":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"MyGovernor1.sol":{"MyGovernor1":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"MyGovernor2.sol":{"MyGovernor2":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"MyGovernor3.sol":{"MyGovernor3":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Ownable.sol":{"Ownable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"OwnableMock.sol":{"OwnableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Pausable.sol":{"Pausable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"PausableMock.sol":{"PausableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"PaymentSplitter.sol":{"PaymentSplitter":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Proxy.sol":{"Proxy":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ProxyAdmin.sol":{"ProxyAdmin":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"PullPayment.sol":{"PullPayment":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"PullPaymentMock.sol":{"PullPaymentMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ReentrancyAttack.sol":{"ReentrancyAttack":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ReentrancyGuard.sol":{"ReentrancyGuard":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"ReentrancyMock.sol":{"ReentrancyMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"RefundEscrow.sol":{"RefundEscrow":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"RegressionImplementation.sol":{"RegressionImplementation":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SafeCast.sol":{"SafeCast":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SafeCastMock.sol":{"SafeCastMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SafeERC20.sol":{"SafeERC20":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SafeERC20Helper.sol":{"SafeERC20Helper":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SafeMath.sol":{"SafeMath":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SafeMathMock.sol":{"SafeMathMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SignatureChecker.sol":{"SignatureChecker":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SignatureCheckerMock.sol":{"SignatureCheckerMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SignedMath.sol":{"SignedMath":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SignedMathMock.sol":{"SignedMathMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SignedSafeMath.sol":{"SignedSafeMath":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SignedSafeMathMock.sol":{"SignedSafeMathMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"SingleInheritanceInitializableMocks.sol":{"SingleInheritanceInitializableMocks":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"StorageSlot.sol":{"StorageSlot":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"StorageSlotMock.sol":{"StorageSlotMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Strings.sol":{"Strings":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"StringsMock.sol":{"StringsMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"TimelockController.sol":{"TimelockController":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Timers.sol":{"Timers":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"TimersBlockNumberImpl.sol":{"TimersBlockNumberImpl":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"TimersTimestampImpl.sol":{"TimersTimestampImpl":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"TokenTimelock.sol":{"TokenTimelock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"TransparentUpgradeableProxy.sol":{"TransparentUpgradeableProxy":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"UUPSLegacy.sol":{"UUPSLegacy":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"UUPSUpgradeable.sol":{"UUPSUpgradeable":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"UUPSUpgradeableMock.sol":{"UUPSUpgradeableMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"UpgradeableBeacon.sol":{"UpgradeableBeacon":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"VestingWallet.sol":{"VestingWallet":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"Votes.sol":{"Votes":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"VotesMock.sol":{"VotesMock":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"bridges.sol":{"bridges":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"draft-EIP712.sol":{"draft-EIP712":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"draft-ERC20Permit.sol":{"draft-ERC20Permit":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"draft-ERC721Votes.sol":{"draft-ERC721Votes":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"draft-IERC1822.sol":{"draft-IERC1822":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"draft-IERC20Permit.sol":{"draft-IERC20Permit":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"draft-IERC2612.sol":{"draft-IERC2612":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"errors.sol":{"errors":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]},"receivers.sol":{"receivers":["abi","bin","bin-runtime","devdoc","userdoc","srcmap"]}}},"version":"0.8.19+commit.7dd6d404"}],"contractTypes":{},"manifest":"ethpm/3","name":"openzeppelin","sources":{"access/AccessControl.sol":{"checksum":{"algorithm":"md5","hash":"0xe6ef731d275b1e7b2995f00fa56d9dab"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n","imports":["access/IAccessControl.sol","utils/Strings.sol","utils/Context.sol","utils/introspection/ERC165.sol"],"references":["access/AccessControlEnumerable.sol","mocks/AccessControlMock.sol","governance/TimelockController.sol","access/AccessControlCrossChain.sol"],"urls":[]},"access/AccessControlCrossChain.sol":{"checksum":{"algorithm":"md5","hash":"0x562db8d0df4d1a9a6c8a994a9b8c15c6"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (access/AccessControlCrossChain.sol)\n\npragma solidity ^0.8.4;\n\nimport \"./AccessControl.sol\";\nimport \"../crosschain/CrossChainEnabled.sol\";\n\n/**\n * @dev An extension to {AccessControl} with support for cross-chain access management.\n * For each role, is extension implements an equivalent \"aliased\" role that is used for\n * restricting calls originating from other chains.\n *\n * For example, if a function `myFunction` is protected by `onlyRole(SOME_ROLE)`, and\n * if an address `x` has role `SOME_ROLE`, it would be able to call `myFunction` directly.\n * A wallet or contract at the same address on another chain would however not be able\n * to call this function. In order to do so, it would require to have the role\n * `_crossChainRoleAlias(SOME_ROLE)`.\n *\n * This aliasing is required to protect against multiple contracts living at the same\n * address on different chains but controlled by conflicting entities.\n *\n * _Available since v4.6._\n */\nabstract contract AccessControlCrossChain is AccessControl, CrossChainEnabled {\n    bytes32 public constant CROSSCHAIN_ALIAS = keccak256(\"CROSSCHAIN_ALIAS\");\n\n    /**\n     * @dev See {AccessControl-_checkRole}.\n     */\n    function _checkRole(bytes32 role) internal view virtual override {\n        if (_isCrossChain()) {\n            _checkRole(_crossChainRoleAlias(role), _crossChainSender());\n        } else {\n            super._checkRole(role);\n        }\n    }\n\n    /**\n     * @dev Returns the aliased role corresponding to `role`.\n     */\n    function _crossChainRoleAlias(bytes32 role) internal pure virtual returns (bytes32) {\n        return role ^ CROSSCHAIN_ALIAS;\n    }\n}\n","imports":["crosschain/CrossChainEnabled.sol","access/AccessControl.sol"],"references":["mocks/AccessControlCrossChainMock.sol"],"urls":[]},"access/AccessControlEnumerable.sol":{"checksum":{"algorithm":"md5","hash":"0xb6d9b165dc57e9ad8153bdca05c783a4"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n}\n","imports":["utils/structs/EnumerableSet.sol","access/AccessControl.sol","access/IAccessControlEnumerable.sol"],"references":["token/ERC1155/presets/ERC1155PresetMinterPauser.sol","token/ERC20/presets/ERC20PresetMinterPauser.sol","token/ERC721/presets/ERC721PresetMinterPauserAutoId.sol","mocks/AccessControlEnumerableMock.sol"],"urls":[]},"access/IAccessControl.sol":{"checksum":{"algorithm":"md5","hash":"0x57c84298234411cea19c7c284d86be8b"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n","imports":[],"references":["access/IAccessControlEnumerable.sol","access/AccessControl.sol"],"urls":[]},"access/IAccessControlEnumerable.sol":{"checksum":{"algorithm":"md5","hash":"0x4e71cc90682e109e999ce2bd329f6572"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n","imports":["access/IAccessControl.sol"],"references":["access/AccessControlEnumerable.sol"],"urls":[]},"access/Ownable.sol":{"checksum":{"algorithm":"md5","hash":"0xe436cea06129be2c73cda4b1acc848b5"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n","imports":["utils/Context.sol"],"references":["mocks/ERC1271WalletMock.sol","mocks/OwnableMock.sol","utils/escrow/Escrow.sol","proxy/transparent/ProxyAdmin.sol","proxy/beacon/UpgradeableBeacon.sol","mocks/crosschain/receivers.sol"],"urls":[]},"access/README.adoc":{"checksum":{"algorithm":"md5","hash":"0x1eb97360fda7ce2169361fd8aafe955e"},"content":"= Access Control\n\n[.readme-notice]\nNOTE: This document is better viewed at https://docs.openzeppelin.com/contracts/api/access\n\nThis directory provides ways to restrict who can access the functions of a contract or when they can do it.\n\n- {AccessControl} provides a general role based access control mechanism. Multiple hierarchical roles can be created and assigned each to multiple accounts.\n- {Ownable} is a simpler mechanism with a single owner \"role\" that can be assigned to a single account. This simpler mechanism can be useful for quick tests but projects with production concerns are likely to outgrow it.\n\n== Authorization\n\n{{Ownable}}\n\n{{IAccessControl}}\n\n{{AccessControl}}\n\n{{AccessControlCrossChain}}\n\n{{IAccessControlEnumerable}}\n\n{{AccessControlEnumerable}}\n","imports":[],"references":[],"urls":[]},"crosschain/CrossChainEnabled.sol":{"checksum":{"algorithm":"md5","hash":"0xcdff8c7d7f4945a9c3e1832716edfeef"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (crosschain/CrossChainEnabled.sol)\n\npragma solidity ^0.8.4;\n\nimport \"./errors.sol\";\n\n/**\n * @dev Provides information for building cross-chain aware contracts. This\n * abstract contract provides accessors and modifiers to control the execution\n * flow when receiving cross-chain messages.\n *\n * Actual implementations of cross-chain aware contracts, which are based on\n * this abstraction, will  have to inherit from a bridge-specific\n * specialization. Such specializations are provided under\n * `crosschain/<chain>/CrossChainEnabled<chain>.sol`.\n *\n * _Available since v4.6._\n */\nabstract contract CrossChainEnabled {\n    /**\n     * @dev Throws if the current function call is not the result of a\n     * cross-chain execution.\n     */\n    modifier onlyCrossChain() {\n        if (!_isCrossChain()) revert NotCrossChainCall();\n        _;\n    }\n\n    /**\n     * @dev Throws if the current function call is not the result of a\n     * cross-chain execution initiated by `account`.\n     */\n    modifier onlyCrossChainSender(address expected) {\n        address actual = _crossChainSender();\n        if (expected != actual) revert InvalidCrossChainSender(actual, expected);\n        _;\n    }\n\n    /**\n     * @dev Returns whether the current function call is the result of a\n     * cross-chain message.\n     */\n    function _isCrossChain() internal view virtual returns (bool);\n\n    /**\n     * @dev Returns the address of the sender of the cross-chain message that\n     * triggered the current function call.\n     *\n     * IMPORTANT: Should revert with `NotCrossChainCall` if the current function\n     * call is not the result of a cross-chain message.\n     */\n    function _crossChainSender() internal view virtual returns (address);\n}\n","imports":["crosschain/errors.sol"],"references":["crosschain/polygon/CrossChainEnabledPolygonChild.sol","crosschain/optimism/CrossChainEnabledOptimism.sol","crosschain/amb/CrossChainEnabledAMB.sol","crosschain/arbitrum/CrossChainEnabledArbitrumL2.sol","access/AccessControlCrossChain.sol","crosschain/arbitrum/CrossChainEnabledArbitrumL1.sol"],"urls":[]},"crosschain/README.adoc":{"checksum":{"algorithm":"md5","hash":"0xa491b854d96a987464ddac9c80da51b1"},"content":"= Cross Chain Awareness\n\n[.readme-notice]\nNOTE: This document is better viewed at https://docs.openzeppelin.com/contracts/api/crosschain\n\nThis directory provides building blocks to improve cross-chain awareness of smart contracts.\n\n- {CrossChainEnabled} is an abstraction that contains accessors and modifiers to control the execution flow when receiving cross-chain messages.\n\n== CrossChainEnabled specializations\n\nThe following specializations of {CrossChainEnabled} provide implementations of the {CrossChainEnabled} abstraction for specific bridges. This can be used to complex cross-chain aware components such as {AccessControlCrossChain}.\n\n{{CrossChainEnabledAMB}}\n\n{{CrossChainEnabledArbitrumL1}}\n\n{{CrossChainEnabledArbitrumL2}}\n\n{{CrossChainEnabledOptimism}}\n\n{{CrossChainEnabledPolygonChild}}\n\n== Libraries for cross-chain\n\nIn addition to the {CrossChainEnabled} abstraction, cross-chain awareness is also available through libraries. These libraries can be used to build complex designs such as contracts with the ability to interact with multiple bridges.\n\n{{LibAMB}}\n\n{{LibArbitrumL1}}\n\n{{LibArbitrumL2}}\n\n{{LibOptimism}}\n","imports":[],"references":[],"urls":[]},"crosschain/amb/CrossChainEnabledAMB.sol":{"checksum":{"algorithm":"md5","hash":"0x8a0a6079d517a951b8da46f2c982ace1"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (crosschain/amb/CrossChainEnabledAMB.sol)\n\npragma solidity ^0.8.4;\n\nimport \"../CrossChainEnabled.sol\";\nimport \"./LibAMB.sol\";\n\n/**\n * @dev https://docs.tokenbridge.net/amb-bridge/about-amb-bridge[AMB]\n * specialization or the {CrossChainEnabled} abstraction.\n *\n * As of february 2020, AMB bridges are available between the following chains:\n *\n * - https://docs.tokenbridge.net/eth-xdai-amb-bridge/about-the-eth-xdai-amb[ETH \u21cc xDai]\n * - https://docs.tokenbridge.net/eth-qdai-bridge/about-the-eth-qdai-amb[ETH \u21cc qDai]\n * - https://docs.tokenbridge.net/eth-etc-amb-bridge/about-the-eth-etc-amb[ETH \u21cc ETC]\n * - https://docs.tokenbridge.net/eth-bsc-amb/about-the-eth-bsc-amb[ETH \u21cc BSC]\n * - https://docs.tokenbridge.net/eth-poa-amb-bridge/about-the-eth-poa-amb[ETH \u21cc POA]\n * - https://docs.tokenbridge.net/bsc-xdai-amb/about-the-bsc-xdai-amb[BSC \u21cc xDai]\n * - https://docs.tokenbridge.net/poa-xdai-amb/about-the-poa-xdai-amb[POA \u21cc xDai]\n * - https://docs.tokenbridge.net/rinkeby-xdai-amb-bridge/about-the-rinkeby-xdai-amb[Rinkeby \u21cc xDai]\n * - https://docs.tokenbridge.net/kovan-sokol-amb-bridge/about-the-kovan-sokol-amb[Kovan \u21cc Sokol]\n *\n * _Available since v4.6._\n */\ncontract CrossChainEnabledAMB is CrossChainEnabled {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _bridge;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address bridge) {\n        _bridge = bridge;\n    }\n\n    /**\n     * @dev see {CrossChainEnabled-_isCrossChain}\n     */\n    function _isCrossChain() internal view virtual override returns (bool) {\n        return LibAMB.isCrossChain(_bridge);\n    }\n\n    /**\n     * @dev see {CrossChainEnabled-_crossChainSender}\n     */\n    function _crossChainSender() internal view virtual override onlyCrossChain returns (address) {\n        return LibAMB.crossChainSender(_bridge);\n    }\n}\n","imports":["crosschain/amb/LibAMB.sol","crosschain/CrossChainEnabled.sol"],"references":["mocks/crosschain/receivers.sol"],"urls":[]},"crosschain/amb/LibAMB.sol":{"checksum":{"algorithm":"md5","hash":"0xaca66130bac2b428adb3d9f908123fb2"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (crosschain/amb/LibAMB.sol)\n\npragma solidity ^0.8.4;\n\nimport {IAMB as AMB_Bridge} from \"../../vendor/amb/IAMB.sol\";\nimport \"../errors.sol\";\n\n/**\n * @dev Primitives for cross-chain aware contracts using the\n * https://docs.tokenbridge.net/amb-bridge/about-amb-bridge[AMB]\n * family of bridges.\n */\nlibrary LibAMB {\n    /**\n     * @dev Returns whether the current function call is the result of a\n     * cross-chain message relayed by `bridge`.\n     */\n    function isCrossChain(address bridge) internal view returns (bool) {\n        return msg.sender == bridge;\n    }\n\n    /**\n     * @dev Returns the address of the sender that triggered the current\n     * cross-chain message through `bridge`.\n     *\n     * NOTE: {isCrossChain} should be checked before trying to recover the\n     * sender, as it will revert with `NotCrossChainCall` if the current\n     * function call is not the result of a cross-chain message.\n     */\n    function crossChainSender(address bridge) internal view returns (address) {\n        if (!isCrossChain(bridge)) revert NotCrossChainCall();\n        return AMB_Bridge(bridge).messageSender();\n    }\n}\n","imports":["crosschain/errors.sol","vendor/amb/IAMB.sol"],"references":["crosschain/amb/CrossChainEnabledAMB.sol"],"urls":[]},"crosschain/arbitrum/CrossChainEnabledArbitrumL1.sol":{"checksum":{"algorithm":"md5","hash":"0x31dc8ded3beb19204c7c5da4a74a47e1"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (crosschain/arbitrum/CrossChainEnabledArbitrumL1.sol)\n\npragma solidity ^0.8.4;\n\nimport \"../CrossChainEnabled.sol\";\nimport \"./LibArbitrumL1.sol\";\n\n/**\n * @dev https://arbitrum.io/[Arbitrum] specialization or the\n * {CrossChainEnabled} abstraction the L1 side (mainnet).\n *\n * This version should only be deployed on L1 to process cross-chain messages\n * originating from L2. For the other side, use {CrossChainEnabledArbitrumL2}.\n *\n * The bridge contract is provided and maintained by the arbitrum team. You can\n * find the address of this contract on the rinkeby testnet in\n * https://developer.offchainlabs.com/docs/useful_addresses[Arbitrum's developer documentation].\n *\n * _Available since v4.6._\n */\nabstract contract CrossChainEnabledArbitrumL1 is CrossChainEnabled {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _bridge;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address bridge) {\n        _bridge = bridge;\n    }\n\n    /**\n     * @dev see {CrossChainEnabled-_isCrossChain}\n     */\n    function _isCrossChain() internal view virtual override returns (bool) {\n        return LibArbitrumL1.isCrossChain(_bridge);\n    }\n\n    /**\n     * @dev see {CrossChainEnabled-_crossChainSender}\n     */\n    function _crossChainSender() internal view virtual override onlyCrossChain returns (address) {\n        return LibArbitrumL1.crossChainSender(_bridge);\n    }\n}\n","imports":["crosschain/CrossChainEnabled.sol","crosschain/arbitrum/LibArbitrumL1.sol"],"references":["mocks/crosschain/receivers.sol"],"urls":[]},"crosschain/arbitrum/CrossChainEnabledArbitrumL2.sol":{"checksum":{"algorithm":"md5","hash":"0xd5380da16db889cd1b39d0851795bb75"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (crosschain/arbitrum/CrossChainEnabledArbitrumL2.sol)\n\npragma solidity ^0.8.4;\n\nimport \"../CrossChainEnabled.sol\";\nimport \"./LibArbitrumL2.sol\";\n\n/**\n * @dev https://arbitrum.io/[Arbitrum] specialization or the\n * {CrossChainEnabled} abstraction the L2 side (arbitrum).\n *\n * This version should only be deployed on L2 to process cross-chain messages\n * originating from L1. For the other side, use {CrossChainEnabledArbitrumL1}.\n *\n * Arbitrum L2 includes the `ArbSys` contract at a fixed address. Therefore,\n * this specialization of {CrossChainEnabled} does not include a constructor.\n *\n * _Available since v4.6._\n */\nabstract contract CrossChainEnabledArbitrumL2 is CrossChainEnabled {\n    /**\n     * @dev see {CrossChainEnabled-_isCrossChain}\n     */\n    function _isCrossChain() internal view virtual override returns (bool) {\n        return LibArbitrumL2.isCrossChain(LibArbitrumL2.ARBSYS);\n    }\n\n    /**\n     * @dev see {CrossChainEnabled-_crossChainSender}\n     */\n    function _crossChainSender() internal view virtual override onlyCrossChain returns (address) {\n        return LibArbitrumL2.crossChainSender(LibArbitrumL2.ARBSYS);\n    }\n}\n","imports":["crosschain/arbitrum/LibArbitrumL2.sol","crosschain/CrossChainEnabled.sol"],"references":["mocks/AccessControlCrossChainMock.sol","mocks/crosschain/receivers.sol"],"urls":[]},"crosschain/arbitrum/LibArbitrumL1.sol":{"checksum":{"algorithm":"md5","hash":"0x8fa2ca12678cb0770d10f385d49c07e2"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (crosschain/arbitrum/LibArbitrumL1.sol)\n\npragma solidity ^0.8.4;\n\nimport {IBridge as ArbitrumL1_Bridge} from \"../../vendor/arbitrum/IBridge.sol\";\nimport {IInbox as ArbitrumL1_Inbox} from \"../../vendor/arbitrum/IInbox.sol\";\nimport {IOutbox as ArbitrumL1_Outbox} from \"../../vendor/arbitrum/IOutbox.sol\";\nimport \"../errors.sol\";\n\n/**\n * @dev Primitives for cross-chain aware contracts for\n * https://arbitrum.io/[Arbitrum].\n *\n * This version should only be used on L1 to process cross-chain messages\n * originating from L2. For the other side, use {LibArbitrumL2}.\n */\nlibrary LibArbitrumL1 {\n    /**\n     * @dev Returns whether the current function call is the result of a\n     * cross-chain message relayed by the `bridge`.\n     */\n    function isCrossChain(address bridge) internal view returns (bool) {\n        return msg.sender == bridge;\n    }\n\n    /**\n     * @dev Returns the address of the sender that triggered the current\n     * cross-chain message through the `bridge`.\n     *\n     * NOTE: {isCrossChain} should be checked before trying to recover the\n     * sender, as it will revert with `NotCrossChainCall` if the current\n     * function call is not the result of a cross-chain message.\n     */\n    function crossChainSender(address bridge) internal view returns (address) {\n        if (!isCrossChain(bridge)) revert NotCrossChainCall();\n\n        address sender = ArbitrumL1_Outbox(ArbitrumL1_Bridge(bridge).activeOutbox()).l2ToL1Sender();\n        require(sender != address(0), \"LibArbitrumL1: system messages without sender\");\n\n        return sender;\n    }\n}\n","imports":["vendor/arbitrum/IInbox.sol","crosschain/errors.sol","vendor/arbitrum/IOutbox.sol","vendor/arbitrum/IBridge.sol"],"references":["crosschain/arbitrum/CrossChainEnabledArbitrumL1.sol"],"urls":[]},"crosschain/arbitrum/LibArbitrumL2.sol":{"checksum":{"algorithm":"md5","hash":"0x26ab1cfd3911910184b0a631df9dfadd"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (crosschain/arbitrum/LibArbitrumL2.sol)\n\npragma solidity ^0.8.4;\n\nimport {IArbSys as ArbitrumL2_Bridge} from \"../../vendor/arbitrum/IArbSys.sol\";\nimport \"../errors.sol\";\n\n/**\n * @dev Primitives for cross-chain aware contracts for\n * https://arbitrum.io/[Arbitrum].\n *\n * This version should only be used on L2 to process cross-chain messages\n * originating from L1. For the other side, use {LibArbitrumL1}.\n */\nlibrary LibArbitrumL2 {\n    /**\n     * @dev Returns whether the current function call is the result of a\n     * cross-chain message relayed by `arbsys`.\n     */\n    address public constant ARBSYS = 0x0000000000000000000000000000000000000064;\n\n    function isCrossChain(address arbsys) internal view returns (bool) {\n        return ArbitrumL2_Bridge(arbsys).isTopLevelCall();\n    }\n\n    /**\n     * @dev Returns the address of the sender that triggered the current\n     * cross-chain message through `arbsys`.\n     *\n     * NOTE: {isCrossChain} should be checked before trying to recover the\n     * sender, as it will revert with `NotCrossChainCall` if the current\n     * function call is not the result of a cross-chain message.\n     */\n    function crossChainSender(address arbsys) internal view returns (address) {\n        if (!isCrossChain(arbsys)) revert NotCrossChainCall();\n\n        return\n            ArbitrumL2_Bridge(arbsys).wasMyCallersAddressAliased()\n                ? ArbitrumL2_Bridge(arbsys).myCallersAddressWithoutAliasing()\n                : msg.sender;\n    }\n}\n","imports":["vendor/arbitrum/IArbSys.sol","crosschain/errors.sol"],"references":["crosschain/arbitrum/CrossChainEnabledArbitrumL2.sol"],"urls":[]},"crosschain/errors.sol":{"checksum":{"algorithm":"md5","hash":"0x6f0eb1ce3507339f0dbcee101521876b"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (crosschain/errors.sol)\n\npragma solidity ^0.8.4;\n\nerror NotCrossChainCall();\nerror InvalidCrossChainSender(address actual, address expected);\n","imports":[],"references":["crosschain/CrossChainEnabled.sol","crosschain/amb/LibAMB.sol","crosschain/arbitrum/LibArbitrumL2.sol","crosschain/arbitrum/LibArbitrumL1.sol","crosschain/optimism/LibOptimism.sol"],"urls":[]},"crosschain/optimism/CrossChainEnabledOptimism.sol":{"checksum":{"algorithm":"md5","hash":"0x6478343193f1b1bddc3a4f7d061ecbfc"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (crosschain/optimism/CrossChainEnabledOptimism.sol)\n\npragma solidity ^0.8.4;\n\nimport \"../CrossChainEnabled.sol\";\nimport \"./LibOptimism.sol\";\n\n/**\n * @dev https://www.optimism.io/[Optimism] specialization or the\n * {CrossChainEnabled} abstraction.\n *\n * The messenger (`CrossDomainMessenger`) contract is provided and maintained by\n * the optimism team. You can find the address of this contract on mainnet and\n * kovan in the https://github.com/ethereum-optimism/optimism/tree/develop/packages/contracts/deployments[deployments section of Optimism monorepo].\n *\n * _Available since v4.6._\n */\nabstract contract CrossChainEnabledOptimism is CrossChainEnabled {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _messenger;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address messenger) {\n        _messenger = messenger;\n    }\n\n    /**\n     * @dev see {CrossChainEnabled-_isCrossChain}\n     */\n    function _isCrossChain() internal view virtual override returns (bool) {\n        return LibOptimism.isCrossChain(_messenger);\n    }\n\n    /**\n     * @dev see {CrossChainEnabled-_crossChainSender}\n     */\n    function _crossChainSender() internal view virtual override onlyCrossChain returns (address) {\n        return LibOptimism.crossChainSender(_messenger);\n    }\n}\n","imports":["crosschain/CrossChainEnabled.sol","crosschain/optimism/LibOptimism.sol"],"references":["mocks/crosschain/receivers.sol"],"urls":[]},"crosschain/optimism/LibOptimism.sol":{"checksum":{"algorithm":"md5","hash":"0x51b8c43c05c0f147ca8c76a8555d932a"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (crosschain/optimism/LibOptimism.sol)\n\npragma solidity ^0.8.4;\n\nimport {ICrossDomainMessenger as Optimism_Bridge} from \"../../vendor/optimism/ICrossDomainMessenger.sol\";\nimport \"../errors.sol\";\n\n/**\n * @dev Primitives for cross-chain aware contracts for https://www.optimism.io/[Optimism].\n * See the https://community.optimism.io/docs/developers/bridge/messaging/#accessing-msg-sender[documentation]\n * for the functionality used here.\n */\nlibrary LibOptimism {\n    /**\n     * @dev Returns whether the current function call is the result of a\n     * cross-chain message relayed by `messenger`.\n     */\n    function isCrossChain(address messenger) internal view returns (bool) {\n        return msg.sender == messenger;\n    }\n\n    /**\n     * @dev Returns the address of the sender that triggered the current\n     * cross-chain message through `messenger`.\n     *\n     * NOTE: {isCrossChain} should be checked before trying to recover the\n     * sender, as it will revert with `NotCrossChainCall` if the current\n     * function call is not the result of a cross-chain message.\n     */\n    function crossChainSender(address messenger) internal view returns (address) {\n        if (!isCrossChain(messenger)) revert NotCrossChainCall();\n\n        return Optimism_Bridge(messenger).xDomainMessageSender();\n    }\n}\n","imports":["vendor/optimism/ICrossDomainMessenger.sol","crosschain/errors.sol"],"references":["crosschain/optimism/CrossChainEnabledOptimism.sol"],"urls":[]},"crosschain/polygon/CrossChainEnabledPolygonChild.sol":{"checksum":{"algorithm":"md5","hash":"0xea5f6e994302dfb7b63a4464cb91df34"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (crosschain/polygon/CrossChainEnabledPolygonChild.sol)\n\npragma solidity ^0.8.4;\n\nimport \"../CrossChainEnabled.sol\";\nimport \"../../security/ReentrancyGuard.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../vendor/polygon/IFxMessageProcessor.sol\";\n\naddress constant DEFAULT_SENDER = 0x000000000000000000000000000000000000dEaD;\n\n/**\n * @dev https://polygon.technology/[Polygon] specialization or the\n * {CrossChainEnabled} abstraction the child side (polygon/mumbai).\n *\n * This version should only be deployed on child chain to process cross-chain\n * messages originating from the parent chain.\n *\n * The fxChild contract is provided and maintained by the polygon team. You can\n * find the address of this contract polygon and mumbai in\n * https://docs.polygon.technology/docs/develop/l1-l2-communication/fx-portal/#contract-addresses[Polygon's Fx-Portal documentation].\n *\n * _Available since v4.6._\n */\nabstract contract CrossChainEnabledPolygonChild is IFxMessageProcessor, CrossChainEnabled, ReentrancyGuard {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _fxChild;\n    address private _sender = DEFAULT_SENDER;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address fxChild) {\n        _fxChild = fxChild;\n    }\n\n    /**\n     * @dev see {CrossChainEnabled-_isCrossChain}\n     */\n    function _isCrossChain() internal view virtual override returns (bool) {\n        return msg.sender == _fxChild;\n    }\n\n    /**\n     * @dev see {CrossChainEnabled-_crossChainSender}\n     */\n    function _crossChainSender() internal view virtual override onlyCrossChain returns (address) {\n        return _sender;\n    }\n\n    /**\n     * @dev External entry point to receive and relay messages originating\n     * from the fxChild.\n     *\n     * Non-reentrancy is crucial to avoid a cross-chain call being able\n     * to impersonate anyone by just looping through this with user-defined\n     * arguments.\n     *\n     * Note: if _fxChild calls any other function that does a delegate-call,\n     * then security could be compromised.\n     */\n    function processMessageFromRoot(\n        uint256, /* stateId */\n        address rootMessageSender,\n        bytes calldata data\n    ) external override nonReentrant {\n        if (!_isCrossChain()) revert NotCrossChainCall();\n\n        _sender = rootMessageSender;\n        Address.functionDelegateCall(address(this), data, \"cross-chain execution failed\");\n        _sender = DEFAULT_SENDER;\n    }\n}\n","imports":["security/ReentrancyGuard.sol","crosschain/CrossChainEnabled.sol","vendor/polygon/IFxMessageProcessor.sol","utils/Address.sol"],"references":["mocks/crosschain/receivers.sol"],"urls":[]},"finance/PaymentSplitter.sol":{"checksum":{"algorithm":"md5","hash":"0x4303d2719c98f9ba1763d56bacbde16f"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (finance/PaymentSplitter.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/utils/SafeERC20.sol\";\nimport \"../utils/Address.sol\";\nimport \"../utils/Context.sol\";\n\n/**\n * @title PaymentSplitter\n * @dev This contract allows to split Ether payments among a group of accounts. The sender does not need to be aware\n * that the Ether will be split in this way, since it is handled transparently by the contract.\n *\n * The split can be in equal parts or in any other arbitrary proportion. The way this is specified is by assigning each\n * account to a number of shares. Of all the Ether that this contract receives, each account will then be able to claim\n * an amount proportional to the percentage of total shares they were assigned. The distribution of shares is set at the\n * time of contract deployment and can't be updated thereafter.\n *\n * `PaymentSplitter` follows a _pull payment_ model. This means that payments are not automatically forwarded to the\n * accounts but kept in this contract, and the actual transfer is triggered as a separate step by calling the {release}\n * function.\n *\n * NOTE: This contract assumes that ERC20 tokens will behave similarly to native tokens (Ether). Rebasing tokens, and\n * tokens that apply fees during transfers, are likely to not be supported as expected. If in doubt, we encourage you\n * to run tests before sending real value to this contract.\n */\ncontract PaymentSplitter is Context {\n    event PayeeAdded(address account, uint256 shares);\n    event PaymentReleased(address to, uint256 amount);\n    event ERC20PaymentReleased(IERC20 indexed token, address to, uint256 amount);\n    event PaymentReceived(address from, uint256 amount);\n\n    uint256 private _totalShares;\n    uint256 private _totalReleased;\n\n    mapping(address => uint256) private _shares;\n    mapping(address => uint256) private _released;\n    address[] private _payees;\n\n    mapping(IERC20 => uint256) private _erc20TotalReleased;\n    mapping(IERC20 => mapping(address => uint256)) private _erc20Released;\n\n    /**\n     * @dev Creates an instance of `PaymentSplitter` where each account in `payees` is assigned the number of shares at\n     * the matching position in the `shares` array.\n     *\n     * All addresses in `payees` must be non-zero. Both arrays must have the same non-zero length, and there must be no\n     * duplicates in `payees`.\n     */\n    constructor(address[] memory payees, uint256[] memory shares_) payable {\n        require(payees.length == shares_.length, \"PaymentSplitter: payees and shares length mismatch\");\n        require(payees.length > 0, \"PaymentSplitter: no payees\");\n\n        for (uint256 i = 0; i < payees.length; i++) {\n            _addPayee(payees[i], shares_[i]);\n        }\n    }\n\n    /**\n     * @dev The Ether received will be logged with {PaymentReceived} events. Note that these events are not fully\n     * reliable: it's possible for a contract to receive Ether without triggering this function. This only affects the\n     * reliability of the events, and not the actual splitting of Ether.\n     *\n     * To learn more about this see the Solidity documentation for\n     * https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function[fallback\n     * functions].\n     */\n    receive() external payable virtual {\n        emit PaymentReceived(_msgSender(), msg.value);\n    }\n\n    /**\n     * @dev Getter for the total shares held by payees.\n     */\n    function totalShares() public view returns (uint256) {\n        return _totalShares;\n    }\n\n    /**\n     * @dev Getter for the total amount of Ether already released.\n     */\n    function totalReleased() public view returns (uint256) {\n        return _totalReleased;\n    }\n\n    /**\n     * @dev Getter for the total amount of `token` already released. `token` should be the address of an IERC20\n     * contract.\n     */\n    function totalReleased(IERC20 token) public view returns (uint256) {\n        return _erc20TotalReleased[token];\n    }\n\n    /**\n     * @dev Getter for the amount of shares held by an account.\n     */\n    function shares(address account) public view returns (uint256) {\n        return _shares[account];\n    }\n\n    /**\n     * @dev Getter for the amount of Ether already released to a payee.\n     */\n    function released(address account) public view returns (uint256) {\n        return _released[account];\n    }\n\n    /**\n     * @dev Getter for the amount of `token` tokens already released to a payee. `token` should be the address of an\n     * IERC20 contract.\n     */\n    function released(IERC20 token, address account) public view returns (uint256) {\n        return _erc20Released[token][account];\n    }\n\n    /**\n     * @dev Getter for the address of the payee number `index`.\n     */\n    function payee(uint256 index) public view returns (address) {\n        return _payees[index];\n    }\n\n    /**\n     * @dev Getter for the amount of payee's releasable Ether.\n     */\n    function releasable(address account) public view returns (uint256) {\n        uint256 totalReceived = address(this).balance + totalReleased();\n        return _pendingPayment(account, totalReceived, released(account));\n    }\n\n    /**\n     * @dev Getter for the amount of payee's releasable `token` tokens. `token` should be the address of an\n     * IERC20 contract.\n     */\n    function releasable(IERC20 token, address account) public view returns (uint256) {\n        uint256 totalReceived = token.balanceOf(address(this)) + totalReleased(token);\n        return _pendingPayment(account, totalReceived, released(token, account));\n    }\n\n    /**\n     * @dev Triggers a transfer to `account` of the amount of Ether they are owed, according to their percentage of the\n     * total shares and their previous withdrawals.\n     */\n    function release(address payable account) public virtual {\n        require(_shares[account] > 0, \"PaymentSplitter: account has no shares\");\n\n        uint256 payment = releasable(account);\n\n        require(payment != 0, \"PaymentSplitter: account is not due payment\");\n\n        _released[account] += payment;\n        _totalReleased += payment;\n\n        Address.sendValue(account, payment);\n        emit PaymentReleased(account, payment);\n    }\n\n    /**\n     * @dev Triggers a transfer to `account` of the amount of `token` tokens they are owed, according to their\n     * percentage of the total shares and their previous withdrawals. `token` must be the address of an IERC20\n     * contract.\n     */\n    function release(IERC20 token, address account) public virtual {\n        require(_shares[account] > 0, \"PaymentSplitter: account has no shares\");\n\n        uint256 payment = releasable(token, account);\n\n        require(payment != 0, \"PaymentSplitter: account is not due payment\");\n\n        _erc20Released[token][account] += payment;\n        _erc20TotalReleased[token] += payment;\n\n        SafeERC20.safeTransfer(token, account, payment);\n        emit ERC20PaymentReleased(token, account, payment);\n    }\n\n    /**\n     * @dev internal logic for computing the pending payment of an `account` given the token historical balances and\n     * already released amounts.\n     */\n    function _pendingPayment(\n        address account,\n        uint256 totalReceived,\n        uint256 alreadyReleased\n    ) private view returns (uint256) {\n        return (totalReceived * _shares[account]) / _totalShares - alreadyReleased;\n    }\n\n    /**\n     * @dev Add a new payee to the contract.\n     * @param account The address of the payee to add.\n     * @param shares_ The number of shares owned by the payee.\n     */\n    function _addPayee(address account, uint256 shares_) private {\n        require(account != address(0), \"PaymentSplitter: account is the zero address\");\n        require(shares_ > 0, \"PaymentSplitter: shares are 0\");\n        require(_shares[account] == 0, \"PaymentSplitter: account already has shares\");\n\n        _payees.push(account);\n        _shares[account] = shares_;\n        _totalShares = _totalShares + shares_;\n        emit PayeeAdded(account, shares_);\n    }\n}\n","imports":["token/ERC20/utils/SafeERC20.sol","utils/Address.sol","utils/Context.sol"],"references":[],"urls":[]},"finance/README.adoc":{"checksum":{"algorithm":"md5","hash":"0x653161fd393fea043c58e9279f84a6b5"},"content":"= Finance\n\n[.readme-notice]\nNOTE: This document is better viewed at https://docs.openzeppelin.com/contracts/api/finance\n\nThis directory includes primitives for financial systems:\n\n- {PaymentSplitter} allows to split Ether and ERC20 payments among a group of accounts. The sender does not need to be\n  aware that the assets will be split in this way, since it is handled transparently by the contract. The split can be\n  in equal parts or in any other arbitrary proportion.\n\n- {VestingWallet} handles the vesting of Ether and ERC20 tokens for a given beneficiary. Custody of multiple tokens can\n  be given to this contract, which will release the token to the beneficiary following a given, customizable, vesting\n  schedule.\n\n== Contracts\n\n{{PaymentSplitter}}\n\n{{VestingWallet}}\n","imports":[],"references":[],"urls":[]},"finance/VestingWallet.sol":{"checksum":{"algorithm":"md5","hash":"0x18528ffbe905b4b148ab73dcf8721070"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (finance/VestingWallet.sol)\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/utils/SafeERC20.sol\";\nimport \"../utils/Address.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/math/Math.sol\";\n\n/**\n * @title VestingWallet\n * @dev This contract handles the vesting of Eth and ERC20 tokens for a given beneficiary. Custody of multiple tokens\n * can be given to this contract, which will release the token to the beneficiary following a given vesting schedule.\n * The vesting schedule is customizable through the {vestedAmount} function.\n *\n * Any token transferred to this contract will follow the vesting schedule as if they were locked from the beginning.\n * Consequently, if the vesting has already started, any amount of tokens sent to this contract will (at least partly)\n * be immediately releasable.\n */\ncontract VestingWallet is Context {\n    event EtherReleased(uint256 amount);\n    event ERC20Released(address indexed token, uint256 amount);\n\n    uint256 private _released;\n    mapping(address => uint256) private _erc20Released;\n    address private immutable _beneficiary;\n    uint64 private immutable _start;\n    uint64 private immutable _duration;\n\n    /**\n     * @dev Set the beneficiary, start timestamp and vesting duration of the vesting wallet.\n     */\n    constructor(\n        address beneficiaryAddress,\n        uint64 startTimestamp,\n        uint64 durationSeconds\n    ) {\n        require(beneficiaryAddress != address(0), \"VestingWallet: beneficiary is zero address\");\n        _beneficiary = beneficiaryAddress;\n        _start = startTimestamp;\n        _duration = durationSeconds;\n    }\n\n    /**\n     * @dev The contract should be able to receive Eth.\n     */\n    receive() external payable virtual {}\n\n    /**\n     * @dev Getter for the beneficiary address.\n     */\n    function beneficiary() public view virtual returns (address) {\n        return _beneficiary;\n    }\n\n    /**\n     * @dev Getter for the start timestamp.\n     */\n    function start() public view virtual returns (uint256) {\n        return _start;\n    }\n\n    /**\n     * @dev Getter for the vesting duration.\n     */\n    function duration() public view virtual returns (uint256) {\n        return _duration;\n    }\n\n    /**\n     * @dev Amount of eth already released\n     */\n    function released() public view virtual returns (uint256) {\n        return _released;\n    }\n\n    /**\n     * @dev Amount of token already released\n     */\n    function released(address token) public view virtual returns (uint256) {\n        return _erc20Released[token];\n    }\n\n    /**\n     * @dev Release the native token (ether) that have already vested.\n     *\n     * Emits a {EtherReleased} event.\n     */\n    function release() public virtual {\n        uint256 releasable = vestedAmount(uint64(block.timestamp)) - released();\n        _released += releasable;\n        emit EtherReleased(releasable);\n        Address.sendValue(payable(beneficiary()), releasable);\n    }\n\n    /**\n     * @dev Release the tokens that have already vested.\n     *\n     * Emits a {ERC20Released} event.\n     */\n    function release(address token) public virtual {\n        uint256 releasable = vestedAmount(token, uint64(block.timestamp)) - released(token);\n        _erc20Released[token] += releasable;\n        emit ERC20Released(token, releasable);\n        SafeERC20.safeTransfer(IERC20(token), beneficiary(), releasable);\n    }\n\n    /**\n     * @dev Calculates the amount of ether that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(uint64 timestamp) public view virtual returns (uint256) {\n        return _vestingSchedule(address(this).balance + released(), timestamp);\n    }\n\n    /**\n     * @dev Calculates the amount of tokens that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(address token, uint64 timestamp) public view virtual returns (uint256) {\n        return _vestingSchedule(IERC20(token).balanceOf(address(this)) + released(token), timestamp);\n    }\n\n    /**\n     * @dev Virtual implementation of the vesting formula. This returns the amount vested, as a function of time, for\n     * an asset given its total historical allocation.\n     */\n    function _vestingSchedule(uint256 totalAllocation, uint64 timestamp) internal view virtual returns (uint256) {\n        if (timestamp < start()) {\n            return 0;\n        } else if (timestamp > start() + duration()) {\n            return totalAllocation;\n        } else {\n            return (totalAllocation * (timestamp - start())) / duration();\n        }\n    }\n}\n","imports":["utils/math/Math.sol","token/ERC20/utils/SafeERC20.sol","utils/Address.sol","utils/Context.sol"],"references":[],"urls":[]},"governance/Governor.sol":{"checksum":{"algorithm":"md5","hash":"0x2d0eefb22e4ea5913516d5f61d01f1c5"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (governance/Governor.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721Receiver.sol\";\nimport \"../token/ERC1155/IERC1155Receiver.sol\";\nimport \"../utils/cryptography/ECDSA.sol\";\nimport \"../utils/cryptography/draft-EIP712.sol\";\nimport \"../utils/introspection/ERC165.sol\";\nimport \"../utils/math/SafeCast.sol\";\nimport \"../utils/structs/DoubleEndedQueue.sol\";\nimport \"../utils/Address.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Timers.sol\";\nimport \"./IGovernor.sol\";\n\n/**\n * @dev Core of the governance system, designed to be extended though various modules.\n *\n * This contract is abstract and requires several function to be implemented in various modules:\n *\n * - A counting module must implement {quorum}, {_quorumReached}, {_voteSucceeded} and {_countVote}\n * - A voting module must implement {_getVotes}\n * - Additionanly, the {votingPeriod} must also be implemented\n *\n * _Available since v4.3._\n */\nabstract contract Governor is Context, ERC165, EIP712, IGovernor, IERC721Receiver, IERC1155Receiver {\n    using DoubleEndedQueue for DoubleEndedQueue.Bytes32Deque;\n    using SafeCast for uint256;\n    using Timers for Timers.BlockNumber;\n\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support)\");\n    bytes32 public constant EXTENDED_BALLOT_TYPEHASH =\n        keccak256(\"ExtendedBallot(uint256 proposalId,uint8 support,string reason,bytes params)\");\n\n    struct ProposalCore {\n        Timers.BlockNumber voteStart;\n        Timers.BlockNumber voteEnd;\n        bool executed;\n        bool canceled;\n    }\n\n    string private _name;\n\n    mapping(uint256 => ProposalCore) private _proposals;\n\n    // This queue keeps track of the governor operating on itself. Calls to functions protected by the\n    // {onlyGovernance} modifier needs to be whitelisted in this queue. Whitelisting is set in {_beforeExecute},\n    // consumed by the {onlyGovernance} modifier and eventually reset in {_afterExecute}. This ensures that the\n    // execution of {onlyGovernance} protected calls can only be achieved through successful proposals.\n    DoubleEndedQueue.Bytes32Deque private _governanceCall;\n\n    /**\n     * @dev Restricts a function so it can only be executed through governance proposals. For example, governance\n     * parameter setters in {GovernorSettings} are protected using this modifier.\n     *\n     * The governance executing address may be different from the Governor's own address, for example it could be a\n     * timelock. This can be customized by modules by overriding {_executor}. The executor is only able to invoke these\n     * functions during the execution of the governor's {execute} function, and not under any other circumstances. Thus,\n     * for example, additional timelock proposers are not able to change governance parameters without going through the\n     * governance protocol (since v4.6).\n     */\n    modifier onlyGovernance() {\n        require(_msgSender() == _executor(), \"Governor: onlyGovernance\");\n        if (_executor() != address(this)) {\n            bytes32 msgDataHash = keccak256(_msgData());\n            // loop until popping the expected operation - throw if deque is empty (operation not authorized)\n            while (_governanceCall.popFront() != msgDataHash) {}\n        }\n        _;\n    }\n\n    /**\n     * @dev Sets the value for {name} and {version}\n     */\n    constructor(string memory name_) EIP712(name_, version()) {\n        _name = name_;\n    }\n\n    /**\n     * @dev Function to receive ETH that will be handled by the governor (disabled if executor is a third party contract)\n     */\n    receive() external payable virtual {\n        require(_executor() == address(this));\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\n        // In addition to the current interfaceId, also support previous version of the interfaceId that did not\n        // include the castVoteWithReasonAndParams() function as standard\n        return\n            interfaceId ==\n            (type(IGovernor).interfaceId ^\n                this.castVoteWithReasonAndParams.selector ^\n                this.castVoteWithReasonAndParamsBySig.selector ^\n                this.getVotesWithParams.selector) ||\n            interfaceId == type(IGovernor).interfaceId ||\n            interfaceId == type(IERC1155Receiver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IGovernor-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IGovernor-version}.\n     */\n    function version() public view virtual override returns (string memory) {\n        return \"1\";\n    }\n\n    /**\n     * @dev See {IGovernor-hashProposal}.\n     *\n     * The proposal id is produced by hashing the RLC encoded `targets` array, the `values` array, the `calldatas` array\n     * and the descriptionHash (bytes32 which itself is the keccak256 hash of the description string). This proposal id\n     * can be produced from the proposal data which is part of the {ProposalCreated} event. It can even be computed in\n     * advance, before the proposal is submitted.\n     *\n     * Note that the chainId and the governor address are not part of the proposal id computation. Consequently, the\n     * same proposal (with same operation and same description) will have the same id if submitted on multiple governors\n     * across multiple networks. This also means that in order to execute the same operation twice (on the same\n     * governor) the proposer will have to change the description in order to avoid proposal id conflicts.\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual override returns (uint256) {\n        return uint256(keccak256(abi.encode(targets, values, calldatas, descriptionHash)));\n    }\n\n    /**\n     * @dev See {IGovernor-state}.\n     */\n    function state(uint256 proposalId) public view virtual override returns (ProposalState) {\n        ProposalCore storage proposal = _proposals[proposalId];\n\n        if (proposal.executed) {\n            return ProposalState.Executed;\n        }\n\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        }\n\n        uint256 snapshot = proposalSnapshot(proposalId);\n\n        if (snapshot == 0) {\n            revert(\"Governor: unknown proposal id\");\n        }\n\n        if (snapshot >= block.number) {\n            return ProposalState.Pending;\n        }\n\n        uint256 deadline = proposalDeadline(proposalId);\n\n        if (deadline >= block.number) {\n            return ProposalState.Active;\n        }\n\n        if (_quorumReached(proposalId) && _voteSucceeded(proposalId)) {\n            return ProposalState.Succeeded;\n        } else {\n            return ProposalState.Defeated;\n        }\n    }\n\n    /**\n     * @dev See {IGovernor-proposalSnapshot}.\n     */\n    function proposalSnapshot(uint256 proposalId) public view virtual override returns (uint256) {\n        return _proposals[proposalId].voteStart.getDeadline();\n    }\n\n    /**\n     * @dev See {IGovernor-proposalDeadline}.\n     */\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return _proposals[proposalId].voteEnd.getDeadline();\n    }\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"The number of votes required in order for a voter to become a proposer\"_.\n     */\n    function proposalThreshold() public view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev Amount of votes already cast passes the threshold limit.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Is the proposal successful or not.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Get the voting weight of `account` at a specific `blockNumber`, for a vote as described by `params`.\n     */\n    function _getVotes(\n        address account,\n        uint256 blockNumber,\n        bytes memory params\n    ) internal view virtual returns (uint256);\n\n    /**\n     * @dev Register a vote for `proposalId` by `account` with a given `support`, voting `weight` and voting `params`.\n     *\n     * Note: Support is generic and can represent various things depending on the voting system used.\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory params\n    ) internal virtual;\n\n    /**\n     * @dev Default additional encoded parameters used by castVote methods that don't include them\n     *\n     * Note: Should be overridden by specific implementations to use an appropriate value, the\n     * meaning of the additional params, in the context of that implementation\n     */\n    function _defaultParams() internal view virtual returns (bytes memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IGovernor-propose}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override returns (uint256) {\n        require(\n            getVotes(_msgSender(), block.number - 1) >= proposalThreshold(),\n            \"Governor: proposer votes below proposal threshold\"\n        );\n\n        uint256 proposalId = hashProposal(targets, values, calldatas, keccak256(bytes(description)));\n\n        require(targets.length == values.length, \"Governor: invalid proposal length\");\n        require(targets.length == calldatas.length, \"Governor: invalid proposal length\");\n        require(targets.length > 0, \"Governor: empty proposal\");\n\n        ProposalCore storage proposal = _proposals[proposalId];\n        require(proposal.voteStart.isUnset(), \"Governor: proposal already exists\");\n\n        uint64 snapshot = block.number.toUint64() + votingDelay().toUint64();\n        uint64 deadline = snapshot + votingPeriod().toUint64();\n\n        proposal.voteStart.setDeadline(snapshot);\n        proposal.voteEnd.setDeadline(deadline);\n\n        emit ProposalCreated(\n            proposalId,\n            _msgSender(),\n            targets,\n            values,\n            new string[](targets.length),\n            calldatas,\n            snapshot,\n            deadline,\n            description\n        );\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-execute}.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        ProposalState status = state(proposalId);\n        require(\n            status == ProposalState.Succeeded || status == ProposalState.Queued,\n            \"Governor: proposal not successful\"\n        );\n        _proposals[proposalId].executed = true;\n\n        emit ProposalExecuted(proposalId);\n\n        _beforeExecute(proposalId, targets, values, calldatas, descriptionHash);\n        _execute(proposalId, targets, values, calldatas, descriptionHash);\n        _afterExecute(proposalId, targets, values, calldatas, descriptionHash);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Internal execution mechanism. Can be overridden to implement different execution mechanism\n     */\n    function _execute(\n        uint256, /* proposalId */\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        string memory errorMessage = \"Governor: call reverted without message\";\n        for (uint256 i = 0; i < targets.length; ++i) {\n            (bool success, bytes memory returndata) = targets[i].call{value: values[i]}(calldatas[i]);\n            Address.verifyCallResult(success, returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Hook before execution is triggered.\n     */\n    function _beforeExecute(\n        uint256, /* proposalId */\n        address[] memory targets,\n        uint256[] memory, /* values */\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        if (_executor() != address(this)) {\n            for (uint256 i = 0; i < targets.length; ++i) {\n                if (targets[i] == address(this)) {\n                    _governanceCall.pushBack(keccak256(calldatas[i]));\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Hook after execution is triggered.\n     */\n    function _afterExecute(\n        uint256, /* proposalId */\n        address[] memory, /* targets */\n        uint256[] memory, /* values */\n        bytes[] memory, /* calldatas */\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        if (_executor() != address(this)) {\n            if (!_governanceCall.empty()) {\n                _governanceCall.clear();\n            }\n        }\n    }\n\n    /**\n     * @dev Internal cancel mechanism: locks up the proposal timer, preventing it from being re-submitted. Marks it as\n     * canceled to allow distinguishing it from executed proposals.\n     *\n     * Emits a {IGovernor-ProposalCanceled} event.\n     */\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n        ProposalState status = state(proposalId);\n\n        require(\n            status != ProposalState.Canceled && status != ProposalState.Expired && status != ProposalState.Executed,\n            \"Governor: proposal not active\"\n        );\n        _proposals[proposalId].canceled = true;\n\n        emit ProposalCanceled(proposalId);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-getVotes}.\n     */\n    function getVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {\n        return _getVotes(account, blockNumber, _defaultParams());\n    }\n\n    /**\n     * @dev See {IGovernor-getVotesWithParams}.\n     */\n    function getVotesWithParams(\n        address account,\n        uint256 blockNumber,\n        bytes memory params\n    ) public view virtual override returns (uint256) {\n        return _getVotes(account, blockNumber, params);\n    }\n\n    /**\n     * @dev See {IGovernor-castVote}.\n     */\n    function castVote(uint256 proposalId, uint8 support) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReason}.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, reason);\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReasonAndParams}.\n     */\n    function castVoteWithReasonAndParams(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params\n    ) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, reason, params);\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteBySig}.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override returns (uint256) {\n        address voter = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\n            v,\n            r,\n            s\n        );\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReasonAndParamsBySig}.\n     */\n    function castVoteWithReasonAndParamsBySig(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override returns (uint256) {\n        address voter = ECDSA.recover(\n            _hashTypedDataV4(\n                keccak256(\n                    abi.encode(\n                        EXTENDED_BALLOT_TYPEHASH,\n                        proposalId,\n                        support,\n                        keccak256(bytes(reason)),\n                        keccak256(params)\n                    )\n                )\n            ),\n            v,\n            r,\n            s\n        );\n\n        return _castVote(proposalId, voter, support, reason, params);\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function. Uses the _defaultParams().\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason\n    ) internal virtual returns (uint256) {\n        return _castVote(proposalId, account, support, reason, _defaultParams());\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function.\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual returns (uint256) {\n        ProposalCore storage proposal = _proposals[proposalId];\n        require(state(proposalId) == ProposalState.Active, \"Governor: vote not currently active\");\n\n        uint256 weight = _getVotes(account, proposal.voteStart.getDeadline(), params);\n        _countVote(proposalId, account, support, weight, params);\n\n        if (params.length == 0) {\n            emit VoteCast(account, proposalId, support, weight, reason);\n        } else {\n            emit VoteCastWithParams(account, proposalId, support, weight, reason, params);\n        }\n\n        return weight;\n    }\n\n    /**\n     * @dev Relays a transaction or function call to an arbitrary target. In cases where the governance executor\n     * is some contract other than the governor itself, like when using a timelock, this function can be invoked\n     * in a governance proposal to recover tokens or Ether that was sent to the governor contract by mistake.\n     * Note that if the executor is simply the governor itself, use of `relay` is redundant.\n     */\n    function relay(\n        address target,\n        uint256 value,\n        bytes calldata data\n    ) external virtual onlyGovernance {\n        Address.functionCallWithValue(target, data, value);\n    }\n\n    /**\n     * @dev Address through which the governor executes action. Will be overloaded by module that execute actions\n     * through another contract such as a timelock.\n     */\n    function _executor() internal view virtual returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155Received}.\n     */\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n","imports":["utils/cryptography/ECDSA.sol","utils/cryptography/draft-EIP712.sol","governance/IGovernor.sol","utils/math/SafeCast.sol","token/ERC721/IERC721Receiver.sol","utils/structs/DoubleEndedQueue.sol","utils/introspection/ERC165.sol","utils/Address.sol","token/ERC1155/IERC1155Receiver.sol","utils/Timers.sol","utils/Context.sol"],"references":["mocks/wizard/MyGovernor2.sol","governance/extensions/GovernorProposalThreshold.sol","mocks/wizard/MyGovernor1.sol","governance/extensions/GovernorVotesComp.sol","governance/extensions/GovernorPreventLateQuorum.sol","mocks/wizard/MyGovernor3.sol","governance/extensions/GovernorSettings.sol","governance/compatibility/GovernorCompatibilityBravo.sol","governance/extensions/GovernorTimelockCompound.sol","governance/extensions/GovernorTimelockControl.sol","governance/extensions/GovernorVotes.sol","governance/extensions/GovernorCountingSimple.sol"],"urls":[]},"governance/IGovernor.sol":{"checksum":{"algorithm":"md5","hash":"0xc16dcc051616ec47196c71b9589b9ca4"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (governance/IGovernor.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Interface of the {Governor} core.\n *\n * _Available since v4.3._\n */\nabstract contract IGovernor is IERC165 {\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    /**\n     * @dev Emitted when a proposal is created.\n     */\n    event ProposalCreated(\n        uint256 proposalId,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock,\n        string description\n    );\n\n    /**\n     * @dev Emitted when a proposal is canceled.\n     */\n    event ProposalCanceled(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a proposal is executed.\n     */\n    event ProposalExecuted(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a vote is cast without params.\n     *\n     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.\n     */\n    event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 weight, string reason);\n\n    /**\n     * @dev Emitted when a vote is cast with params.\n     *\n     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.\n     * `params` are additional encoded parameters. Their intepepretation also depends on the voting module used.\n     */\n    event VoteCastWithParams(\n        address indexed voter,\n        uint256 proposalId,\n        uint8 support,\n        uint256 weight,\n        string reason,\n        bytes params\n    );\n\n    /**\n     * @notice module:core\n     * @dev Name of the governor instance (used in building the ERC712 domain separator).\n     */\n    function name() public view virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Version of the governor instance (used in building the ERC712 domain separator). Default: \"1\"\n     */\n    function version() public view virtual returns (string memory);\n\n    /**\n     * @notice module:voting\n     * @dev A description of the possible `support` values for {castVote} and the way these votes are counted, meant to\n     * be consumed by UIs to show correct vote options and interpret the results. The string is a URL-encoded sequence of\n     * key-value pairs that each describe one aspect, for example `support=bravo&quorum=for,abstain`.\n     *\n     * There are 2 standard keys: `support` and `quorum`.\n     *\n     * - `support=bravo` refers to the vote options 0 = Against, 1 = For, 2 = Abstain, as in `GovernorBravo`.\n     * - `quorum=bravo` means that only For votes are counted towards quorum.\n     * - `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.\n     *\n     * If a counting module makes use of encoded `params`, it should  include this under a `params` key with a unique\n     * name that describes the behavior. For example:\n     *\n     * - `params=fractional` might refer to a scheme where votes are divided fractionally between for/against/abstain.\n     * - `params=erc721` might refer to a scheme where specific NFTs are delegated to vote.\n     *\n     * NOTE: The string can be decoded by the standard\n     * https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams[`URLSearchParams`]\n     * JavaScript class.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Hashing function used to (re)build the proposal id from the proposal details..\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Current state of a proposal, following Compound's convention\n     */\n    function state(uint256 proposalId) public view virtual returns (ProposalState);\n\n    /**\n     * @notice module:core\n     * @dev Block number used to retrieve user's votes and quorum. As per Compound's Comp and OpenZeppelin's\n     * ERC20Votes, the snapshot is performed at the end of this block. Hence, voting for this proposal starts at the\n     * beginning of the following block.\n     */\n    function proposalSnapshot(uint256 proposalId) public view virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Block number at which votes close. Votes close at the end of this block, so it is possible to cast a vote\n     * during this block.\n     */\n    function proposalDeadline(uint256 proposalId) public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay, in number of block, between the proposal is created and the vote starts. This can be increassed to\n     * leave time for users to buy voting power, of delegate it, before the voting of a proposal starts.\n     */\n    function votingDelay() public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay, in number of blocks, between the vote start and vote ends.\n     *\n     * NOTE: The {votingDelay} can delay the start of the vote. This must be considered when setting the voting\n     * duration compared to the voting delay.\n     */\n    function votingPeriod() public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Minimum number of cast voted required for a proposal to be successful.\n     *\n     * Note: The `blockNumber` parameter corresponds to the snapshot used for counting vote. This allows to scale the\n     * quorum depending on values such as the totalSupply of a token at this block (see {ERC20Votes}).\n     */\n    function quorum(uint256 blockNumber) public view virtual returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `account` at a specific `blockNumber`.\n     *\n     * Note: this can be implemented in a number of ways, for example by reading the delegated balance from one (or\n     * multiple), {ERC20Votes} tokens.\n     */\n    function getVotes(address account, uint256 blockNumber) public view virtual returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `account` at a specific `blockNumber` given additional encoded parameters.\n     */\n    function getVotesWithParams(\n        address account,\n        uint256 blockNumber,\n        bytes memory params\n    ) public view virtual returns (uint256);\n\n    /**\n     * @notice module:voting\n     * @dev Returns weither `account` has cast a vote on `proposalId`.\n     */\n    function hasVoted(uint256 proposalId, address account) public view virtual returns (bool);\n\n    /**\n     * @dev Create a new proposal. Vote start {IGovernor-votingDelay} blocks after the proposal is created and ends\n     * {IGovernor-votingPeriod} blocks after the voting starts.\n     *\n     * Emits a {ProposalCreated} event.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Execute a successful proposal. This requires the quorum to be reached, the vote to be successful, and the\n     * deadline to be reached.\n     *\n     * Emits a {ProposalExecuted} event.\n     *\n     * Note: some module can modify the requirements for execution, for example by adding an additional timelock.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Cast a vote\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVote(uint256 proposalId, uint8 support) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason and additional encoded parameters\n     *\n     * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.\n     */\n    function castVoteWithReasonAndParams(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote using the user's cryptographic signature.\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason and additional encoded parameters using the user's cryptographic signature.\n     *\n     * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.\n     */\n    function castVoteWithReasonAndParamsBySig(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual returns (uint256 balance);\n}\n","imports":["utils/introspection/ERC165.sol"],"references":["governance/extensions/IGovernorTimelock.sol","governance/compatibility/IGovernorCompatibilityBravo.sol","governance/Governor.sol"],"urls":[]},"governance/README.adoc":{"checksum":{"algorithm":"md5","hash":"0xa5504199fc3a47b20b8f7d1e2283981c"},"content":"= Governance\n\n[.readme-notice]\nNOTE: This document is better viewed at https://docs.openzeppelin.com/contracts/api/governance\n\nThis directory includes primitives for on-chain governance.\n\n== Governor\n\nThis modular system of Governor contracts allows the deployment on-chain voting protocols similar to https://compound.finance/docs/governance[Compound's Governor Alpha & Bravo] and beyond, through the ability to easily customize multiple aspects of the protocol.\n\n[TIP]\n====\nFor a guided experience, set up your Governor contract using https://wizard.openzeppelin.com/#governor[Contracts Wizard].\n\nFor a written walkthrough, check out our guide on xref:ROOT:governance.adoc[How to set up on-chain governance].\n====\n\n* {Governor}: The core contract that contains all the logic and primitives. It is abstract and requires choosing one of each of the modules below, or custom ones.\n\nVotes modules determine the source of voting power, and sometimes quorum number.\n\n* {GovernorVotes}: Extracts voting weight from an {ERC20Votes} token.\n\n* {GovernorVotesComp}: Extracts voting weight from a COMP-like or {ERC20VotesComp} token.\n\n* {GovernorVotesQuorumFraction}: Combines with `GovernorVotes` to set the quorum as a fraction of the total token supply.\n\nCounting modules determine valid voting options.\n\n* {GovernorCountingSimple}: Simple voting mechanism with 3 voting options: Against, For and Abstain.\n\nTimelock extensions add a delay for governance decisions to be executed. The workflow is extended to require a `queue` step before execution. With these modules, proposals are executed by the external timelock contract, thus it is the timelock that has to hold the assets that are being governed.\n\n* {GovernorTimelockControl}: Connects with an instance of {TimelockController}. Allows multiple proposers and executors, in addition to the Governor itself.\n\n* {GovernorTimelockCompound}: Connects with an instance of Compound's https://github.com/compound-finance/compound-protocol/blob/master/contracts/Timelock.sol[`Timelock`] contract.\n\nOther extensions can customize the behavior or interface in multiple ways.\n\n* {GovernorCompatibilityBravo}: Extends the interface to be fully `GovernorBravo`-compatible. Note that events are compatible regardless of whether this extension is included or not.\n\n* {GovernorSettings}: Manages some of the settings (voting delay, voting period duration, and proposal threshold) in a way that can be updated through a governance proposal, without requiring an upgrade.\n\n* {GovernorPreventLateQuorum}: Ensures there is a minimum voting period after quorum is reached as a security protection against large voters.\n\nIn addition to modules and extensions, the core contract requires a few virtual functions to be implemented to your particular specifications:\n\n* <<Governor-votingDelay-,`votingDelay()`>>: Delay (in number of blocks) since the proposal is submitted until voting power is fixed and voting starts. This can be used to enforce a delay after a proposal is published for users to buy tokens, or delegate their votes.\n* <<Governor-votingPeriod-,`votingPeriod()`>>: Delay (in number of blocks) since the proposal starts until voting ends.\n* <<Governor-quorum-uint256-,`quorum(uint256 blockNumber)`>>: Quorum required for a proposal to be successful. This function includes a `blockNumber` argument so the quorum can adapt through time, for example, to follow a token's `totalSupply`.\n\nNOTE: Functions of the `Governor` contract do not include access control. If you want to restrict access, you should add these checks by overloading the particular functions. Among these, {Governor-_cancel} is internal by default, and you will have to expose it (with the right access control mechanism) yourself if this function is needed.\n\n=== Core\n\n{{IGovernor}}\n\n{{Governor}}\n\n=== Modules\n\n{{GovernorCountingSimple}}\n\n{{GovernorVotes}}\n\n{{GovernorVotesQuorumFraction}}\n\n{{GovernorVotesComp}}\n\n=== Extensions\n\n{{GovernorTimelockControl}}\n\n{{GovernorTimelockCompound}}\n\n{{GovernorSettings}}\n\n{{GovernorPreventLateQuorum}}\n\n{{GovernorCompatibilityBravo}}\n\n=== Deprecated\n\n{{GovernorProposalThreshold}}\n\n== Utils\n\n{{Votes}}\n\n== Timelock\n\nIn a governance system, the {TimelockController} contract is in charge of introducing a delay between a proposal and its execution. It can be used with or without a {Governor}.\n\n{{TimelockController}}\n\n[[timelock-terminology]]\n==== Terminology\n\n* *Operation:* A transaction (or a set of transactions) that is the subject of the timelock. It has to be scheduled by a proposer and executed by an executor. The timelock enforces a minimum delay between the proposition and the execution (see xref:access-control.adoc#operation_lifecycle[operation lifecycle]). If the operation contains multiple transactions (batch mode), they are executed atomically. Operations are identified by the hash of their content.\n* *Operation status:*\n** *Unset:* An operation that is not part of the timelock mechanism.\n** *Pending:* An operation that has been scheduled, before the timer expires.\n** *Ready:* An operation that has been scheduled, after the timer expires.\n** *Done:* An operation that has been executed.\n* *Predecessor*: An (optional) dependency between operations. An operation can depend on another operation (its predecessor), forcing the execution order of these two operations.\n* *Role*:\n** *Admin:* An address (smart contract or EOA) that is in charge of granting the roles of Proposer and Executor.\n** *Proposer:* An address (smart contract or EOA) that is in charge of scheduling (and cancelling) operations.\n** *Executor:* An address (smart contract or EOA) that is in charge of executing operations once the timelock has expired. This role can be given to the zero address to allow anyone to execute operations.\n\n[[timelock-operation]]\n==== Operation structure\n\nOperation executed by the xref:api:governance.adoc#TimelockController[`TimelockController`] can contain one or multiple subsequent calls. Depending on whether you need to multiple calls to be executed atomically, you can either use simple or batched operations.\n\nBoth operations contain:\n\n* *Target*, the address of the smart contract that the timelock should operate on.\n* *Value*, in wei, that should be sent with the transaction. Most of the time this will be 0. Ether can be deposited before-end or passed along when executing the transaction.\n* *Data*, containing the encoded function selector and parameters of the call. This can be produced using a number of tools. For example, a maintenance operation granting role `ROLE` to `ACCOUNT` can be encode using web3js as follows:\n\n```javascript\nconst data = timelock.contract.methods.grantRole(ROLE, ACCOUNT).encodeABI()\n```\n\n* *Predecessor*, that specifies a dependency between operations. This dependency is optional. Use `bytes32(0)` if the operation does not have any dependency.\n* *Salt*, used to disambiguate two otherwise identical operations. This can be any random value.\n\nIn the case of batched operations, `target`, `value` and `data` are specified as arrays, which must be of the same length.\n\n[[timelock-operation-lifecycle]]\n==== Operation lifecycle\n\nTimelocked operations are identified by a unique id (their hash) and follow a specific lifecycle:\n\n`Unset` -> `Pending` -> `Pending` + `Ready` -> `Done`\n\n* By calling xref:api:governance.adoc#TimelockController-schedule-address-uint256-bytes-bytes32-bytes32-uint256-[`schedule`] (or xref:api:governance.adoc#TimelockController-scheduleBatch-address---uint256---bytes---bytes32-bytes32-uint256-[`scheduleBatch`]), a proposer moves the operation from the `Unset` to the `Pending` state. This starts a timer that must be longer than the minimum delay. The timer expires at a timestamp accessible through the xref:api:governance.adoc#TimelockController-getTimestamp-bytes32-[`getTimestamp`] method.\n* Once the timer expires, the operation automatically gets the `Ready` state. At this point, it can be executed.\n* By calling xref:api:governance.adoc#TimelockController-TimelockController-execute-address-uint256-bytes-bytes32-bytes32-[`execute`] (or xref:api:governance.adoc#TimelockController-executeBatch-address---uint256---bytes---bytes32-bytes32-[`executeBatch`]), an executor triggers the operation's underlying transactions and moves it to the `Done` state. If the operation has a predecessor, it has to be in the `Done` state for this transition to succeed.\n* xref:api:governance.adoc#TimelockController-TimelockController-cancel-bytes32-[`cancel`] allows proposers to cancel any `Pending` operation. This resets the operation to the `Unset` state. It is thus possible for a proposer to re-schedule an operation that has been cancelled. In this case, the timer restarts when the operation is re-scheduled.\n\nOperations status can be queried using the functions:\n\n* xref:api:governance.adoc#TimelockController-isOperationPending-bytes32-[`isOperationPending(bytes32)`]\n* xref:api:governance.adoc#TimelockController-isOperationReady-bytes32-[`isOperationReady(bytes32)`]\n* xref:api:governance.adoc#TimelockController-isOperationDone-bytes32-[`isOperationDone(bytes32)`]\n\n[[timelock-roles]]\n==== Roles\n\n[[timelock-admin]]\n===== Admin\n\nThe admins are in charge of managing proposers and executors. For the timelock to be self-governed, this role should only be given to the timelock itself. Upon deployment, both the timelock and the deployer have this role. After further configuration and testing, the deployer can renounce this role such that all further maintenance operations have to go through the timelock process.\n\nThis role is identified by the *TIMELOCK_ADMIN_ROLE* value: `0x5f58e3a2316349923ce3780f8d587db2d72378aed66a8261c916544fa6846ca5`\n\n[[timelock-proposer]]\n===== Proposer\n\nThe proposers are in charge of scheduling (and cancelling) operations. This is a critical role, that should be given to governing entities. This could be an EOA, a multisig, or a DAO.\n\nWARNING: *Proposer fight:* Having multiple proposers, while providing redundancy in case one becomes unavailable, can be dangerous. As proposer have their say on all operations, they could cancel operations they disagree with, including operations to remove them for the proposers.\n\nThis role is identified by the *PROPOSER_ROLE* value: `0xb09aa5aeb3702cfd50b6b62bc4532604938f21248a27a1d5ca736082b6819cc1`\n\n[[timelock-executor]]\n===== Executor\n\nThe executors are in charge of executing the operations scheduled by the proposers once the timelock expires. Logic dictates that multisig or DAO that are proposers should also be executors in order to guarantee operations that have been scheduled will eventually be executed. However, having additional executors can reduce the cost (the executing transaction does not require validation by the multisig or DAO that proposed it), while ensuring whoever is in charge of execution cannot trigger actions that have not been scheduled by the proposers. Alternatively, it is possible to allow _any_ address to execute a proposal once the timelock has expired by granting the executor role to the zero address.\n\nThis role is identified by the *EXECUTOR_ROLE* value: `0xd8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e63`\n\nWARNING: A live contract without at least one proposer and one executor is locked. Make sure these roles are filled by reliable entities before the deployer renounces its administrative rights in favour of the timelock contract itself. See the {AccessControl} documentation to learn more about role management.\n","imports":[],"references":[],"urls":[]},"governance/TimelockController.sol":{"checksum":{"algorithm":"md5","hash":"0x4335526a8b113a9250ee1f2639cffff6"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (governance/TimelockController.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../access/AccessControl.sol\";\nimport \"../token/ERC721/IERC721Receiver.sol\";\nimport \"../token/ERC1155/IERC1155Receiver.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * _Available since v3.3._\n */\ncontract TimelockController is AccessControl, IERC721Receiver, IERC1155Receiver {\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELLER_ROLE = keccak256(\"CANCELLER_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    mapping(bytes32 => uint256) private _timestamps;\n    uint256 private _minDelay;\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    /**\n     * @dev Initializes the contract with a given `minDelay`, and a list of\n     * initial proposers and executors. The proposers receive both the\n     * proposer and the canceller role (for backward compatibility). The\n     * executors receive the executor role.\n     *\n     * NOTE: At construction, both the deployer and the timelock itself are\n     * administrators. This helps further configuration of the timelock by the\n     * deployer. After configuration is done, it is recommended that the\n     * deployer renounces its admin position and relies on timelocked\n     * operations to perform future maintenance.\n     */\n    constructor(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors\n    ) {\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(CANCELLER_ROLE, TIMELOCK_ADMIN_ROLE);\n\n        // deployer + self administration\n        _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n        // register proposers and cancellers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _setupRole(PROPOSER_ROLE, proposers[i]);\n            _setupRole(CANCELLER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _setupRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        _minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, AccessControl) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns whether an id correspond to a registered operation. This\n     * includes both Pending, Ready and Done operations.\n     */\n    function isOperation(bytes32 id) public view virtual returns (bool registered) {\n        return getTimestamp(id) > 0;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not.\n     */\n    function isOperationPending(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready or not.\n     */\n    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {\n        uint256 timestamp = getTimestamp(id);\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view virtual returns (bool done) {\n        return getTimestamp(id) == _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns the timestamp at with an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {\n        return _timestamps[id];\n    }\n\n    /**\n     * @dev Returns the minimum delay for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256 duration) {\n        return _minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(targets, values, payloads, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits a {CallScheduled} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == payloads.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to becomes valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        require(!isOperation(id), \"TimelockController: operation already scheduled\");\n        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");\n        _timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'canceller' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {\n        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");\n        delete _timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata payload,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, payload, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        _execute(target, value, payload);\n        emit CallExecuted(id, 0, target, value, payload);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == payloads.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            address target = targets[i];\n            uint256 value = values[i];\n            bytes calldata payload = payloads[i];\n            _execute(target, value, payload);\n            emit CallExecuted(id, i, target, value, payload);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     */\n    function _execute(\n        address target,\n        uint256 value,\n        bytes calldata data\n    ) internal virtual {\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        _timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        require(msg.sender == address(this), \"TimelockController: caller must be timelock\");\n        emit MinDelayChange(_minDelay, newDelay);\n        _minDelay = newDelay;\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155Received}.\n     */\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n","imports":["token/ERC1155/IERC1155Receiver.sol","utils/Address.sol","access/AccessControl.sol","token/ERC721/IERC721Receiver.sol"],"references":["governance/extensions/GovernorTimelockControl.sol"],"urls":[]},"governance/compatibility/GovernorCompatibilityBravo.sol":{"checksum":{"algorithm":"md5","hash":"0xbde5610ecd11f2f5930e70fda7c90165"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (governance/compatibility/GovernorCompatibilityBravo.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/Counters.sol\";\nimport \"../../utils/math/SafeCast.sol\";\nimport \"../extensions/IGovernorTimelock.sol\";\nimport \"../Governor.sol\";\nimport \"./IGovernorCompatibilityBravo.sol\";\n\n/**\n * @dev Compatibility layer that implements GovernorBravo compatibility on to of {Governor}.\n *\n * This compatibility layer includes a voting system and requires a {IGovernorTimelock} compatible module to be added\n * through inheritance. It does not include token bindings, not does it include any variable upgrade patterns.\n *\n * NOTE: When using this module, you may need to enable the Solidity optimizer to avoid hitting the contract size limit.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorCompatibilityBravo is IGovernorTimelock, IGovernorCompatibilityBravo, Governor {\n    using Counters for Counters.Counter;\n    using Timers for Timers.BlockNumber;\n\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n\n    struct ProposalDetails {\n        address proposer;\n        address[] targets;\n        uint256[] values;\n        string[] signatures;\n        bytes[] calldatas;\n        uint256 forVotes;\n        uint256 againstVotes;\n        uint256 abstainVotes;\n        mapping(address => Receipt) receipts;\n        bytes32 descriptionHash;\n    }\n\n    mapping(uint256 => ProposalDetails) private _proposalDetails;\n\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=bravo\";\n    }\n\n    // ============================================== Proposal lifecycle ==============================================\n    /**\n     * @dev See {IGovernor-propose}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override(IGovernor, Governor) returns (uint256) {\n        _storeProposal(_msgSender(), targets, values, new string[](calldatas.length), calldatas, description);\n        return super.propose(targets, values, calldatas, description);\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-propose}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override returns (uint256) {\n        _storeProposal(_msgSender(), targets, values, signatures, calldatas, description);\n        return propose(targets, values, _encodeCalldata(signatures, calldatas), description);\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-queue}.\n     */\n    function queue(uint256 proposalId) public virtual override {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        queue(\n            details.targets,\n            details.values,\n            _encodeCalldata(details.signatures, details.calldatas),\n            details.descriptionHash\n        );\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-execute}.\n     */\n    function execute(uint256 proposalId) public payable virtual override {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        execute(\n            details.targets,\n            details.values,\n            _encodeCalldata(details.signatures, details.calldatas),\n            details.descriptionHash\n        );\n    }\n\n    function cancel(uint256 proposalId) public virtual override {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n\n        require(\n            _msgSender() == details.proposer || getVotes(details.proposer, block.number - 1) < proposalThreshold(),\n            \"GovernorBravo: proposer above threshold\"\n        );\n\n        _cancel(\n            details.targets,\n            details.values,\n            _encodeCalldata(details.signatures, details.calldatas),\n            details.descriptionHash\n        );\n    }\n\n    /**\n     * @dev Encodes calldatas with optional function signature.\n     */\n    function _encodeCalldata(string[] memory signatures, bytes[] memory calldatas)\n        private\n        pure\n        returns (bytes[] memory)\n    {\n        bytes[] memory fullcalldatas = new bytes[](calldatas.length);\n\n        for (uint256 i = 0; i < signatures.length; ++i) {\n            fullcalldatas[i] = bytes(signatures[i]).length == 0\n                ? calldatas[i]\n                : abi.encodePacked(bytes4(keccak256(bytes(signatures[i]))), calldatas[i]);\n        }\n\n        return fullcalldatas;\n    }\n\n    /**\n     * @dev Store proposal metadata for later lookup\n     */\n    function _storeProposal(\n        address proposer,\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) private {\n        bytes32 descriptionHash = keccak256(bytes(description));\n        uint256 proposalId = hashProposal(targets, values, _encodeCalldata(signatures, calldatas), descriptionHash);\n\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        if (details.descriptionHash == bytes32(0)) {\n            details.proposer = proposer;\n            details.targets = targets;\n            details.values = values;\n            details.signatures = signatures;\n            details.calldatas = calldatas;\n            details.descriptionHash = descriptionHash;\n        }\n    }\n\n    // ==================================================== Views =====================================================\n    /**\n     * @dev See {IGovernorCompatibilityBravo-proposals}.\n     */\n    function proposals(uint256 proposalId)\n        public\n        view\n        virtual\n        override\n        returns (\n            uint256 id,\n            address proposer,\n            uint256 eta,\n            uint256 startBlock,\n            uint256 endBlock,\n            uint256 forVotes,\n            uint256 againstVotes,\n            uint256 abstainVotes,\n            bool canceled,\n            bool executed\n        )\n    {\n        id = proposalId;\n        eta = proposalEta(proposalId);\n        startBlock = proposalSnapshot(proposalId);\n        endBlock = proposalDeadline(proposalId);\n\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        proposer = details.proposer;\n        forVotes = details.forVotes;\n        againstVotes = details.againstVotes;\n        abstainVotes = details.abstainVotes;\n\n        ProposalState status = state(proposalId);\n        canceled = status == ProposalState.Canceled;\n        executed = status == ProposalState.Executed;\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-getActions}.\n     */\n    function getActions(uint256 proposalId)\n        public\n        view\n        virtual\n        override\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        return (details.targets, details.values, details.signatures, details.calldatas);\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-getReceipt}.\n     */\n    function getReceipt(uint256 proposalId, address voter) public view virtual override returns (Receipt memory) {\n        return _proposalDetails[proposalId].receipts[voter];\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-quorumVotes}.\n     */\n    function quorumVotes() public view virtual override returns (uint256) {\n        return quorum(block.number - 1);\n    }\n\n    // ==================================================== Voting ====================================================\n    /**\n     * @dev See {IGovernor-hasVoted}.\n     */\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalDetails[proposalId].receipts[account].hasVoted;\n    }\n\n    /**\n     * @dev See {Governor-_quorumReached}. In this module, only forVotes count toward the quorum.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        return quorum(proposalSnapshot(proposalId)) <= details.forVotes;\n    }\n\n    /**\n     * @dev See {Governor-_voteSucceeded}. In this module, the forVotes must be scritly over the againstVotes.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        return details.forVotes > details.againstVotes;\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. In this module, the support follows Governor Bravo.\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory // params\n    ) internal virtual override {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        Receipt storage receipt = details.receipts[account];\n\n        require(!receipt.hasVoted, \"GovernorCompatibilityBravo: vote already cast\");\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = SafeCast.toUint96(weight);\n\n        if (support == uint8(VoteType.Against)) {\n            details.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            details.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            details.abstainVotes += weight;\n        } else {\n            revert(\"GovernorCompatibilityBravo: invalid vote type\");\n        }\n    }\n}\n","imports":["utils/math/SafeCast.sol","utils/Counters.sol","governance/extensions/IGovernorTimelock.sol","governance/Governor.sol","governance/compatibility/IGovernorCompatibilityBravo.sol"],"references":["mocks/wizard/MyGovernor3.sol","mocks/GovernorCompatibilityBravoMock.sol"],"urls":[]},"governance/compatibility/IGovernorCompatibilityBravo.sol":{"checksum":{"algorithm":"md5","hash":"0x150a6426dc55ba789e76389d6893f908"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (governance/compatibility/IGovernorCompatibilityBravo.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IGovernor.sol\";\n\n/**\n * @dev Interface extension that adds missing functions to the {Governor} core to provide `GovernorBravo` compatibility.\n *\n * _Available since v4.3._\n */\nabstract contract IGovernorCompatibilityBravo is IGovernor {\n    /**\n     * @dev Proposal structure from Compound Governor Bravo. Not actually used by the compatibility layer, as\n     * {{proposal}} returns a very different structure.\n     */\n    struct Proposal {\n        uint256 id;\n        address proposer;\n        uint256 eta;\n        address[] targets;\n        uint256[] values;\n        string[] signatures;\n        bytes[] calldatas;\n        uint256 startBlock;\n        uint256 endBlock;\n        uint256 forVotes;\n        uint256 againstVotes;\n        uint256 abstainVotes;\n        bool canceled;\n        bool executed;\n        mapping(address => Receipt) receipts;\n    }\n\n    /**\n     * @dev Receipt structure from Compound Governor Bravo\n     */\n    struct Receipt {\n        bool hasVoted;\n        uint8 support;\n        uint96 votes;\n    }\n\n    /**\n     * @dev Part of the Governor Bravo's interface.\n     */\n    function quorumVotes() public view virtual returns (uint256);\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"The official record of all proposals ever proposed\"_.\n     */\n    function proposals(uint256)\n        public\n        view\n        virtual\n        returns (\n            uint256 id,\n            address proposer,\n            uint256 eta,\n            uint256 startBlock,\n            uint256 endBlock,\n            uint256 forVotes,\n            uint256 againstVotes,\n            uint256 abstainVotes,\n            bool canceled,\n            bool executed\n        );\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"Function used to propose a new proposal\"_.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual returns (uint256);\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"Queues a proposal of state succeeded\"_.\n     */\n    function queue(uint256 proposalId) public virtual;\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"Executes a queued proposal if eta has passed\"_.\n     */\n    function execute(uint256 proposalId) public payable virtual;\n\n    /**\n     * @dev Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold.\n     */\n    function cancel(uint256 proposalId) public virtual;\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"Gets actions of a proposal\"_.\n     */\n    function getActions(uint256 proposalId)\n        public\n        view\n        virtual\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        );\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"Gets the receipt for a voter on a given proposal\"_.\n     */\n    function getReceipt(uint256 proposalId, address voter) public view virtual returns (Receipt memory);\n}\n","imports":["governance/IGovernor.sol"],"references":["governance/compatibility/GovernorCompatibilityBravo.sol"],"urls":[]},"governance/extensions/GovernorCountingSimple.sol":{"checksum":{"algorithm":"md5","hash":"0x02b1526768c0ab245c630eb5a6b160fc"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (governance/extensions/GovernorCountingSimple.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\n\n/**\n * @dev Extension of {Governor} for simple, 3 options, vote counting.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorCountingSimple is Governor {\n    /**\n     * @dev Supported vote types. Matches Governor Bravo ordering.\n     */\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address => bool) hasVoted;\n    }\n\n    mapping(uint256 => ProposalVote) private _proposalVotes;\n\n    /**\n     * @dev See {IGovernor-COUNTING_MODE}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain\";\n    }\n\n    /**\n     * @dev See {IGovernor-hasVoted}.\n     */\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n\n    /**\n     * @dev Accessor to the internal vote counts.\n     */\n    function proposalVotes(uint256 proposalId)\n        public\n        view\n        virtual\n        returns (\n            uint256 againstVotes,\n            uint256 forVotes,\n            uint256 abstainVotes\n        )\n    {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return (proposalvote.againstVotes, proposalvote.forVotes, proposalvote.abstainVotes);\n    }\n\n    /**\n     * @dev See {Governor-_quorumReached}.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n\n        return quorum(proposalSnapshot(proposalId)) <= proposalvote.forVotes + proposalvote.abstainVotes;\n    }\n\n    /**\n     * @dev See {Governor-_voteSucceeded}. In this module, the forVotes must be strictly over the againstVotes.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n\n        return proposalvote.forVotes > proposalvote.againstVotes;\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. In this module, the support follows the `VoteType` enum (from Governor Bravo).\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory // params\n    ) internal virtual override {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n\n        require(!proposalvote.hasVoted[account], \"GovernorVotingSimple: vote already cast\");\n        proposalvote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalvote.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalvote.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalvote.abstainVotes += weight;\n        } else {\n            revert(\"GovernorVotingSimple: invalid value for enum VoteType\");\n        }\n    }\n}\n","imports":["governance/Governor.sol"],"references":["mocks/GovernorTimelockCompoundMock.sol","mocks/wizard/MyGovernor2.sol","mocks/GovernorCompMock.sol","mocks/GovernorMock.sol","mocks/wizard/MyGovernor1.sol","mocks/GovernorTimelockControlMock.sol","mocks/GovernorPreventLateQuorumMock.sol","mocks/GovernorVoteMock.sol","mocks/GovernorWithParamsMock.sol"],"urls":[]},"governance/extensions/GovernorPreventLateQuorum.sol":{"checksum":{"algorithm":"md5","hash":"0x8a5d8fa457b66fe4bacb1320a0a079b7"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (governance/extensions/GovernorPreventLateQuorum.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\nimport \"../../utils/math/Math.sol\";\n\n/**\n * @dev A module that ensures there is a minimum voting period after quorum is reached. This prevents a large voter from\n * swaying a vote and triggering quorum at the last minute, by ensuring there is always time for other voters to react\n * and try to oppose the decision.\n *\n * If a vote causes quorum to be reached, the proposal's voting period may be extended so that it does not end before at\n * least a given number of blocks have passed (the \"vote extension\" parameter). This parameter can be set by the\n * governance executor (e.g. through a governance proposal).\n *\n * _Available since v4.5._\n */\nabstract contract GovernorPreventLateQuorum is Governor {\n    using SafeCast for uint256;\n    using Timers for Timers.BlockNumber;\n\n    uint64 private _voteExtension;\n    mapping(uint256 => Timers.BlockNumber) private _extendedDeadlines;\n\n    /// @dev Emitted when a proposal deadline is pushed back due to reaching quorum late in its voting period.\n    event ProposalExtended(uint256 indexed proposalId, uint64 extendedDeadline);\n\n    /// @dev Emitted when the {lateQuorumVoteExtension} parameter is changed.\n    event LateQuorumVoteExtensionSet(uint64 oldVoteExtension, uint64 newVoteExtension);\n\n    /**\n     * @dev Initializes the vote extension parameter: the number of blocks that are required to pass since a proposal\n     * reaches quorum until its voting period ends. If necessary the voting period will be extended beyond the one set\n     * at proposal creation.\n     */\n    constructor(uint64 initialVoteExtension) {\n        _setLateQuorumVoteExtension(initialVoteExtension);\n    }\n\n    /**\n     * @dev Returns the proposal deadline, which may have been extended beyond that set at proposal creation, if the\n     * proposal reached quorum late in the voting period. See {Governor-proposalDeadline}.\n     */\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId].getDeadline());\n    }\n\n    /**\n     * @dev Casts a vote and detects if it caused quorum to be reached, potentially extending the voting period. See\n     * {Governor-_castVote}.\n     *\n     * May emit a {ProposalExtended} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual override returns (uint256) {\n        uint256 result = super._castVote(proposalId, account, support, reason, params);\n\n        Timers.BlockNumber storage extendedDeadline = _extendedDeadlines[proposalId];\n\n        if (extendedDeadline.isUnset() && _quorumReached(proposalId)) {\n            uint64 extendedDeadlineValue = block.number.toUint64() + lateQuorumVoteExtension();\n\n            if (extendedDeadlineValue > proposalDeadline(proposalId)) {\n                emit ProposalExtended(proposalId, extendedDeadlineValue);\n            }\n\n            extendedDeadline.setDeadline(extendedDeadlineValue);\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Returns the current value of the vote extension parameter: the number of blocks that are required to pass\n     * from the time a proposal reaches quorum until its voting period ends.\n     */\n    function lateQuorumVoteExtension() public view virtual returns (uint64) {\n        return _voteExtension;\n    }\n\n    /**\n     * @dev Changes the {lateQuorumVoteExtension}. This operation can only be performed by the governance executor,\n     * generally through a governance proposal.\n     *\n     * Emits a {LateQuorumVoteExtensionSet} event.\n     */\n    function setLateQuorumVoteExtension(uint64 newVoteExtension) public virtual onlyGovernance {\n        _setLateQuorumVoteExtension(newVoteExtension);\n    }\n\n    /**\n     * @dev Changes the {lateQuorumVoteExtension}. This is an internal function that can be exposed in a public function\n     * like {setLateQuorumVoteExtension} if another access control mechanism is needed.\n     *\n     * Emits a {LateQuorumVoteExtensionSet} event.\n     */\n    function _setLateQuorumVoteExtension(uint64 newVoteExtension) internal virtual {\n        emit LateQuorumVoteExtensionSet(_voteExtension, newVoteExtension);\n        _voteExtension = newVoteExtension;\n    }\n}\n","imports":["utils/math/Math.sol","governance/Governor.sol"],"references":["mocks/GovernorPreventLateQuorumMock.sol"],"urls":[]},"governance/extensions/GovernorProposalThreshold.sol":{"checksum":{"algorithm":"md5","hash":"0xbadf0ac3dc5335b05d84dab6e58a9d6e"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (governance/extensions/GovernorProposalThreshold.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\n\n/**\n * @dev Extension of {Governor} for proposal restriction to token holders with a minimum balance.\n *\n * _Available since v4.3._\n * _Deprecated since v4.4._\n */\nabstract contract GovernorProposalThreshold is Governor {\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override returns (uint256) {\n        return super.propose(targets, values, calldatas, description);\n    }\n}\n","imports":["governance/Governor.sol"],"references":["mocks/wizard/MyGovernor2.sol","mocks/GovernorMock.sol"],"urls":[]},"governance/extensions/GovernorSettings.sol":{"checksum":{"algorithm":"md5","hash":"0x2c6e87fa9b63c7ef8579eb4ae937d4c2"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (governance/extensions/GovernorSettings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\n\n/**\n * @dev Extension of {Governor} for settings updatable through governance.\n *\n * _Available since v4.4._\n */\nabstract contract GovernorSettings is Governor {\n    uint256 private _votingDelay;\n    uint256 private _votingPeriod;\n    uint256 private _proposalThreshold;\n\n    event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);\n    event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);\n    event ProposalThresholdSet(uint256 oldProposalThreshold, uint256 newProposalThreshold);\n\n    /**\n     * @dev Initialize the governance parameters.\n     */\n    constructor(\n        uint256 initialVotingDelay,\n        uint256 initialVotingPeriod,\n        uint256 initialProposalThreshold\n    ) {\n        _setVotingDelay(initialVotingDelay);\n        _setVotingPeriod(initialVotingPeriod);\n        _setProposalThreshold(initialProposalThreshold);\n    }\n\n    /**\n     * @dev See {IGovernor-votingDelay}.\n     */\n    function votingDelay() public view virtual override returns (uint256) {\n        return _votingDelay;\n    }\n\n    /**\n     * @dev See {IGovernor-votingPeriod}.\n     */\n    function votingPeriod() public view virtual override returns (uint256) {\n        return _votingPeriod;\n    }\n\n    /**\n     * @dev See {Governor-proposalThreshold}.\n     */\n    function proposalThreshold() public view virtual override returns (uint256) {\n        return _proposalThreshold;\n    }\n\n    /**\n     * @dev Update the voting delay. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {VotingDelaySet} event.\n     */\n    function setVotingDelay(uint256 newVotingDelay) public virtual onlyGovernance {\n        _setVotingDelay(newVotingDelay);\n    }\n\n    /**\n     * @dev Update the voting period. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {VotingPeriodSet} event.\n     */\n    function setVotingPeriod(uint256 newVotingPeriod) public virtual onlyGovernance {\n        _setVotingPeriod(newVotingPeriod);\n    }\n\n    /**\n     * @dev Update the proposal threshold. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {ProposalThresholdSet} event.\n     */\n    function setProposalThreshold(uint256 newProposalThreshold) public virtual onlyGovernance {\n        _setProposalThreshold(newProposalThreshold);\n    }\n\n    /**\n     * @dev Internal setter for the voting delay.\n     *\n     * Emits a {VotingDelaySet} event.\n     */\n    function _setVotingDelay(uint256 newVotingDelay) internal virtual {\n        emit VotingDelaySet(_votingDelay, newVotingDelay);\n        _votingDelay = newVotingDelay;\n    }\n\n    /**\n     * @dev Internal setter for the voting period.\n     *\n     * Emits a {VotingPeriodSet} event.\n     */\n    function _setVotingPeriod(uint256 newVotingPeriod) internal virtual {\n        // voting period must be at least one block long\n        require(newVotingPeriod > 0, \"GovernorSettings: voting period too low\");\n        emit VotingPeriodSet(_votingPeriod, newVotingPeriod);\n        _votingPeriod = newVotingPeriod;\n    }\n\n    /**\n     * @dev Internal setter for the proposal threshold.\n     *\n     * Emits a {ProposalThresholdSet} event.\n     */\n    function _setProposalThreshold(uint256 newProposalThreshold) internal virtual {\n        emit ProposalThresholdSet(_proposalThreshold, newProposalThreshold);\n        _proposalThreshold = newProposalThreshold;\n    }\n}\n","imports":["governance/Governor.sol"],"references":["mocks/GovernorTimelockCompoundMock.sol","mocks/GovernorMock.sol","mocks/GovernorCompatibilityBravoMock.sol","mocks/GovernorTimelockControlMock.sol","mocks/GovernorPreventLateQuorumMock.sol"],"urls":[]},"governance/extensions/GovernorTimelockCompound.sol":{"checksum":{"algorithm":"md5","hash":"0x756c2fabb71e0805f8bf4464638b3034"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (governance/extensions/GovernorTimelockCompound.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IGovernorTimelock.sol\";\nimport \"../Governor.sol\";\nimport \"../../utils/math/SafeCast.sol\";\nimport \"../../vendor/compound/ICompoundTimelock.sol\";\n\n/**\n * @dev Extension of {Governor} that binds the execution process to a Compound Timelock. This adds a delay, enforced by\n * the external timelock to all successful proposal (in addition to the voting duration). The {Governor} needs to be\n * the admin of the timelock for any operation to be performed. A public, unrestricted,\n * {GovernorTimelockCompound-__acceptAdmin} is available to accept ownership of the timelock.\n *\n * Using this model means the proposal will be operated by the {TimelockController} and not by the {Governor}. Thus,\n * the assets and permissions must be attached to the {TimelockController}. Any asset sent to the {Governor} will be\n * inaccessible.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorTimelockCompound is IGovernorTimelock, Governor {\n    using SafeCast for uint256;\n    using Timers for Timers.Timestamp;\n\n    struct ProposalTimelock {\n        Timers.Timestamp timer;\n    }\n\n    ICompoundTimelock private _timelock;\n\n    mapping(uint256 => ProposalTimelock) private _proposalTimelocks;\n\n    /**\n     * @dev Emitted when the timelock controller used for proposal execution is modified.\n     */\n    event TimelockChange(address oldTimelock, address newTimelock);\n\n    /**\n     * @dev Set the timelock.\n     */\n    constructor(ICompoundTimelock timelockAddress) {\n        _updateTimelock(timelockAddress);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, Governor) returns (bool) {\n        return interfaceId == type(IGovernorTimelock).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Overridden version of the {Governor-state} function with added support for the `Queued` and `Expired` status.\n     */\n    function state(uint256 proposalId) public view virtual override(IGovernor, Governor) returns (ProposalState) {\n        ProposalState status = super.state(proposalId);\n\n        if (status != ProposalState.Succeeded) {\n            return status;\n        }\n\n        uint256 eta = proposalEta(proposalId);\n        if (eta == 0) {\n            return status;\n        } else if (block.timestamp >= eta + _timelock.GRACE_PERIOD()) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /**\n     * @dev Public accessor to check the address of the timelock\n     */\n    function timelock() public view virtual override returns (address) {\n        return address(_timelock);\n    }\n\n    /**\n     * @dev Public accessor to check the eta of a queued proposal\n     */\n    function proposalEta(uint256 proposalId) public view virtual override returns (uint256) {\n        return _proposalTimelocks[proposalId].timer.getDeadline();\n    }\n\n    /**\n     * @dev Function to queue a proposal to the timelock.\n     */\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        require(state(proposalId) == ProposalState.Succeeded, \"Governor: proposal not successful\");\n\n        uint256 eta = block.timestamp + _timelock.delay();\n        _proposalTimelocks[proposalId].timer.setDeadline(eta.toUint64());\n        for (uint256 i = 0; i < targets.length; ++i) {\n            require(\n                !_timelock.queuedTransactions(keccak256(abi.encode(targets[i], values[i], \"\", calldatas[i], eta))),\n                \"GovernorTimelockCompound: identical proposal action already queued\"\n            );\n            _timelock.queueTransaction(targets[i], values[i], \"\", calldatas[i], eta);\n        }\n\n        emit ProposalQueued(proposalId, eta);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Overridden execute function that run the already queued proposal through the timelock.\n     */\n    function _execute(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual override {\n        uint256 eta = proposalEta(proposalId);\n        require(eta > 0, \"GovernorTimelockCompound: proposal not yet queued\");\n        Address.sendValue(payable(_timelock), msg.value);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            _timelock.executeTransaction(targets[i], values[i], \"\", calldatas[i], eta);\n        }\n    }\n\n    /**\n     * @dev Overridden version of the {Governor-_cancel} function to cancel the timelocked proposal if it as already\n     * been queued.\n     */\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override returns (uint256) {\n        uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash);\n\n        uint256 eta = proposalEta(proposalId);\n        if (eta > 0) {\n            for (uint256 i = 0; i < targets.length; ++i) {\n                _timelock.cancelTransaction(targets[i], values[i], \"\", calldatas[i], eta);\n            }\n            _proposalTimelocks[proposalId].timer.reset();\n        }\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Address through which the governor executes action. In this case, the timelock.\n     */\n    function _executor() internal view virtual override returns (address) {\n        return address(_timelock);\n    }\n\n    /**\n     * @dev Accept admin right over the timelock.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    function __acceptAdmin() public {\n        _timelock.acceptAdmin();\n    }\n\n    /**\n     * @dev Public endpoint to update the underlying timelock instance. Restricted to the timelock itself, so updates\n     * must be proposed, scheduled, and executed through governance proposals.\n     *\n     * For security reasons, the timelock must be handed over to another admin before setting up a new one. The two\n     * operations (hand over the timelock) and do the update can be batched in a single proposal.\n     *\n     * Note that if the timelock admin has been handed over in a previous operation, we refuse updates made through the\n     * timelock if admin of the timelock has already been accepted and the operation is executed outside the scope of\n     * governance.\n\n     * CAUTION: It is not recommended to change the timelock while there are other queued governance proposals.\n     */\n    function updateTimelock(ICompoundTimelock newTimelock) external virtual onlyGovernance {\n        _updateTimelock(newTimelock);\n    }\n\n    function _updateTimelock(ICompoundTimelock newTimelock) private {\n        emit TimelockChange(address(_timelock), address(newTimelock));\n        _timelock = newTimelock;\n    }\n}\n","imports":["vendor/compound/ICompoundTimelock.sol","governance/extensions/IGovernorTimelock.sol","utils/math/SafeCast.sol","governance/Governor.sol"],"references":["mocks/GovernorTimelockCompoundMock.sol","mocks/GovernorCompatibilityBravoMock.sol"],"urls":[]},"governance/extensions/GovernorTimelockControl.sol":{"checksum":{"algorithm":"md5","hash":"0xd75bd1fe3635665c9468947aa4c13bd5"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (governance/extensions/GovernorTimelockControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IGovernorTimelock.sol\";\nimport \"../Governor.sol\";\nimport \"../TimelockController.sol\";\n\n/**\n * @dev Extension of {Governor} that binds the execution process to an instance of {TimelockController}. This adds a\n * delay, enforced by the {TimelockController} to all successful proposal (in addition to the voting duration). The\n * {Governor} needs the proposer (and ideally the executor) roles for the {Governor} to work properly.\n *\n * Using this model means the proposal will be operated by the {TimelockController} and not by the {Governor}. Thus,\n * the assets and permissions must be attached to the {TimelockController}. Any asset sent to the {Governor} will be\n * inaccessible.\n *\n * WARNING: Setting up the TimelockController to have additional proposers besides the governor is very risky, as it\n * grants them powers that they must be trusted or known not to use: 1) {onlyGovernance} functions like {relay} are\n * available to them through the timelock, and 2) approved governance proposals can be blocked by them, effectively\n * executing a Denial of Service attack. This risk will be mitigated in a future release.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorTimelockControl is IGovernorTimelock, Governor {\n    TimelockController private _timelock;\n    mapping(uint256 => bytes32) private _timelockIds;\n\n    /**\n     * @dev Emitted when the timelock controller used for proposal execution is modified.\n     */\n    event TimelockChange(address oldTimelock, address newTimelock);\n\n    /**\n     * @dev Set the timelock.\n     */\n    constructor(TimelockController timelockAddress) {\n        _updateTimelock(timelockAddress);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, Governor) returns (bool) {\n        return interfaceId == type(IGovernorTimelock).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Overridden version of the {Governor-state} function with added support for the `Queued` status.\n     */\n    function state(uint256 proposalId) public view virtual override(IGovernor, Governor) returns (ProposalState) {\n        ProposalState status = super.state(proposalId);\n\n        if (status != ProposalState.Succeeded) {\n            return status;\n        }\n\n        // core tracks execution, so we just have to check if successful proposal have been queued.\n        bytes32 queueid = _timelockIds[proposalId];\n        if (queueid == bytes32(0)) {\n            return status;\n        } else if (_timelock.isOperationDone(queueid)) {\n            return ProposalState.Executed;\n        } else if (_timelock.isOperationPending(queueid)) {\n            return ProposalState.Queued;\n        } else {\n            return ProposalState.Canceled;\n        }\n    }\n\n    /**\n     * @dev Public accessor to check the address of the timelock\n     */\n    function timelock() public view virtual override returns (address) {\n        return address(_timelock);\n    }\n\n    /**\n     * @dev Public accessor to check the eta of a queued proposal\n     */\n    function proposalEta(uint256 proposalId) public view virtual override returns (uint256) {\n        uint256 eta = _timelock.getTimestamp(_timelockIds[proposalId]);\n        return eta == 1 ? 0 : eta; // _DONE_TIMESTAMP (1) should be replaced with a 0 value\n    }\n\n    /**\n     * @dev Function to queue a proposal to the timelock.\n     */\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        require(state(proposalId) == ProposalState.Succeeded, \"Governor: proposal not successful\");\n\n        uint256 delay = _timelock.getMinDelay();\n        _timelockIds[proposalId] = _timelock.hashOperationBatch(targets, values, calldatas, 0, descriptionHash);\n        _timelock.scheduleBatch(targets, values, calldatas, 0, descriptionHash, delay);\n\n        emit ProposalQueued(proposalId, block.timestamp + delay);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Overridden execute function that run the already queued proposal through the timelock.\n     */\n    function _execute(\n        uint256, /* proposalId */\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override {\n        _timelock.executeBatch{value: msg.value}(targets, values, calldatas, 0, descriptionHash);\n    }\n\n    /**\n     * @dev Overridden version of the {Governor-_cancel} function to cancel the timelocked proposal if it as already\n     * been queued.\n     */\n    // This function can reenter through the external call to the timelock, but we assume the timelock is trusted and\n    // well behaved (according to TimelockController) and this will not happen.\n    // slither-disable-next-line reentrancy-no-eth\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override returns (uint256) {\n        uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash);\n\n        if (_timelockIds[proposalId] != 0) {\n            _timelock.cancel(_timelockIds[proposalId]);\n            delete _timelockIds[proposalId];\n        }\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Address through which the governor executes action. In this case, the timelock.\n     */\n    function _executor() internal view virtual override returns (address) {\n        return address(_timelock);\n    }\n\n    /**\n     * @dev Public endpoint to update the underlying timelock instance. Restricted to the timelock itself, so updates\n     * must be proposed, scheduled, and executed through governance proposals.\n     *\n     * CAUTION: It is not recommended to change the timelock while there are other queued governance proposals.\n     */\n    function updateTimelock(TimelockController newTimelock) external virtual onlyGovernance {\n        _updateTimelock(newTimelock);\n    }\n\n    function _updateTimelock(TimelockController newTimelock) private {\n        emit TimelockChange(address(_timelock), address(newTimelock));\n        _timelock = newTimelock;\n    }\n}\n","imports":["governance/extensions/IGovernorTimelock.sol","governance/TimelockController.sol","governance/Governor.sol"],"references":["mocks/wizard/MyGovernor2.sol","mocks/wizard/MyGovernor1.sol","mocks/wizard/MyGovernor3.sol","mocks/GovernorTimelockControlMock.sol"],"urls":[]},"governance/extensions/GovernorVotes.sol":{"checksum":{"algorithm":"md5","hash":"0xd5ec18eb16b8452e749ee7d3aaa304b1"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (governance/extensions/GovernorVotes.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\nimport \"../utils/IVotes.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token, or since v4.5 an {ERC721Votes} token.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorVotes is Governor {\n    IVotes public immutable token;\n\n    constructor(IVotes tokenAddress) {\n        token = tokenAddress;\n    }\n\n    /**\n     * Read the voting weight from the token's built in snapshot mechanism (see {Governor-_getVotes}).\n     */\n    function _getVotes(\n        address account,\n        uint256 blockNumber,\n        bytes memory /*params*/\n    ) internal view virtual override returns (uint256) {\n        return token.getPastVotes(account, blockNumber);\n    }\n}\n","imports":["governance/utils/IVotes.sol","governance/Governor.sol"],"references":["mocks/wizard/MyGovernor2.sol","mocks/wizard/MyGovernor1.sol","mocks/wizard/MyGovernor3.sol","mocks/GovernorPreventLateQuorumMock.sol","mocks/GovernorVoteMock.sol","mocks/GovernorWithParamsMock.sol","governance/extensions/GovernorVotesQuorumFraction.sol"],"urls":[]},"governance/extensions/GovernorVotesComp.sol":{"checksum":{"algorithm":"md5","hash":"0xb5275e42abd62e4780bd73bc69492d33"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (governance/extensions/GovernorVotesComp.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\nimport \"../../token/ERC20/extensions/ERC20VotesComp.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from a Comp token.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorVotesComp is Governor {\n    ERC20VotesComp public immutable token;\n\n    constructor(ERC20VotesComp token_) {\n        token = token_;\n    }\n\n    /**\n     * Read the voting weight from the token's built in snapshot mechanism (see {Governor-_getVotes}).\n     */\n    function _getVotes(\n        address account,\n        uint256 blockNumber,\n        bytes memory /*params*/\n    ) internal view virtual override returns (uint256) {\n        return token.getPriorVotes(account, blockNumber);\n    }\n}\n","imports":["token/ERC20/extensions/ERC20VotesComp.sol","governance/Governor.sol"],"references":["mocks/GovernorCompMock.sol","mocks/GovernorCompatibilityBravoMock.sol"],"urls":[]},"governance/extensions/GovernorVotesQuorumFraction.sol":{"checksum":{"algorithm":"md5","hash":"0xb346cb21204465106e3d5ea7b6264ee9"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (governance/extensions/GovernorVotesQuorumFraction.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./GovernorVotes.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token and a quorum expressed as a\n * fraction of the total supply.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorVotesQuorumFraction is GovernorVotes {\n    uint256 private _quorumNumerator;\n\n    event QuorumNumeratorUpdated(uint256 oldQuorumNumerator, uint256 newQuorumNumerator);\n\n    /**\n     * @dev Initialize quorum as a fraction of the token's total supply.\n     *\n     * The fraction is specified as `numerator / denominator`. By default the denominator is 100, so quorum is\n     * specified as a percent: a numerator of 10 corresponds to quorum being 10% of total supply. The denominator can be\n     * customized by overriding {quorumDenominator}.\n     */\n    constructor(uint256 quorumNumeratorValue) {\n        _updateQuorumNumerator(quorumNumeratorValue);\n    }\n\n    /**\n     * @dev Returns the current quorum numerator. See {quorumDenominator}.\n     */\n    function quorumNumerator() public view virtual returns (uint256) {\n        return _quorumNumerator;\n    }\n\n    /**\n     * @dev Returns the quorum denominator. Defaults to 100, but may be overridden.\n     */\n    function quorumDenominator() public view virtual returns (uint256) {\n        return 100;\n    }\n\n    /**\n     * @dev Returns the quorum for a block number, in terms of number of votes: `supply * numerator / denominator`.\n     */\n    function quorum(uint256 blockNumber) public view virtual override returns (uint256) {\n        return (token.getPastTotalSupply(blockNumber) * quorumNumerator()) / quorumDenominator();\n    }\n\n    /**\n     * @dev Changes the quorum numerator.\n     *\n     * Emits a {QuorumNumeratorUpdated} event.\n     *\n     * Requirements:\n     *\n     * - Must be called through a governance proposal.\n     * - New numerator must be smaller or equal to the denominator.\n     */\n    function updateQuorumNumerator(uint256 newQuorumNumerator) external virtual onlyGovernance {\n        _updateQuorumNumerator(newQuorumNumerator);\n    }\n\n    /**\n     * @dev Changes the quorum numerator.\n     *\n     * Emits a {QuorumNumeratorUpdated} event.\n     *\n     * Requirements:\n     *\n     * - New numerator must be smaller or equal to the denominator.\n     */\n    function _updateQuorumNumerator(uint256 newQuorumNumerator) internal virtual {\n        require(\n            newQuorumNumerator <= quorumDenominator(),\n            \"GovernorVotesQuorumFraction: quorumNumerator over quorumDenominator\"\n        );\n\n        uint256 oldQuorumNumerator = _quorumNumerator;\n        _quorumNumerator = newQuorumNumerator;\n\n        emit QuorumNumeratorUpdated(oldQuorumNumerator, newQuorumNumerator);\n    }\n}\n","imports":["governance/extensions/GovernorVotes.sol"],"references":["mocks/GovernorTimelockCompoundMock.sol","mocks/wizard/MyGovernor2.sol","mocks/GovernorMock.sol","mocks/wizard/MyGovernor1.sol","mocks/wizard/MyGovernor3.sol","mocks/GovernorTimelockControlMock.sol"],"urls":[]},"governance/extensions/IGovernorTimelock.sol":{"checksum":{"algorithm":"md5","hash":"0xeebb17e144c4fd58549d815db19552da"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (governance/extensions/IGovernorTimelock.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IGovernor.sol\";\n\n/**\n * @dev Extension of the {IGovernor} for timelock supporting modules.\n *\n * _Available since v4.3._\n */\nabstract contract IGovernorTimelock is IGovernor {\n    event ProposalQueued(uint256 proposalId, uint256 eta);\n\n    function timelock() public view virtual returns (address);\n\n    function proposalEta(uint256 proposalId) public view virtual returns (uint256);\n\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256 proposalId);\n}\n","imports":["governance/IGovernor.sol"],"references":["governance/compatibility/GovernorCompatibilityBravo.sol","governance/extensions/GovernorTimelockCompound.sol","governance/extensions/GovernorTimelockControl.sol"],"urls":[]},"governance/utils/IVotes.sol":{"checksum":{"algorithm":"md5","hash":"0xa036d40989f21d08bb990e68d0088fa1"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (governance/utils/IVotes.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\n *\n * _Available since v4.5._\n */\ninterface IVotes {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of votes that `account` had at the end of a past block (`blockNumber`).\n     */\n    function getPastVotes(address account, uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at the end of a past block (`blockNumber`).\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) external view returns (address);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n","imports":[],"references":["governance/utils/Votes.sol","token/ERC20/extensions/ERC20Votes.sol","governance/extensions/GovernorVotes.sol"],"urls":[]},"governance/utils/Votes.sol":{"checksum":{"algorithm":"md5","hash":"0x33fb580069b232a436ee825012df574d"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (governance/utils/Votes.sol)\npragma solidity ^0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Counters.sol\";\nimport \"../../utils/Checkpoints.sol\";\nimport \"../../utils/cryptography/draft-EIP712.sol\";\nimport \"./IVotes.sol\";\n\n/**\n * @dev This is a base abstract contract that tracks voting units, which are a measure of voting power that can be\n * transferred, and provides a system of vote delegation, where an account can delegate its voting units to a sort of\n * \"representative\" that will pool delegated voting units from different accounts and can then use it to vote in\n * decisions. In fact, voting units _must_ be delegated in order to count as actual votes, and an account has to\n * delegate those votes to itself if it wishes to participate in decisions and does not have a trusted representative.\n *\n * This contract is often combined with a token contract such that voting units correspond to token units. For an\n * example, see {ERC721Votes}.\n *\n * The full history of delegate votes is tracked on-chain so that governance protocols can consider votes as distributed\n * at a particular block number to protect against flash loans and double voting. The opt-in delegate system makes the\n * cost of this history tracking optional.\n *\n * When using this module the derived contract must implement {_getVotingUnits} (for example, make it return\n * {ERC721-balanceOf}), and can use {_transferVotingUnits} to track a change in the distribution of those units (in the\n * previous example, it would be included in {ERC721-_beforeTokenTransfer}).\n *\n * _Available since v4.5._\n */\nabstract contract Votes is IVotes, Context, EIP712 {\n    using Checkpoints for Checkpoints.History;\n    using Counters for Counters.Counter;\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegation;\n    mapping(address => Checkpoints.History) private _delegateCheckpoints;\n    Checkpoints.History private _totalCheckpoints;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) public view virtual override returns (uint256) {\n        return _delegateCheckpoints[account].latest();\n    }\n\n    /**\n     * @dev Returns the amount of votes that `account` had at the end of a past block (`blockNumber`).\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {\n        return _delegateCheckpoints[account].getAtBlock(blockNumber);\n    }\n\n    /**\n     * @dev Returns the total supply of votes available at the end of a past block (`blockNumber`).\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"Votes: block not yet mined\");\n        return _totalCheckpoints.getAtBlock(blockNumber);\n    }\n\n    /**\n     * @dev Returns the current total supply of votes.\n     */\n    function _getTotalSupply() internal view virtual returns (uint256) {\n        return _totalCheckpoints.latest();\n    }\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegation[account];\n    }\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual override {\n        address account = _msgSender();\n        _delegate(account, delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"Votes: signature expired\");\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Delegate all of `account`'s voting units to `delegatee`.\n     *\n     * Emits events {DelegateChanged} and {DelegateVotesChanged}.\n     */\n    function _delegate(address account, address delegatee) internal virtual {\n        address oldDelegate = delegates(account);\n        _delegation[account] = delegatee;\n\n        emit DelegateChanged(account, oldDelegate, delegatee);\n        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));\n    }\n\n    /**\n     * @dev Transfers, mints, or burns voting units. To register a mint, `from` should be zero. To register a burn, `to`\n     * should be zero. Total supply of voting units will be adjusted with mints and burns.\n     */\n    function _transferVotingUnits(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        if (from == address(0)) {\n            _totalCheckpoints.push(_add, amount);\n        }\n        if (to == address(0)) {\n            _totalCheckpoints.push(_subtract, amount);\n        }\n        _moveDelegateVotes(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Moves delegated votes from one delegate to another.\n     */\n    function _moveDelegateVotes(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        if (from != to && amount > 0) {\n            if (from != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _delegateCheckpoints[from].push(_subtract, amount);\n                emit DelegateVotesChanged(from, oldValue, newValue);\n            }\n            if (to != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _delegateCheckpoints[to].push(_add, amount);\n                emit DelegateVotesChanged(to, oldValue, newValue);\n            }\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n\n    /**\n     * @dev Returns an address nonce.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev Returns the contract's {EIP712} domain separator.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev Must return the voting units held by an account.\n     */\n    function _getVotingUnits(address) internal view virtual returns (uint256);\n}\n","imports":["utils/cryptography/draft-EIP712.sol","utils/Checkpoints.sol","utils/Counters.sol","governance/utils/IVotes.sol","utils/Context.sol"],"references":["token/ERC721/extensions/draft-ERC721Votes.sol","mocks/VotesMock.sol"],"urls":[]},"interfaces/IERC1155.sol":{"checksum":{"algorithm":"md5","hash":"0xf646f2b291e7c83dcc7f1c6c7d1ece30"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC1155/IERC1155.sol\";\n","imports":["token/ERC1155/IERC1155.sol"],"references":[],"urls":[]},"interfaces/IERC1155MetadataURI.sol":{"checksum":{"algorithm":"md5","hash":"0xbc1c98271c8b14d98b8caf09250dd039"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC1155/extensions/IERC1155MetadataURI.sol\";\n","imports":["token/ERC1155/extensions/IERC1155MetadataURI.sol"],"references":[],"urls":[]},"interfaces/IERC1155Receiver.sol":{"checksum":{"algorithm":"md5","hash":"0xa80dbc3947556c57c569cd81aa255f10"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC1155/IERC1155Receiver.sol\";\n","imports":["token/ERC1155/IERC1155Receiver.sol"],"references":[],"urls":[]},"interfaces/IERC1271.sol":{"checksum":{"algorithm":"md5","hash":"0x8fe867b95c856b204f954a1910e28a1e"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n","imports":[],"references":["mocks/ERC1271WalletMock.sol","utils/cryptography/SignatureChecker.sol"],"urls":[]},"interfaces/IERC1363.sol":{"checksum":{"algorithm":"md5","hash":"0xacec8cadeb2b66b07429c854a788a555"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IERC165.sol\";\n\ninterface IERC1363 is IERC165, IERC20 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0x4bbee2df.\n     * 0x4bbee2df ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)'))\n     */\n\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xfb9ec8ce.\n     * 0xfb9ec8ce ===\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\n     * @param to address The address which you want to transfer to\n     * @param value uint256 The amount of tokens to be transferred\n     * @return true unless throwing\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\n     * @param to address The address which you want to transfer to\n     * @param value uint256 The amount of tokens to be transferred\n     * @param data bytes Additional data with no specified format, sent in call to `to`\n     * @return true unless throwing\n     */\n    function transferAndCall(\n        address to,\n        uint256 value,\n        bytes memory data\n    ) external returns (bool);\n\n    /**\n     * @dev Transfer tokens from one address to another and then call `onTransferReceived` on receiver\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 The amount of tokens to be transferred\n     * @return true unless throwing\n     */\n    function transferFromAndCall(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    /**\n     * @dev Transfer tokens from one address to another and then call `onTransferReceived` on receiver\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 The amount of tokens to be transferred\n     * @param data bytes Additional data with no specified format, sent in call to `to`\n     * @return true unless throwing\n     */\n    function transferFromAndCall(\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) external returns (bool);\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\n     * and then call `onApprovalReceived` on spender.\n     * @param spender address The address which will spend the funds\n     * @param value uint256 The amount of tokens to be spent\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\n     * and then call `onApprovalReceived` on spender.\n     * @param spender address The address which will spend the funds\n     * @param value uint256 The amount of tokens to be spent\n     * @param data bytes Additional data with no specified format, sent in call to `spender`\n     */\n    function approveAndCall(\n        address spender,\n        uint256 value,\n        bytes memory data\n    ) external returns (bool);\n}\n","imports":["interfaces/IERC165.sol","interfaces/IERC20.sol"],"references":[],"urls":[]},"interfaces/IERC1363Receiver.sol":{"checksum":{"algorithm":"md5","hash":"0x81d82b92e32be3906f750c8aa081eb09"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1363Receiver.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC1363Receiver {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0x88a7ca5c.\n     * 0x88a7ca5c === bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))\n     */\n\n    /**\n     * @notice Handle the receipt of ERC1363 tokens\n     * @dev Any ERC1363 smart contract calls this function on the recipient\n     * after a `transfer` or a `transferFrom`. This function MAY throw to revert and reject the\n     * transfer. Return of other than the magic value MUST result in the\n     * transaction being reverted.\n     * Note: the token contract address is always the message sender.\n     * @param operator address The address which called `transferAndCall` or `transferFromAndCall` function\n     * @param from address The address which are token transferred from\n     * @param value uint256 The amount of tokens transferred\n     * @param data bytes Additional data with no specified format\n     * @return `bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))`\n     *  unless throwing\n     */\n    function onTransferReceived(\n        address operator,\n        address from,\n        uint256 value,\n        bytes memory data\n    ) external returns (bytes4);\n}\n","imports":[],"references":[],"urls":[]},"interfaces/IERC1363Spender.sol":{"checksum":{"algorithm":"md5","hash":"0x59232bcd69ecd60f9fdc41e435eff762"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1363Spender.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC1363Spender {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0x7b04a2d0.\n     * 0x7b04a2d0 === bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))\n     */\n\n    /**\n     * @notice Handle the approval of ERC1363 tokens\n     * @dev Any ERC1363 smart contract calls this function on the recipient\n     * after an `approve`. This function MAY throw to revert and reject the\n     * approval. Return of other than the magic value MUST result in the\n     * transaction being reverted.\n     * Note: the token contract address is always the message sender.\n     * @param owner address The address which called `approveAndCall` function\n     * @param value uint256 The amount of tokens to be spent\n     * @param data bytes Additional data with no specified format\n     * @return `bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))`\n     *  unless throwing\n     */\n    function onApprovalReceived(\n        address owner,\n        uint256 value,\n        bytes memory data\n    ) external returns (bytes4);\n}\n","imports":[],"references":[],"urls":[]},"interfaces/IERC165.sol":{"checksum":{"algorithm":"md5","hash":"0xee9624272968c23d93d4c2e39f06e6e2"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n","imports":["utils/introspection/IERC165.sol"],"references":["interfaces/IERC1363.sol"],"urls":[]},"interfaces/IERC1820Implementer.sol":{"checksum":{"algorithm":"md5","hash":"0xb78ff1b7467f49381ceffd0e1c86b821"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1820Implementer.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC1820Implementer.sol\";\n","imports":["utils/introspection/IERC1820Implementer.sol"],"references":[],"urls":[]},"interfaces/IERC1820Registry.sol":{"checksum":{"algorithm":"md5","hash":"0xfee82324a47df8d208c5389f695afab9"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1820Registry.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC1820Registry.sol\";\n","imports":["utils/introspection/IERC1820Registry.sol"],"references":[],"urls":[]},"interfaces/IERC20.sol":{"checksum":{"algorithm":"md5","hash":"0xd151fbfe7939989b9acf22797b32058b"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n","imports":["token/ERC20/IERC20.sol"],"references":["interfaces/IERC1363.sol"],"urls":[]},"interfaces/IERC20Metadata.sol":{"checksum":{"algorithm":"md5","hash":"0x5f6b568ff33d29c2a468a48e4d2bb0f4"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/extensions/IERC20Metadata.sol\";\n","imports":["token/ERC20/extensions/IERC20Metadata.sol"],"references":[],"urls":[]},"interfaces/IERC2981.sol":{"checksum":{"algorithm":"md5","hash":"0x608566bc5327454ba54e487e7c226ff6"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * _Available since v4.5._\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n","imports":["utils/introspection/IERC165.sol"],"references":["token/common/ERC2981.sol"],"urls":[]},"interfaces/IERC3156.sol":{"checksum":{"algorithm":"md5","hash":"0x8a4addf833379ccc6911f847b308332f"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC3156FlashBorrower.sol\";\nimport \"./IERC3156FlashLender.sol\";\n","imports":["interfaces/IERC3156FlashLender.sol","interfaces/IERC3156FlashBorrower.sol"],"references":["mocks/ERC3156FlashBorrowerMock.sol"],"urls":[]},"interfaces/IERC3156FlashBorrower.sol":{"checksum":{"algorithm":"md5","hash":"0xa526318b0e6016b4ef301c4279be02cb"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (interfaces/IERC3156FlashBorrower.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC3156 FlashBorrower, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashBorrower {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"IERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n","imports":[],"references":["interfaces/IERC3156.sol","interfaces/IERC3156FlashLender.sol","token/ERC20/extensions/ERC20FlashMint.sol"],"urls":[]},"interfaces/IERC3156FlashLender.sol":{"checksum":{"algorithm":"md5","hash":"0x9e16b4d269b399e8ab6342e0cf8a2edd"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156FlashLender.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC3156FlashBorrower.sol\";\n\n/**\n * @dev Interface of the ERC3156 FlashLender, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashLender {\n    /**\n     * @dev The amount of currency available to be lended.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n","imports":["interfaces/IERC3156FlashBorrower.sol"],"references":["interfaces/IERC3156.sol","token/ERC20/extensions/ERC20FlashMint.sol"],"urls":[]},"interfaces/IERC4626.sol":{"checksum":{"algorithm":"md5","hash":"0xcb420c41d73987fa812167081de427a5"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\nimport \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is \u201cmanaged\u201d by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n}\n","imports":["token/ERC20/IERC20.sol","token/ERC20/extensions/IERC20Metadata.sol"],"references":["token/ERC20/extensions/ERC4626.sol"],"urls":[]},"interfaces/IERC721.sol":{"checksum":{"algorithm":"md5","hash":"0xe6da7798a8c22c5043cc42d64a2a8f80"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n","imports":["token/ERC721/IERC721.sol"],"references":[],"urls":[]},"interfaces/IERC721Enumerable.sol":{"checksum":{"algorithm":"md5","hash":"0xff727125a84ba8d0dd642f6ab0632435"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/extensions/IERC721Enumerable.sol\";\n","imports":["token/ERC721/extensions/IERC721Enumerable.sol"],"references":[],"urls":[]},"interfaces/IERC721Metadata.sol":{"checksum":{"algorithm":"md5","hash":"0xd228683ef3a0f519456720463403ced6"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/extensions/IERC721Metadata.sol\";\n","imports":["token/ERC721/extensions/IERC721Metadata.sol"],"references":[],"urls":[]},"interfaces/IERC721Receiver.sol":{"checksum":{"algorithm":"md5","hash":"0x04c99e0f7cc521daff42ecd8e8f14877"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721Receiver.sol\";\n","imports":["token/ERC721/IERC721Receiver.sol"],"references":[],"urls":[]},"interfaces/IERC777.sol":{"checksum":{"algorithm":"md5","hash":"0x6009e31d3e8cbdc6831fc5d43e99701c"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC777.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC777/IERC777.sol\";\n","imports":["token/ERC777/IERC777.sol"],"references":[],"urls":[]},"interfaces/IERC777Recipient.sol":{"checksum":{"algorithm":"md5","hash":"0x5cb82721cc0841a27ae151e7f7b268e1"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC777Recipient.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC777/IERC777Recipient.sol\";\n","imports":["token/ERC777/IERC777Recipient.sol"],"references":[],"urls":[]},"interfaces/IERC777Sender.sol":{"checksum":{"algorithm":"md5","hash":"0xe573734b8269ff2e407c505ea6fa4474"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC777Sender.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC777/IERC777Sender.sol\";\n","imports":["token/ERC777/IERC777Sender.sol"],"references":[],"urls":[]},"interfaces/README.adoc":{"checksum":{"algorithm":"md5","hash":"0xdefabf7cc7ca385aa86cbdb1e95bf961"},"content":"= Interfaces\n\n[.readme-notice]\nNOTE: This document is better viewed at https://docs.openzeppelin.com/contracts/api/interfaces\n\n== List of standardized interfaces\nThese interfaces are available as `.sol` files, and also as compiler `.json` ABI files (through the npm package). These\nare useful to interact with third party contracts that implement them.\n\n- {IERC20}\n- {IERC20Metadata}\n- {IERC165}\n- {IERC721}\n- {IERC721Receiver}\n- {IERC721Enumerable}\n- {IERC721Metadata}\n- {IERC777}\n- {IERC777Recipient}\n- {IERC777Sender}\n- {IERC1155}\n- {IERC1155Receiver}\n- {IERC1155MetadataURI}\n- {IERC1271}\n- {IERC1363}\n- {IERC1820Implementer}\n- {IERC1820Registry}\n- {IERC2612}\n- {IERC2981}\n- {IERC3156FlashLender}\n- {IERC3156FlashBorrower}\n\n== Detailed ABI\n\n{{IERC1271}}\n\n{{IERC1363}}\n\n{{IERC1363Receiver}}\n\n{{IERC1820Implementer}}\n\n{{IERC1820Registry}}\n\n{{IERC2612}}\n\n{{IERC2981}}\n\n{{IERC3156FlashLender}}\n\n{{IERC3156FlashBorrower}}\n","imports":[],"references":[],"urls":[]},"interfaces/draft-IERC1822.sol":{"checksum":{"algorithm":"md5","hash":"0x2858d98e74e67987ec81b39605230b74"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n","imports":[],"references":["proxy/ERC1967/ERC1967Upgrade.sol","proxy/utils/UUPSUpgradeable.sol"],"urls":[]},"interfaces/draft-IERC2612.sol":{"checksum":{"algorithm":"md5","hash":"0xad2177bf228c4a10bd94423ed7b1c67a"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/draft-IERC2612.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/extensions/draft-IERC20Permit.sol\";\n\ninterface IERC2612 is IERC20Permit {}\n","imports":["token/ERC20/extensions/draft-IERC20Permit.sol"],"references":[],"urls":[]},"metatx/ERC2771Context.sol":{"checksum":{"algorithm":"md5","hash":"0x21f86a5846802b47da7f6bb6b9ce89d4"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (metatx/ERC2771Context.sol)\n\npragma solidity ^0.8.9;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Context variant with ERC2771 support.\n */\nabstract contract ERC2771Context is Context {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _trustedForwarder;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address trustedForwarder) {\n        _trustedForwarder = trustedForwarder;\n    }\n\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == _trustedForwarder;\n    }\n\n    function _msgSender() internal view virtual override returns (address sender) {\n        if (isTrustedForwarder(msg.sender)) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            /// @solidity memory-safe-assembly\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        if (isTrustedForwarder(msg.sender)) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return super._msgData();\n        }\n    }\n}\n","imports":["utils/Context.sol"],"references":["mocks/ERC2771ContextMock.sol"],"urls":[]},"metatx/MinimalForwarder.sol":{"checksum":{"algorithm":"md5","hash":"0x4ff135bcd937462e4a038835d6381a15"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (metatx/MinimalForwarder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/cryptography/ECDSA.sol\";\nimport \"../utils/cryptography/draft-EIP712.sol\";\n\n/**\n * @dev Simple minimal forwarder to be used together with an ERC2771 compatible contract. See {ERC2771Context}.\n *\n * MinimalForwarder is mainly meant for testing, as it is missing features to be a good production-ready forwarder. This\n * contract does not intend to have all the properties that are needed for a sound forwarding system. A fully\n * functioning forwarding system with good properties requires more complexity. We suggest you look at other projects\n * such as the GSN which do have the goal of building a system like that.\n */\ncontract MinimalForwarder is EIP712 {\n    using ECDSA for bytes32;\n\n    struct ForwardRequest {\n        address from;\n        address to;\n        uint256 value;\n        uint256 gas;\n        uint256 nonce;\n        bytes data;\n    }\n\n    bytes32 private constant _TYPEHASH =\n        keccak256(\"ForwardRequest(address from,address to,uint256 value,uint256 gas,uint256 nonce,bytes data)\");\n\n    mapping(address => uint256) private _nonces;\n\n    constructor() EIP712(\"MinimalForwarder\", \"0.0.1\") {}\n\n    function getNonce(address from) public view returns (uint256) {\n        return _nonces[from];\n    }\n\n    function verify(ForwardRequest calldata req, bytes calldata signature) public view returns (bool) {\n        address signer = _hashTypedDataV4(\n            keccak256(abi.encode(_TYPEHASH, req.from, req.to, req.value, req.gas, req.nonce, keccak256(req.data)))\n        ).recover(signature);\n        return _nonces[req.from] == req.nonce && signer == req.from;\n    }\n\n    function execute(ForwardRequest calldata req, bytes calldata signature)\n        public\n        payable\n        returns (bool, bytes memory)\n    {\n        require(verify(req, signature), \"MinimalForwarder: signature does not match request\");\n        _nonces[req.from] = req.nonce + 1;\n\n        (bool success, bytes memory returndata) = req.to.call{gas: req.gas, value: req.value}(\n            abi.encodePacked(req.data, req.from)\n        );\n\n        // Validate that the relayer has sent enough gas for the call.\n        // See https://ronan.eth.link/blog/ethereum-gas-dangers/\n        if (gasleft() <= req.gas / 63) {\n            // We explicitly trigger invalid opcode to consume all gas and bubble-up the effects, since\n            // neither revert or assert consume all gas since Solidity 0.8.0\n            // https://docs.soliditylang.org/en/v0.8.0/control-structures.html#panic-via-assert-and-error-via-require\n            /// @solidity memory-safe-assembly\n            assembly {\n                invalid()\n            }\n        }\n\n        return (success, returndata);\n    }\n}\n","imports":["utils/cryptography/ECDSA.sol","utils/cryptography/draft-EIP712.sol"],"references":[],"urls":[]},"metatx/README.adoc":{"checksum":{"algorithm":"md5","hash":"0x3a7d438e29c1cd02c5e60db99f0a1b9e"},"content":"= Meta Transactions\n\n[.readme-notice]\nNOTE: This document is better viewed at https://docs.openzeppelin.com/contracts/api/metatx\n\n== Core\n\n{{ERC2771Context}}\n\n== Utils\n\n{{MinimalForwarder}}\n","imports":[],"references":[],"urls":[]},"mocks/AccessControlCrossChainMock.sol":{"checksum":{"algorithm":"md5","hash":"0x98bb1b3324179d8f08715f6c43d12270"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"../access/AccessControlCrossChain.sol\";\nimport \"../crosschain/arbitrum/CrossChainEnabledArbitrumL2.sol\";\n\ncontract AccessControlCrossChainMock is AccessControlCrossChain, CrossChainEnabledArbitrumL2 {\n    constructor() {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    function setRoleAdmin(bytes32 roleId, bytes32 adminRoleId) public {\n        _setRoleAdmin(roleId, adminRoleId);\n    }\n\n    function senderProtected(bytes32 roleId) public onlyRole(roleId) {}\n\n    function crossChainRoleAlias(bytes32 role) public pure virtual returns (bytes32) {\n        return _crossChainRoleAlias(role);\n    }\n}\n","imports":["access/AccessControlCrossChain.sol","crosschain/arbitrum/CrossChainEnabledArbitrumL2.sol"],"references":[],"urls":[]},"mocks/AccessControlEnumerableMock.sol":{"checksum":{"algorithm":"md5","hash":"0x540e353a94b07ea4fc00e8d7c271da65"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../access/AccessControlEnumerable.sol\";\n\ncontract AccessControlEnumerableMock is AccessControlEnumerable {\n    constructor() {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    function setRoleAdmin(bytes32 roleId, bytes32 adminRoleId) public {\n        _setRoleAdmin(roleId, adminRoleId);\n    }\n\n    function senderProtected(bytes32 roleId) public onlyRole(roleId) {}\n}\n","imports":["access/AccessControlEnumerable.sol"],"references":[],"urls":[]},"mocks/AccessControlMock.sol":{"checksum":{"algorithm":"md5","hash":"0x9ab346051c25fc9309e084adc6112888"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../access/AccessControl.sol\";\n\ncontract AccessControlMock is AccessControl {\n    constructor() {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    function setRoleAdmin(bytes32 roleId, bytes32 adminRoleId) public {\n        _setRoleAdmin(roleId, adminRoleId);\n    }\n\n    function senderProtected(bytes32 roleId) public onlyRole(roleId) {}\n}\n","imports":["access/AccessControl.sol"],"references":[],"urls":[]},"mocks/AddressImpl.sol":{"checksum":{"algorithm":"md5","hash":"0x521efadbf907d3700ca7378b35bd0c1b"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Address.sol\";\n\ncontract AddressImpl {\n    string public sharedAnswer;\n\n    event CallReturnValue(string data);\n\n    function isContract(address account) external view returns (bool) {\n        return Address.isContract(account);\n    }\n\n    function sendValue(address payable receiver, uint256 amount) external {\n        Address.sendValue(receiver, amount);\n    }\n\n    function functionCall(address target, bytes calldata data) external {\n        bytes memory returnData = Address.functionCall(target, data);\n        emit CallReturnValue(abi.decode(returnData, (string)));\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes calldata data,\n        uint256 value\n    ) external payable {\n        bytes memory returnData = Address.functionCallWithValue(target, data, value);\n        emit CallReturnValue(abi.decode(returnData, (string)));\n    }\n\n    function functionStaticCall(address target, bytes calldata data) external {\n        bytes memory returnData = Address.functionStaticCall(target, data);\n        emit CallReturnValue(abi.decode(returnData, (string)));\n    }\n\n    function functionDelegateCall(address target, bytes calldata data) external {\n        bytes memory returnData = Address.functionDelegateCall(target, data);\n        emit CallReturnValue(abi.decode(returnData, (string)));\n    }\n\n    // sendValue's tests require the contract to hold Ether\n    receive() external payable {}\n}\n","imports":["utils/Address.sol"],"references":[],"urls":[]},"mocks/ArraysImpl.sol":{"checksum":{"algorithm":"md5","hash":"0x896807a6030108ad8e8872fceca45a48"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Arrays.sol\";\n\ncontract ArraysImpl {\n    using Arrays for uint256[];\n\n    uint256[] private _array;\n\n    constructor(uint256[] memory array) {\n        _array = array;\n    }\n\n    function findUpperBound(uint256 element) external view returns (uint256) {\n        return _array.findUpperBound(element);\n    }\n}\n","imports":["utils/Arrays.sol"],"references":[],"urls":[]},"mocks/BadBeacon.sol":{"checksum":{"algorithm":"md5","hash":"0xd821204fbf5f1e3f73a880bc121d3d5a"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract BadBeaconNoImpl {}\n\ncontract BadBeaconNotContract {\n    function implementation() external pure returns (address) {\n        return address(0x1);\n    }\n}\n","imports":[],"references":[],"urls":[]},"mocks/Base64Mock.sol":{"checksum":{"algorithm":"md5","hash":"0x69a0cb2e8b9813ad82e11b37eace779b"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Base64.sol\";\n\ncontract Base64Mock {\n    function encode(bytes memory value) external pure returns (string memory) {\n        return Base64.encode(value);\n    }\n}\n","imports":["utils/Base64.sol"],"references":[],"urls":[]},"mocks/BitmapMock.sol":{"checksum":{"algorithm":"md5","hash":"0x6144ba9e614894591453591ab6fd3287"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/structs/BitMaps.sol\";\n\ncontract BitMapMock {\n    using BitMaps for BitMaps.BitMap;\n\n    BitMaps.BitMap private _bitmap;\n\n    function get(uint256 index) public view returns (bool) {\n        return _bitmap.get(index);\n    }\n\n    function setTo(uint256 index, bool value) public {\n        _bitmap.setTo(index, value);\n    }\n\n    function set(uint256 index) public {\n        _bitmap.set(index);\n    }\n\n    function unset(uint256 index) public {\n        _bitmap.unset(index);\n    }\n}\n","imports":["utils/structs/BitMaps.sol"],"references":[],"urls":[]},"mocks/CallReceiverMock.sol":{"checksum":{"algorithm":"md5","hash":"0xd8ad0fa6f5cb047fd71030abd436c3d2"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract CallReceiverMock {\n    string public sharedAnswer;\n\n    event MockFunctionCalled();\n    event MockFunctionCalledWithArgs(uint256 a, uint256 b);\n\n    uint256[] private _array;\n\n    function mockFunction() public payable returns (string memory) {\n        emit MockFunctionCalled();\n\n        return \"0x1234\";\n    }\n\n    function mockFunctionWithArgs(uint256 a, uint256 b) public payable returns (string memory) {\n        emit MockFunctionCalledWithArgs(a, b);\n\n        return \"0x1234\";\n    }\n\n    function mockFunctionNonPayable() public returns (string memory) {\n        emit MockFunctionCalled();\n\n        return \"0x1234\";\n    }\n\n    function mockStaticFunction() public pure returns (string memory) {\n        return \"0x1234\";\n    }\n\n    function mockFunctionRevertsNoReason() public payable {\n        revert();\n    }\n\n    function mockFunctionRevertsReason() public payable {\n        revert(\"CallReceiverMock: reverting\");\n    }\n\n    function mockFunctionThrows() public payable {\n        assert(false);\n    }\n\n    function mockFunctionOutOfGas() public payable {\n        for (uint256 i = 0; ; ++i) {\n            _array.push(i);\n        }\n    }\n\n    function mockFunctionWritesStorage() public returns (string memory) {\n        sharedAnswer = \"42\";\n        return \"0x1234\";\n    }\n}\n","imports":[],"references":[],"urls":[]},"mocks/CheckpointsImpl.sol":{"checksum":{"algorithm":"md5","hash":"0x8547b4ee67445ba51b9cfe667b167494"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Checkpoints.sol\";\n\ncontract CheckpointsImpl {\n    using Checkpoints for Checkpoints.History;\n\n    Checkpoints.History private _totalCheckpoints;\n\n    function latest() public view returns (uint256) {\n        return _totalCheckpoints.latest();\n    }\n\n    function getAtBlock(uint256 blockNumber) public view returns (uint256) {\n        return _totalCheckpoints.getAtBlock(blockNumber);\n    }\n\n    function push(uint256 value) public returns (uint256, uint256) {\n        return _totalCheckpoints.push(value);\n    }\n\n    function length() public view returns (uint256) {\n        return _totalCheckpoints._checkpoints.length;\n    }\n}\n","imports":["utils/Checkpoints.sol"],"references":[],"urls":[]},"mocks/ClashingImplementation.sol":{"checksum":{"algorithm":"md5","hash":"0x40774f559f6efe4bb93058b32e680c02"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Implementation contract with an admin() function made to clash with\n * @dev TransparentUpgradeableProxy's to test correct functioning of the\n * @dev Transparent Proxy feature.\n */\ncontract ClashingImplementation {\n    function admin() external pure returns (address) {\n        return 0x0000000000000000000000000000000011111142;\n    }\n\n    function delegatedFunction() external pure returns (bool) {\n        return true;\n    }\n}\n","imports":[],"references":[],"urls":[]},"mocks/ClonesMock.sol":{"checksum":{"algorithm":"md5","hash":"0x3c3d897099214ce6223c577dc55d212c"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../proxy/Clones.sol\";\nimport \"../utils/Address.sol\";\n\ncontract ClonesMock {\n    using Address for address;\n    using Clones for address;\n\n    event NewInstance(address instance);\n\n    function clone(address implementation, bytes calldata initdata) public payable {\n        _initAndEmit(implementation.clone(), initdata);\n    }\n\n    function cloneDeterministic(\n        address implementation,\n        bytes32 salt,\n        bytes calldata initdata\n    ) public payable {\n        _initAndEmit(implementation.cloneDeterministic(salt), initdata);\n    }\n\n    function predictDeterministicAddress(address implementation, bytes32 salt) public view returns (address predicted) {\n        return implementation.predictDeterministicAddress(salt);\n    }\n\n    function _initAndEmit(address instance, bytes memory initdata) private {\n        if (initdata.length > 0) {\n            instance.functionCallWithValue(initdata, msg.value);\n        }\n        emit NewInstance(instance);\n    }\n}\n","imports":["utils/Address.sol","proxy/Clones.sol"],"references":[],"urls":[]},"mocks/ConditionalEscrowMock.sol":{"checksum":{"algorithm":"md5","hash":"0x63b04414ec27ee252e7e7431785f5a63"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/escrow/ConditionalEscrow.sol\";\n\n// mock class using ConditionalEscrow\ncontract ConditionalEscrowMock is ConditionalEscrow {\n    mapping(address => bool) private _allowed;\n\n    function setAllowed(address payee, bool allowed) public {\n        _allowed[payee] = allowed;\n    }\n\n    function withdrawalAllowed(address payee) public view override returns (bool) {\n        return _allowed[payee];\n    }\n}\n","imports":["utils/escrow/ConditionalEscrow.sol"],"references":[],"urls":[]},"mocks/ContextMock.sol":{"checksum":{"algorithm":"md5","hash":"0x719fb67a19e30889dcb3569262f65b85"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\ncontract ContextMock is Context {\n    event Sender(address sender);\n\n    function msgSender() public {\n        emit Sender(_msgSender());\n    }\n\n    event Data(bytes data, uint256 integerValue, string stringValue);\n\n    function msgData(uint256 integerValue, string memory stringValue) public {\n        emit Data(_msgData(), integerValue, stringValue);\n    }\n}\n\ncontract ContextMockCaller {\n    function callSender(ContextMock context) public {\n        context.msgSender();\n    }\n\n    function callData(\n        ContextMock context,\n        uint256 integerValue,\n        string memory stringValue\n    ) public {\n        context.msgData(integerValue, stringValue);\n    }\n}\n","imports":["utils/Context.sol"],"references":["mocks/ERC2771ContextMock.sol"],"urls":[]},"mocks/CountersImpl.sol":{"checksum":{"algorithm":"md5","hash":"0x2446dbf347ba8cbdaedbde8892514a0a"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Counters.sol\";\n\ncontract CountersImpl {\n    using Counters for Counters.Counter;\n\n    Counters.Counter private _counter;\n\n    function current() public view returns (uint256) {\n        return _counter.current();\n    }\n\n    function increment() public {\n        _counter.increment();\n    }\n\n    function decrement() public {\n        _counter.decrement();\n    }\n\n    function reset() public {\n        _counter.reset();\n    }\n}\n","imports":["utils/Counters.sol"],"references":["mocks/UUPS/UUPSUpgradeableMock.sol"],"urls":[]},"mocks/Create2Impl.sol":{"checksum":{"algorithm":"md5","hash":"0xcf00427c363da666d4c3041c48fb3039"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Create2.sol\";\nimport \"../utils/introspection/ERC1820Implementer.sol\";\n\ncontract Create2Impl {\n    function deploy(\n        uint256 value,\n        bytes32 salt,\n        bytes memory code\n    ) public {\n        Create2.deploy(value, salt, code);\n    }\n\n    function deployERC1820Implementer(uint256 value, bytes32 salt) public {\n        Create2.deploy(value, salt, type(ERC1820Implementer).creationCode);\n    }\n\n    function computeAddress(bytes32 salt, bytes32 codeHash) public view returns (address) {\n        return Create2.computeAddress(salt, codeHash);\n    }\n\n    function computeAddressWithDeployer(\n        bytes32 salt,\n        bytes32 codeHash,\n        address deployer\n    ) public pure returns (address) {\n        return Create2.computeAddress(salt, codeHash, deployer);\n    }\n\n    receive() external payable {}\n}\n","imports":["utils/Create2.sol","utils/introspection/ERC1820Implementer.sol"],"references":[],"urls":[]},"mocks/DoubleEndedQueueMock.sol":{"checksum":{"algorithm":"md5","hash":"0x40efb3affb38c5f44d92d97361ffd8ee"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/structs/DoubleEndedQueue.sol\";\n\n// Bytes32Deque\ncontract Bytes32DequeMock {\n    using DoubleEndedQueue for DoubleEndedQueue.Bytes32Deque;\n\n    event OperationResult(bytes32 value);\n\n    DoubleEndedQueue.Bytes32Deque private _vector;\n\n    function pushBack(bytes32 value) public {\n        _vector.pushBack(value);\n    }\n\n    function pushFront(bytes32 value) public {\n        _vector.pushFront(value);\n    }\n\n    function popFront() public returns (bytes32) {\n        bytes32 value = _vector.popFront();\n        emit OperationResult(value);\n        return value;\n    }\n\n    function popBack() public returns (bytes32) {\n        bytes32 value = _vector.popBack();\n        emit OperationResult(value);\n        return value;\n    }\n\n    function front() public view returns (bytes32) {\n        return _vector.front();\n    }\n\n    function back() public view returns (bytes32) {\n        return _vector.back();\n    }\n\n    function at(uint256 i) public view returns (bytes32) {\n        return _vector.at(i);\n    }\n\n    function clear() public {\n        _vector.clear();\n    }\n\n    function length() public view returns (uint256) {\n        return _vector.length();\n    }\n\n    function empty() public view returns (bool) {\n        return _vector.empty();\n    }\n}\n","imports":["utils/structs/DoubleEndedQueue.sol"],"references":[],"urls":[]},"mocks/DummyImplementation.sol":{"checksum":{"algorithm":"md5","hash":"0x23052da0351ecbcd43802845a41fbeef"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nabstract contract Impl {\n    function version() public pure virtual returns (string memory);\n}\n\ncontract DummyImplementation {\n    uint256 public value;\n    string public text;\n    uint256[] public values;\n\n    function initializeNonPayable() public {\n        value = 10;\n    }\n\n    function initializePayable() public payable {\n        value = 100;\n    }\n\n    function initializeNonPayableWithValue(uint256 _value) public {\n        value = _value;\n    }\n\n    function initializePayableWithValue(uint256 _value) public payable {\n        value = _value;\n    }\n\n    function initialize(\n        uint256 _value,\n        string memory _text,\n        uint256[] memory _values\n    ) public {\n        value = _value;\n        text = _text;\n        values = _values;\n    }\n\n    function get() public pure returns (bool) {\n        return true;\n    }\n\n    function version() public pure virtual returns (string memory) {\n        return \"V1\";\n    }\n\n    function reverts() public pure {\n        require(false, \"DummyImplementation reverted\");\n    }\n}\n\ncontract DummyImplementationV2 is DummyImplementation {\n    function migrate(uint256 newVal) public payable {\n        value = newVal;\n    }\n\n    function version() public pure override returns (string memory) {\n        return \"V2\";\n    }\n}\n","imports":[],"references":[],"urls":[]},"mocks/ECDSAMock.sol":{"checksum":{"algorithm":"md5","hash":"0x89ffe0c0ce25a9fa5e5230f3e756908f"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/cryptography/ECDSA.sol\";\n\ncontract ECDSAMock {\n    using ECDSA for bytes32;\n    using ECDSA for bytes;\n\n    function recover(bytes32 hash, bytes memory signature) public pure returns (address) {\n        return hash.recover(signature);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function recover_v_r_s(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public pure returns (address) {\n        return hash.recover(v, r, s);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function recover_r_vs(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) public pure returns (address) {\n        return hash.recover(r, vs);\n    }\n\n    function toEthSignedMessageHash(bytes32 hash) public pure returns (bytes32) {\n        return hash.toEthSignedMessageHash();\n    }\n\n    function toEthSignedMessageHash(bytes memory s) public pure returns (bytes32) {\n        return s.toEthSignedMessageHash();\n    }\n}\n","imports":["utils/cryptography/ECDSA.sol"],"references":[],"urls":[]},"mocks/EIP712External.sol":{"checksum":{"algorithm":"md5","hash":"0xf3ce57602b397d603d1ab47a289cd8c9"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/cryptography/draft-EIP712.sol\";\nimport \"../utils/cryptography/ECDSA.sol\";\n\ncontract EIP712External is EIP712 {\n    constructor(string memory name, string memory version) EIP712(name, version) {}\n\n    function domainSeparator() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    function verify(\n        bytes memory signature,\n        address signer,\n        address mailTo,\n        string memory mailContents\n    ) external view {\n        bytes32 digest = _hashTypedDataV4(\n            keccak256(abi.encode(keccak256(\"Mail(address to,string contents)\"), mailTo, keccak256(bytes(mailContents))))\n        );\n        address recoveredSigner = ECDSA.recover(digest, signature);\n        require(recoveredSigner == signer);\n    }\n\n    function getChainId() external view returns (uint256) {\n        return block.chainid;\n    }\n}\n","imports":["utils/cryptography/ECDSA.sol","utils/cryptography/draft-EIP712.sol"],"references":[],"urls":[]},"mocks/ERC1155BurnableMock.sol":{"checksum":{"algorithm":"md5","hash":"0x81d86936cc90a2e9aef2539052e7bc42"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC1155/extensions/ERC1155Burnable.sol\";\n\ncontract ERC1155BurnableMock is ERC1155Burnable {\n    constructor(string memory uri) ERC1155(uri) {}\n\n    function mint(\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) public {\n        _mint(to, id, value, data);\n    }\n}\n","imports":["token/ERC1155/extensions/ERC1155Burnable.sol"],"references":[],"urls":[]},"mocks/ERC1155Mock.sol":{"checksum":{"algorithm":"md5","hash":"0x1be5f5c78217fb35b62f121b7d62296c"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC1155/ERC1155.sol\";\n\n/**\n * @title ERC1155Mock\n * This mock just publicizes internal functions for testing purposes\n */\ncontract ERC1155Mock is ERC1155 {\n    constructor(string memory uri) ERC1155(uri) {}\n\n    function setURI(string memory newuri) public {\n        _setURI(newuri);\n    }\n\n    function mint(\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) public {\n        _mint(to, id, value, data);\n    }\n\n    function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) public {\n        _mintBatch(to, ids, values, data);\n    }\n\n    function burn(\n        address owner,\n        uint256 id,\n        uint256 value\n    ) public {\n        _burn(owner, id, value);\n    }\n\n    function burnBatch(\n        address owner,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public {\n        _burnBatch(owner, ids, values);\n    }\n}\n","imports":["token/ERC1155/ERC1155.sol"],"references":["mocks/ERC1155URIStorageMock.sol","mocks/ERC1155SupplyMock.sol","mocks/ERC1155PausableMock.sol"],"urls":[]},"mocks/ERC1155PausableMock.sol":{"checksum":{"algorithm":"md5","hash":"0x5d635e73b1a90f2c04feefb8faa919b4"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155Mock.sol\";\nimport \"../token/ERC1155/extensions/ERC1155Pausable.sol\";\n\ncontract ERC1155PausableMock is ERC1155Mock, ERC1155Pausable {\n    constructor(string memory uri) ERC1155Mock(uri) {}\n\n    function pause() external {\n        _pause();\n    }\n\n    function unpause() external {\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override(ERC1155, ERC1155Pausable) {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n}\n","imports":["mocks/ERC1155Mock.sol","token/ERC1155/extensions/ERC1155Pausable.sol"],"references":[],"urls":[]},"mocks/ERC1155ReceiverMock.sol":{"checksum":{"algorithm":"md5","hash":"0x509f8265587db2c555344f91e2fe5b1d"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC1155/IERC1155Receiver.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\ncontract ERC1155ReceiverMock is ERC165, IERC1155Receiver {\n    bytes4 private _recRetval;\n    bool private _recReverts;\n    bytes4 private _batRetval;\n    bool private _batReverts;\n\n    event Received(address operator, address from, uint256 id, uint256 value, bytes data, uint256 gas);\n    event BatchReceived(address operator, address from, uint256[] ids, uint256[] values, bytes data, uint256 gas);\n\n    constructor(\n        bytes4 recRetval,\n        bool recReverts,\n        bytes4 batRetval,\n        bool batReverts\n    ) {\n        _recRetval = recRetval;\n        _recReverts = recReverts;\n        _batRetval = batRetval;\n        _batReverts = batReverts;\n    }\n\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external override returns (bytes4) {\n        require(!_recReverts, \"ERC1155ReceiverMock: reverting on receive\");\n        emit Received(operator, from, id, value, data, gasleft());\n        return _recRetval;\n    }\n\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external override returns (bytes4) {\n        require(!_batReverts, \"ERC1155ReceiverMock: reverting on batch receive\");\n        emit BatchReceived(operator, from, ids, values, data, gasleft());\n        return _batRetval;\n    }\n}\n","imports":["token/ERC1155/IERC1155Receiver.sol","utils/introspection/ERC165.sol"],"references":[],"urls":[]},"mocks/ERC1155SupplyMock.sol":{"checksum":{"algorithm":"md5","hash":"0xb34aa207d4814d7f3e659955620b936c"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155Mock.sol\";\nimport \"../token/ERC1155/extensions/ERC1155Supply.sol\";\n\ncontract ERC1155SupplyMock is ERC1155Mock, ERC1155Supply {\n    constructor(string memory uri) ERC1155Mock(uri) {}\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override(ERC1155, ERC1155Supply) {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n}\n","imports":["mocks/ERC1155Mock.sol","token/ERC1155/extensions/ERC1155Supply.sol"],"references":[],"urls":[]},"mocks/ERC1155URIStorageMock.sol":{"checksum":{"algorithm":"md5","hash":"0x277d177cc39f3e1aa3801eddc8d86d44"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155Mock.sol\";\nimport \"../token/ERC1155/extensions/ERC1155URIStorage.sol\";\n\ncontract ERC1155URIStorageMock is ERC1155Mock, ERC1155URIStorage {\n    constructor(string memory _uri) ERC1155Mock(_uri) {}\n\n    function uri(uint256 tokenId) public view virtual override(ERC1155, ERC1155URIStorage) returns (string memory) {\n        return ERC1155URIStorage.uri(tokenId);\n    }\n\n    function setURI(uint256 tokenId, string memory _tokenURI) public {\n        _setURI(tokenId, _tokenURI);\n    }\n\n    function setBaseURI(string memory baseURI) public {\n        _setBaseURI(baseURI);\n    }\n}\n","imports":["mocks/ERC1155Mock.sol","token/ERC1155/extensions/ERC1155URIStorage.sol"],"references":[],"urls":[]},"mocks/ERC1271WalletMock.sol":{"checksum":{"algorithm":"md5","hash":"0x918863d96faa1e17cd245dfaf23ac786"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../access/Ownable.sol\";\nimport \"../interfaces/IERC1271.sol\";\nimport \"../utils/cryptography/ECDSA.sol\";\n\ncontract ERC1271WalletMock is Ownable, IERC1271 {\n    constructor(address originalOwner) {\n        transferOwnership(originalOwner);\n    }\n\n    function isValidSignature(bytes32 hash, bytes memory signature) public view override returns (bytes4 magicValue) {\n        return ECDSA.recover(hash, signature) == owner() ? this.isValidSignature.selector : bytes4(0);\n    }\n}\n\ncontract ERC1271MaliciousMock is IERC1271 {\n    function isValidSignature(bytes32, bytes memory) public pure override returns (bytes4) {\n        assembly {\n            mstore(0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            return(0, 32)\n        }\n    }\n}\n","imports":["utils/cryptography/ECDSA.sol","interfaces/IERC1271.sol","access/Ownable.sol"],"references":[],"urls":[]},"mocks/ERC165/ERC165InterfacesSupported.sol":{"checksum":{"algorithm":"md5","hash":"0x782e9abe56260a34233eca2d838a5086"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * https://eips.ethereum.org/EIPS/eip-214#specification\n * From the specification:\n * > Any attempts to make state-changing operations inside an execution instance with STATIC set to true will instead\n * throw an exception.\n * > These operations include [...], LOG0, LOG1, LOG2, [...]\n *\n * therefore, because this contract is staticcall'd we need to not emit events (which is how solidity-coverage works)\n * solidity-coverage ignores the /mocks folder, so we duplicate its implementation here to avoid instrumenting it\n */\ncontract SupportsInterfaceWithLookupMock is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 public constant INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev A mapping of interface id to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    /**\n     * @dev A contract implementing SupportsInterfaceWithLookup\n     * implement ERC165 itself.\n     */\n    constructor() {\n        _registerInterface(INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev Implement supportsInterface(bytes4) using a lookup table.\n     */\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Private method for registering an interface.\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff, \"ERC165InterfacesSupported: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\ncontract ERC165InterfacesSupported is SupportsInterfaceWithLookupMock {\n    constructor(bytes4[] memory interfaceIds) {\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            _registerInterface(interfaceIds[i]);\n        }\n    }\n}\n","imports":["utils/introspection/IERC165.sol"],"references":[],"urls":[]},"mocks/ERC165/ERC165MaliciousData.sol":{"checksum":{"algorithm":"md5","hash":"0x57347d0a13deb819501f581bd0655145"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract ERC165MaliciousData {\n    function supportsInterface(bytes4) public view returns (bool) {\n        assembly {\n            mstore(0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            return(0, 32)\n        }\n    }\n}\n","imports":[],"references":[],"urls":[]},"mocks/ERC165/ERC165MissingData.sol":{"checksum":{"algorithm":"md5","hash":"0xf7a435a8acb3f5f0bcf2c8aa87a6ab6b"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract ERC165MissingData {\n    function supportsInterface(bytes4 interfaceId) public view {} // missing return\n}\n","imports":[],"references":[],"urls":[]},"mocks/ERC165/ERC165NotSupported.sol":{"checksum":{"algorithm":"md5","hash":"0x3d6acaa746a431a94963bccd84b1ef76"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract ERC165NotSupported {}\n","imports":[],"references":[],"urls":[]},"mocks/ERC165CheckerMock.sol":{"checksum":{"algorithm":"md5","hash":"0x185db21182a9486960b8c9368cc69573"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/ERC165Checker.sol\";\n\ncontract ERC165CheckerMock {\n    using ERC165Checker for address;\n\n    function supportsERC165(address account) public view returns (bool) {\n        return account.supportsERC165();\n    }\n\n    function supportsInterface(address account, bytes4 interfaceId) public view returns (bool) {\n        return account.supportsInterface(interfaceId);\n    }\n\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) public view returns (bool) {\n        return account.supportsAllInterfaces(interfaceIds);\n    }\n\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds) public view returns (bool[] memory) {\n        return account.getSupportedInterfaces(interfaceIds);\n    }\n}\n","imports":["utils/introspection/ERC165Checker.sol"],"references":[],"urls":[]},"mocks/ERC165Mock.sol":{"checksum":{"algorithm":"md5","hash":"0x4af581ea8aa2c8845c950d764f220b26"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/ERC165.sol\";\n\ncontract ERC165Mock is ERC165 {}\n","imports":["utils/introspection/ERC165.sol"],"references":[],"urls":[]},"mocks/ERC165StorageMock.sol":{"checksum":{"algorithm":"md5","hash":"0x5e1f7907867ff274418400e6a41d38a7"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/ERC165Storage.sol\";\n\ncontract ERC165StorageMock is ERC165Storage {\n    function registerInterface(bytes4 interfaceId) public {\n        _registerInterface(interfaceId);\n    }\n}\n","imports":["utils/introspection/ERC165Storage.sol"],"references":[],"urls":[]},"mocks/ERC1820ImplementerMock.sol":{"checksum":{"algorithm":"md5","hash":"0x932975c1e28f595457f9621603c95220"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/ERC1820Implementer.sol\";\n\ncontract ERC1820ImplementerMock is ERC1820Implementer {\n    function registerInterfaceForAddress(bytes32 interfaceHash, address account) public {\n        _registerInterfaceForAddress(interfaceHash, account);\n    }\n}\n","imports":["utils/introspection/ERC1820Implementer.sol"],"references":[],"urls":[]},"mocks/ERC20BurnableMock.sol":{"checksum":{"algorithm":"md5","hash":"0x16c0c062fb93e0fc7c60061c16e198bc"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/extensions/ERC20Burnable.sol\";\n\ncontract ERC20BurnableMock is ERC20Burnable {\n    constructor(\n        string memory name,\n        string memory symbol,\n        address initialAccount,\n        uint256 initialBalance\n    ) ERC20(name, symbol) {\n        _mint(initialAccount, initialBalance);\n    }\n}\n","imports":["token/ERC20/extensions/ERC20Burnable.sol"],"references":[],"urls":[]},"mocks/ERC20CappedMock.sol":{"checksum":{"algorithm":"md5","hash":"0x02c66aea2a7fd9cc8807fa7bfcd1f41f"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/extensions/ERC20Capped.sol\";\n\ncontract ERC20CappedMock is ERC20Capped {\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 cap\n    ) ERC20(name, symbol) ERC20Capped(cap) {}\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n}\n","imports":["token/ERC20/extensions/ERC20Capped.sol"],"references":[],"urls":[]},"mocks/ERC20DecimalsMock.sol":{"checksum":{"algorithm":"md5","hash":"0x5c6681a1c77679d6774b9de58cf5e5d5"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/ERC20.sol\";\n\ncontract ERC20DecimalsMock is ERC20 {\n    uint8 private immutable _decimals;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20(name_, symbol_) {\n        _decimals = decimals_;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    function mint(address account, uint256 amount) public {\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n    }\n}\n","imports":["token/ERC20/ERC20.sol"],"references":[],"urls":[]},"mocks/ERC20FlashMintMock.sol":{"checksum":{"algorithm":"md5","hash":"0x8c818089aee980b51e413f73bfb1433f"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/extensions/ERC20FlashMint.sol\";\n\ncontract ERC20FlashMintMock is ERC20FlashMint {\n    uint256 _flashFeeAmount;\n    address _flashFeeReceiverAddress;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        address initialAccount,\n        uint256 initialBalance\n    ) ERC20(name, symbol) {\n        _mint(initialAccount, initialBalance);\n    }\n\n    function mint(address account, uint256 amount) public {\n        _mint(account, amount);\n    }\n\n    function setFlashFee(uint256 amount) public {\n        _flashFeeAmount = amount;\n    }\n\n    function flashFee(address token, uint256 amount) public view virtual override returns (uint256) {\n        super.flashFee(token, amount);\n        return _flashFeeAmount;\n    }\n\n    function setFlashFeeReceiver(address receiver) public {\n        _flashFeeReceiverAddress = receiver;\n    }\n\n    function flashFeeReceiver() public view returns (address) {\n        return _flashFeeReceiver();\n    }\n\n    function _flashFeeReceiver() internal view override returns (address) {\n        return _flashFeeReceiverAddress;\n    }\n}\n","imports":["token/ERC20/extensions/ERC20FlashMint.sol"],"references":[],"urls":[]},"mocks/ERC20Mock.sol":{"checksum":{"algorithm":"md5","hash":"0xafadd2df2b3d63aa4d0f8180932b7b73"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/ERC20.sol\";\n\n// mock class using ERC20\ncontract ERC20Mock is ERC20 {\n    constructor(\n        string memory name,\n        string memory symbol,\n        address initialAccount,\n        uint256 initialBalance\n    ) payable ERC20(name, symbol) {\n        _mint(initialAccount, initialBalance);\n    }\n\n    function mint(address account, uint256 amount) public {\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n    }\n\n    function transferInternal(\n        address from,\n        address to,\n        uint256 value\n    ) public {\n        _transfer(from, to, value);\n    }\n\n    function approveInternal(\n        address owner,\n        address spender,\n        uint256 value\n    ) public {\n        _approve(owner, spender, value);\n    }\n}\n","imports":["token/ERC20/ERC20.sol"],"references":["mocks/MulticallTokenMock.sol"],"urls":[]},"mocks/ERC20PausableMock.sol":{"checksum":{"algorithm":"md5","hash":"0x751b5341b45a270abb1629777a9624ac"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/extensions/ERC20Pausable.sol\";\n\n// mock class using ERC20Pausable\ncontract ERC20PausableMock is ERC20Pausable {\n    constructor(\n        string memory name,\n        string memory symbol,\n        address initialAccount,\n        uint256 initialBalance\n    ) ERC20(name, symbol) {\n        _mint(initialAccount, initialBalance);\n    }\n\n    function pause() external {\n        _pause();\n    }\n\n    function unpause() external {\n        _unpause();\n    }\n\n    function mint(address to, uint256 amount) public {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) public {\n        _burn(from, amount);\n    }\n}\n","imports":["token/ERC20/extensions/ERC20Pausable.sol"],"references":[],"urls":[]},"mocks/ERC20PermitMock.sol":{"checksum":{"algorithm":"md5","hash":"0x0e343f28085a0e6583aae67dd967ccce"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/extensions/draft-ERC20Permit.sol\";\n\ncontract ERC20PermitMock is ERC20Permit {\n    constructor(\n        string memory name,\n        string memory symbol,\n        address initialAccount,\n        uint256 initialBalance\n    ) payable ERC20(name, symbol) ERC20Permit(name) {\n        _mint(initialAccount, initialBalance);\n    }\n\n    function getChainId() external view returns (uint256) {\n        return block.chainid;\n    }\n}\n","imports":["token/ERC20/extensions/draft-ERC20Permit.sol"],"references":[],"urls":[]},"mocks/ERC20SnapshotMock.sol":{"checksum":{"algorithm":"md5","hash":"0xd1c6ab468983add875049a57a5485e77"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/extensions/ERC20Snapshot.sol\";\n\ncontract ERC20SnapshotMock is ERC20Snapshot {\n    constructor(\n        string memory name,\n        string memory symbol,\n        address initialAccount,\n        uint256 initialBalance\n    ) ERC20(name, symbol) {\n        _mint(initialAccount, initialBalance);\n    }\n\n    function snapshot() public {\n        _snapshot();\n    }\n\n    function mint(address account, uint256 amount) public {\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n    }\n}\n","imports":["token/ERC20/extensions/ERC20Snapshot.sol"],"references":[],"urls":[]},"mocks/ERC20VotesCompMock.sol":{"checksum":{"algorithm":"md5","hash":"0xd5feb91e29eb503d3401af62d360be04"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/extensions/ERC20VotesComp.sol\";\n\ncontract ERC20VotesCompMock is ERC20VotesComp {\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) ERC20Permit(name) {}\n\n    function mint(address account, uint256 amount) public {\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n    }\n\n    function getChainId() external view returns (uint256) {\n        return block.chainid;\n    }\n}\n","imports":["token/ERC20/extensions/ERC20VotesComp.sol"],"references":[],"urls":[]},"mocks/ERC20VotesMock.sol":{"checksum":{"algorithm":"md5","hash":"0x053434c5bb49ac564e581ceb1181b7e1"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/extensions/ERC20Votes.sol\";\n\ncontract ERC20VotesMock is ERC20Votes {\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) ERC20Permit(name) {}\n\n    function mint(address account, uint256 amount) public {\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n    }\n\n    function getChainId() external view returns (uint256) {\n        return block.chainid;\n    }\n}\n","imports":["token/ERC20/extensions/ERC20Votes.sol"],"references":[],"urls":[]},"mocks/ERC20WrapperMock.sol":{"checksum":{"algorithm":"md5","hash":"0xe2d41de561bf9c27cc7c68f5fbbf9fa9"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/extensions/ERC20Wrapper.sol\";\n\ncontract ERC20WrapperMock is ERC20Wrapper {\n    constructor(\n        IERC20 _underlyingToken,\n        string memory name,\n        string memory symbol\n    ) ERC20(name, symbol) ERC20Wrapper(_underlyingToken) {}\n\n    function recover(address account) public returns (uint256) {\n        return _recover(account);\n    }\n}\n","imports":["token/ERC20/extensions/ERC20Wrapper.sol"],"references":[],"urls":[]},"mocks/ERC2771ContextMock.sol":{"checksum":{"algorithm":"md5","hash":"0x60d502d8706ff64a4754cbcca07f570f"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ContextMock.sol\";\nimport \"../metatx/ERC2771Context.sol\";\n\n// By inheriting from ERC2771Context, Context's internal functions are overridden automatically\ncontract ERC2771ContextMock is ContextMock, ERC2771Context {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {\n        emit Sender(_msgSender()); // _msgSender() should be accessible during construction\n    }\n\n    function _msgSender() internal view virtual override(Context, ERC2771Context) returns (address) {\n        return ERC2771Context._msgSender();\n    }\n\n    function _msgData() internal view virtual override(Context, ERC2771Context) returns (bytes calldata) {\n        return ERC2771Context._msgData();\n    }\n}\n","imports":["metatx/ERC2771Context.sol","mocks/ContextMock.sol"],"references":[],"urls":[]},"mocks/ERC3156FlashBorrowerMock.sol":{"checksum":{"algorithm":"md5","hash":"0xf5aaafe8ca151fca303734ce7c7ba8ce"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\nimport \"../interfaces/IERC3156.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n * @dev WARNING: this IERC3156FlashBorrower mock implementation is for testing purposes ONLY.\n * Writing a secure flash lock borrower is not an easy task, and should be done with the utmost care.\n * This is not an example of how it should be done, and no pattern present in this mock should be considered secure.\n * Following best practices, always have your contract properly audited before using them to manipulate important funds on\n * live networks.\n */\ncontract ERC3156FlashBorrowerMock is IERC3156FlashBorrower {\n    bytes32 internal constant _RETURN_VALUE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    bool immutable _enableApprove;\n    bool immutable _enableReturn;\n\n    event BalanceOf(address token, address account, uint256 value);\n    event TotalSupply(address token, uint256 value);\n\n    constructor(bool enableReturn, bool enableApprove) {\n        _enableApprove = enableApprove;\n        _enableReturn = enableReturn;\n    }\n\n    function onFlashLoan(\n        address, /*initiator*/\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) public override returns (bytes32) {\n        require(msg.sender == token);\n\n        emit BalanceOf(token, address(this), IERC20(token).balanceOf(address(this)));\n        emit TotalSupply(token, IERC20(token).totalSupply());\n\n        if (data.length > 0) {\n            // WARNING: This code is for testing purposes only! Do not use.\n            Address.functionCall(token, data);\n        }\n\n        if (_enableApprove) {\n            IERC20(token).approve(token, amount + fee);\n        }\n\n        return _enableReturn ? _RETURN_VALUE : bytes32(0);\n    }\n}\n","imports":["token/ERC20/IERC20.sol","utils/Address.sol","interfaces/IERC3156.sol"],"references":[],"urls":[]},"mocks/ERC4626Mock.sol":{"checksum":{"algorithm":"md5","hash":"0xe6e5dfc6bbb30ed112970b332d012505"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/extensions/ERC4626.sol\";\n\n// mock class using ERC20\ncontract ERC4626Mock is ERC4626 {\n    constructor(\n        IERC20Metadata asset,\n        string memory name,\n        string memory symbol\n    ) ERC20(name, symbol) ERC4626(asset) {}\n\n    function mockMint(address account, uint256 amount) public {\n        _mint(account, amount);\n    }\n\n    function mockBurn(address account, uint256 amount) public {\n        _burn(account, amount);\n    }\n}\n","imports":["token/ERC20/extensions/ERC4626.sol"],"references":[],"urls":[]},"mocks/ERC721BurnableMock.sol":{"checksum":{"algorithm":"md5","hash":"0x4341e54dc10a462272be888db0ae01c4"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/extensions/ERC721Burnable.sol\";\n\ncontract ERC721BurnableMock is ERC721Burnable {\n    constructor(string memory name, string memory symbol) ERC721(name, symbol) {}\n\n    function exists(uint256 tokenId) public view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public {\n        _safeMint(to, tokenId);\n    }\n\n    function safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public {\n        _safeMint(to, tokenId, _data);\n    }\n}\n","imports":["token/ERC721/extensions/ERC721Burnable.sol"],"references":[],"urls":[]},"mocks/ERC721EnumerableMock.sol":{"checksum":{"algorithm":"md5","hash":"0x574df2bb6f3a5ddc7332729e496ac01b"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/extensions/ERC721Enumerable.sol\";\n\n/**\n * @title ERC721Mock\n * This mock just provides a public safeMint, mint, and burn functions for testing purposes\n */\ncontract ERC721EnumerableMock is ERC721Enumerable {\n    string private _baseTokenURI;\n\n    constructor(string memory name, string memory symbol) ERC721(name, symbol) {}\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseTokenURI;\n    }\n\n    function setBaseURI(string calldata newBaseTokenURI) public {\n        _baseTokenURI = newBaseTokenURI;\n    }\n\n    function baseURI() public view returns (string memory) {\n        return _baseURI();\n    }\n\n    function exists(uint256 tokenId) public view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public {\n        _safeMint(to, tokenId);\n    }\n\n    function safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public {\n        _safeMint(to, tokenId, _data);\n    }\n\n    function burn(uint256 tokenId) public {\n        _burn(tokenId);\n    }\n}\n","imports":["token/ERC721/extensions/ERC721Enumerable.sol"],"references":[],"urls":[]},"mocks/ERC721Mock.sol":{"checksum":{"algorithm":"md5","hash":"0x777ca2a3777630c7bec2e6dbc9b7055b"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/ERC721.sol\";\n\n/**\n * @title ERC721Mock\n * This mock just provides a public safeMint, mint, and burn functions for testing purposes\n */\ncontract ERC721Mock is ERC721 {\n    constructor(string memory name, string memory symbol) ERC721(name, symbol) {}\n\n    function baseURI() public view returns (string memory) {\n        return _baseURI();\n    }\n\n    function exists(uint256 tokenId) public view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public {\n        _safeMint(to, tokenId);\n    }\n\n    function safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public {\n        _safeMint(to, tokenId, _data);\n    }\n\n    function burn(uint256 tokenId) public {\n        _burn(tokenId);\n    }\n}\n","imports":["token/ERC721/ERC721.sol"],"references":[],"urls":[]},"mocks/ERC721PausableMock.sol":{"checksum":{"algorithm":"md5","hash":"0xd956d419d6d9abff2fb0fbcb14f5bdae"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/extensions/ERC721Pausable.sol\";\n\n/**\n * @title ERC721PausableMock\n * This mock just provides a public mint, burn and exists functions for testing purposes\n */\ncontract ERC721PausableMock is ERC721Pausable {\n    constructor(string memory name, string memory symbol) ERC721(name, symbol) {}\n\n    function pause() external {\n        _pause();\n    }\n\n    function unpause() external {\n        _unpause();\n    }\n\n    function exists(uint256 tokenId) public view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public {\n        _safeMint(to, tokenId);\n    }\n\n    function safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public {\n        _safeMint(to, tokenId, _data);\n    }\n\n    function burn(uint256 tokenId) public {\n        _burn(tokenId);\n    }\n}\n","imports":["token/ERC721/extensions/ERC721Pausable.sol"],"references":[],"urls":[]},"mocks/ERC721ReceiverMock.sol":{"checksum":{"algorithm":"md5","hash":"0x6a446429aabded16b45d40ebbbb7f672"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721Receiver.sol\";\n\ncontract ERC721ReceiverMock is IERC721Receiver {\n    enum Error {\n        None,\n        RevertWithMessage,\n        RevertWithoutMessage,\n        Panic\n    }\n\n    bytes4 private immutable _retval;\n    Error private immutable _error;\n\n    event Received(address operator, address from, uint256 tokenId, bytes data, uint256 gas);\n\n    constructor(bytes4 retval, Error error) {\n        _retval = retval;\n        _error = error;\n    }\n\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes memory data\n    ) public override returns (bytes4) {\n        if (_error == Error.RevertWithMessage) {\n            revert(\"ERC721ReceiverMock: reverting\");\n        } else if (_error == Error.RevertWithoutMessage) {\n            revert();\n        } else if (_error == Error.Panic) {\n            uint256 a = uint256(0) / uint256(0);\n            a;\n        }\n        emit Received(operator, from, tokenId, data, gasleft());\n        return _retval;\n    }\n}\n","imports":["token/ERC721/IERC721Receiver.sol"],"references":[],"urls":[]},"mocks/ERC721RoyaltyMock.sol":{"checksum":{"algorithm":"md5","hash":"0x28b7cbbe21cc6c764fd24e88c85d306a"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/extensions/ERC721Royalty.sol\";\n\ncontract ERC721RoyaltyMock is ERC721Royalty {\n    constructor(string memory name, string memory symbol) ERC721(name, symbol) {}\n\n    function setTokenRoyalty(\n        uint256 tokenId,\n        address recipient,\n        uint96 fraction\n    ) public {\n        _setTokenRoyalty(tokenId, recipient, fraction);\n    }\n\n    function setDefaultRoyalty(address recipient, uint96 fraction) public {\n        _setDefaultRoyalty(recipient, fraction);\n    }\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n\n    function burn(uint256 tokenId) public {\n        _burn(tokenId);\n    }\n\n    function deleteDefaultRoyalty() public {\n        _deleteDefaultRoyalty();\n    }\n}\n","imports":["token/ERC721/extensions/ERC721Royalty.sol"],"references":[],"urls":[]},"mocks/ERC721URIStorageMock.sol":{"checksum":{"algorithm":"md5","hash":"0x49af10a60f7b5cf77c322f7c002eca81"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/extensions/ERC721URIStorage.sol\";\n\n/**\n * @title ERC721Mock\n * This mock just provides a public safeMint, mint, and burn functions for testing purposes\n */\ncontract ERC721URIStorageMock is ERC721URIStorage {\n    string private _baseTokenURI;\n\n    constructor(string memory name, string memory symbol) ERC721(name, symbol) {}\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseTokenURI;\n    }\n\n    function setBaseURI(string calldata newBaseTokenURI) public {\n        _baseTokenURI = newBaseTokenURI;\n    }\n\n    function baseURI() public view returns (string memory) {\n        return _baseURI();\n    }\n\n    function setTokenURI(uint256 tokenId, string memory _tokenURI) public {\n        _setTokenURI(tokenId, _tokenURI);\n    }\n\n    function exists(uint256 tokenId) public view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public {\n        _safeMint(to, tokenId);\n    }\n\n    function safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public {\n        _safeMint(to, tokenId, _data);\n    }\n\n    function burn(uint256 tokenId) public {\n        _burn(tokenId);\n    }\n}\n","imports":["token/ERC721/extensions/ERC721URIStorage.sol"],"references":[],"urls":[]},"mocks/ERC721VotesMock.sol":{"checksum":{"algorithm":"md5","hash":"0x51c578f7664980755d8dbf705b965998"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/extensions/draft-ERC721Votes.sol\";\n\ncontract ERC721VotesMock is ERC721Votes {\n    constructor(string memory name, string memory symbol) ERC721(name, symbol) EIP712(name, \"1\") {}\n\n    function getTotalSupply() public view returns (uint256) {\n        return _getTotalSupply();\n    }\n\n    function mint(address account, uint256 tokenId) public {\n        _mint(account, tokenId);\n    }\n\n    function burn(uint256 tokenId) public {\n        _burn(tokenId);\n    }\n\n    function getChainId() external view returns (uint256) {\n        return block.chainid;\n    }\n}\n","imports":["token/ERC721/extensions/draft-ERC721Votes.sol"],"references":[],"urls":[]},"mocks/ERC777Mock.sol":{"checksum":{"algorithm":"md5","hash":"0x3264b51fb51450bf75d97ae95835fc72"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\nimport \"../token/ERC777/ERC777.sol\";\n\ncontract ERC777Mock is Context, ERC777 {\n    event BeforeTokenTransfer();\n\n    constructor(\n        address initialHolder,\n        uint256 initialBalance,\n        string memory name,\n        string memory symbol,\n        address[] memory defaultOperators\n    ) ERC777(name, symbol, defaultOperators) {\n        _mint(initialHolder, initialBalance, \"\", \"\");\n    }\n\n    function mintInternal(\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) public {\n        _mint(to, amount, userData, operatorData);\n    }\n\n    function mintInternalExtended(\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    ) public {\n        _mint(to, amount, userData, operatorData, requireReceptionAck);\n    }\n\n    function approveInternal(\n        address holder,\n        address spender,\n        uint256 value\n    ) public {\n        _approve(holder, spender, value);\n    }\n\n    function _beforeTokenTransfer(\n        address,\n        address,\n        address,\n        uint256\n    ) internal override {\n        emit BeforeTokenTransfer();\n    }\n}\n","imports":["utils/Context.sol","token/ERC777/ERC777.sol"],"references":[],"urls":[]},"mocks/ERC777SenderRecipientMock.sol":{"checksum":{"algorithm":"md5","hash":"0x4d1d27e77d4d1c8ac900d7f5a145bd22"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC777/IERC777.sol\";\nimport \"../token/ERC777/IERC777Sender.sol\";\nimport \"../token/ERC777/IERC777Recipient.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/introspection/IERC1820Registry.sol\";\nimport \"../utils/introspection/ERC1820Implementer.sol\";\n\ncontract ERC777SenderRecipientMock is Context, IERC777Sender, IERC777Recipient, ERC1820Implementer {\n    event TokensToSendCalled(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData,\n        address token,\n        uint256 fromBalance,\n        uint256 toBalance\n    );\n\n    event TokensReceivedCalled(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData,\n        address token,\n        uint256 fromBalance,\n        uint256 toBalance\n    );\n\n    // Emitted in ERC777Mock. Here for easier decoding\n    event BeforeTokenTransfer();\n\n    bool private _shouldRevertSend;\n    bool private _shouldRevertReceive;\n\n    IERC1820Registry private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n    bytes32 private constant _TOKENS_SENDER_INTERFACE_HASH = keccak256(\"ERC777TokensSender\");\n    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(\"ERC777TokensRecipient\");\n\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external override {\n        if (_shouldRevertSend) {\n            revert();\n        }\n\n        IERC777 token = IERC777(_msgSender());\n\n        uint256 fromBalance = token.balanceOf(from);\n        // when called due to burn, to will be the zero address, which will have a balance of 0\n        uint256 toBalance = token.balanceOf(to);\n\n        emit TokensToSendCalled(\n            operator,\n            from,\n            to,\n            amount,\n            userData,\n            operatorData,\n            address(token),\n            fromBalance,\n            toBalance\n        );\n    }\n\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external override {\n        if (_shouldRevertReceive) {\n            revert();\n        }\n\n        IERC777 token = IERC777(_msgSender());\n\n        uint256 fromBalance = token.balanceOf(from);\n        // when called due to burn, to will be the zero address, which will have a balance of 0\n        uint256 toBalance = token.balanceOf(to);\n\n        emit TokensReceivedCalled(\n            operator,\n            from,\n            to,\n            amount,\n            userData,\n            operatorData,\n            address(token),\n            fromBalance,\n            toBalance\n        );\n    }\n\n    function senderFor(address account) public {\n        _registerInterfaceForAddress(_TOKENS_SENDER_INTERFACE_HASH, account);\n\n        address self = address(this);\n        if (account == self) {\n            registerSender(self);\n        }\n    }\n\n    function registerSender(address sender) public {\n        _erc1820.setInterfaceImplementer(address(this), _TOKENS_SENDER_INTERFACE_HASH, sender);\n    }\n\n    function recipientFor(address account) public {\n        _registerInterfaceForAddress(_TOKENS_RECIPIENT_INTERFACE_HASH, account);\n\n        address self = address(this);\n        if (account == self) {\n            registerRecipient(self);\n        }\n    }\n\n    function registerRecipient(address recipient) public {\n        _erc1820.setInterfaceImplementer(address(this), _TOKENS_RECIPIENT_INTERFACE_HASH, recipient);\n    }\n\n    function setShouldRevertSend(bool shouldRevert) public {\n        _shouldRevertSend = shouldRevert;\n    }\n\n    function setShouldRevertReceive(bool shouldRevert) public {\n        _shouldRevertReceive = shouldRevert;\n    }\n\n    function send(\n        IERC777 token,\n        address to,\n        uint256 amount,\n        bytes memory data\n    ) public {\n        // This is 777's send function, not the Solidity send function\n        token.send(to, amount, data); // solhint-disable-line check-send-result\n    }\n\n    function burn(\n        IERC777 token,\n        uint256 amount,\n        bytes memory data\n    ) public {\n        token.burn(amount, data);\n    }\n}\n","imports":["utils/introspection/ERC1820Implementer.sol","token/ERC777/IERC777Sender.sol","token/ERC777/IERC777.sol","token/ERC777/IERC777Recipient.sol","utils/introspection/IERC1820Registry.sol","utils/Context.sol"],"references":[],"urls":[]},"mocks/EnumerableMapMock.sol":{"checksum":{"algorithm":"md5","hash":"0xfc9e6319e0f21ae3f434184d27117fc9"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/structs/EnumerableMap.sol\";\n\n// UintToAddressMap\ncontract UintToAddressMapMock {\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n\n    event OperationResult(bool result);\n\n    EnumerableMap.UintToAddressMap private _map;\n\n    function contains(uint256 key) public view returns (bool) {\n        return _map.contains(key);\n    }\n\n    function set(uint256 key, address value) public {\n        bool result = _map.set(key, value);\n        emit OperationResult(result);\n    }\n\n    function remove(uint256 key) public {\n        bool result = _map.remove(key);\n        emit OperationResult(result);\n    }\n\n    function length() public view returns (uint256) {\n        return _map.length();\n    }\n\n    function at(uint256 index) public view returns (uint256 key, address value) {\n        return _map.at(index);\n    }\n\n    function tryGet(uint256 key) public view returns (bool, address) {\n        return _map.tryGet(key);\n    }\n\n    function get(uint256 key) public view returns (address) {\n        return _map.get(key);\n    }\n\n    function getWithMessage(uint256 key, string calldata errorMessage) public view returns (address) {\n        return _map.get(key, errorMessage);\n    }\n}\n\n// AddressToUintMap\ncontract AddressToUintMapMock {\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\n\n    event OperationResult(bool result);\n\n    EnumerableMap.AddressToUintMap private _map;\n\n    function contains(address key) public view returns (bool) {\n        return _map.contains(key);\n    }\n\n    function set(address key, uint256 value) public {\n        bool result = _map.set(key, value);\n        emit OperationResult(result);\n    }\n\n    function remove(address key) public {\n        bool result = _map.remove(key);\n        emit OperationResult(result);\n    }\n\n    function length() public view returns (uint256) {\n        return _map.length();\n    }\n\n    function at(uint256 index) public view returns (address key, uint256 value) {\n        return _map.at(index);\n    }\n\n    function tryGet(address key) public view returns (bool, uint256) {\n        return _map.tryGet(key);\n    }\n\n    function get(address key) public view returns (uint256) {\n        return _map.get(key);\n    }\n\n    function getWithMessage(address key, string calldata errorMessage) public view returns (uint256) {\n        return _map.get(key, errorMessage);\n    }\n}\n\ncontract Bytes32ToBytes32MapMock {\n    using EnumerableMap for EnumerableMap.Bytes32ToBytes32Map;\n\n    event OperationResult(bool result);\n\n    EnumerableMap.Bytes32ToBytes32Map private _map;\n\n    function contains(bytes32 key) public view returns (bool) {\n        return _map.contains(key);\n    }\n\n    function set(bytes32 key, bytes32 value) public {\n        bool result = _map.set(key, value);\n        emit OperationResult(result);\n    }\n\n    function remove(bytes32 key) public {\n        bool result = _map.remove(key);\n        emit OperationResult(result);\n    }\n\n    function length() public view returns (uint256) {\n        return _map.length();\n    }\n\n    function at(uint256 index) public view returns (bytes32 key, bytes32 value) {\n        return _map.at(index);\n    }\n\n    function tryGet(bytes32 key) public view returns (bool, bytes32) {\n        return _map.tryGet(key);\n    }\n\n    function get(bytes32 key) public view returns (bytes32) {\n        return _map.get(key);\n    }\n\n    function getWithMessage(bytes32 key, string calldata errorMessage) public view returns (bytes32) {\n        return _map.get(key, errorMessage);\n    }\n}\n\n// UintToUintMap\ncontract UintToUintMapMock {\n    using EnumerableMap for EnumerableMap.UintToUintMap;\n\n    event OperationResult(bool result);\n\n    EnumerableMap.UintToUintMap private _map;\n\n    function contains(uint256 key) public view returns (bool) {\n        return _map.contains(key);\n    }\n\n    function set(uint256 key, uint256 value) public {\n        bool result = _map.set(key, value);\n        emit OperationResult(result);\n    }\n\n    function remove(uint256 key) public {\n        bool result = _map.remove(key);\n        emit OperationResult(result);\n    }\n\n    function length() public view returns (uint256) {\n        return _map.length();\n    }\n\n    function at(uint256 index) public view returns (uint256 key, uint256 value) {\n        return _map.at(index);\n    }\n\n    function tryGet(uint256 key) public view returns (bool, uint256) {\n        return _map.tryGet(key);\n    }\n\n    function get(uint256 key) public view returns (uint256) {\n        return _map.get(key);\n    }\n\n    function getWithMessage(uint256 key, string calldata errorMessage) public view returns (uint256) {\n        return _map.get(key, errorMessage);\n    }\n}\n\n// Bytes32ToUintMap\ncontract Bytes32ToUintMapMock {\n    using EnumerableMap for EnumerableMap.Bytes32ToUintMap;\n\n    event OperationResult(bool result);\n\n    EnumerableMap.Bytes32ToUintMap private _map;\n\n    function contains(bytes32 key) public view returns (bool) {\n        return _map.contains(key);\n    }\n\n    function set(bytes32 key, uint256 value) public {\n        bool result = _map.set(key, value);\n        emit OperationResult(result);\n    }\n\n    function remove(bytes32 key) public {\n        bool result = _map.remove(key);\n        emit OperationResult(result);\n    }\n\n    function length() public view returns (uint256) {\n        return _map.length();\n    }\n\n    function at(uint256 index) public view returns (bytes32 key, uint256 value) {\n        return _map.at(index);\n    }\n\n    function tryGet(bytes32 key) public view returns (bool, uint256) {\n        return _map.tryGet(key);\n    }\n\n    function get(bytes32 key) public view returns (uint256) {\n        return _map.get(key);\n    }\n\n    function getWithMessage(bytes32 key, string calldata errorMessage) public view returns (uint256) {\n        return _map.get(key, errorMessage);\n    }\n}\n","imports":["utils/structs/EnumerableMap.sol"],"references":[],"urls":[]},"mocks/EnumerableSetMock.sol":{"checksum":{"algorithm":"md5","hash":"0x132727e4f74eb805b03945288864e434"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/structs/EnumerableSet.sol\";\n\n// Bytes32Set\ncontract EnumerableBytes32SetMock {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    event OperationResult(bool result);\n\n    EnumerableSet.Bytes32Set private _set;\n\n    function contains(bytes32 value) public view returns (bool) {\n        return _set.contains(value);\n    }\n\n    function add(bytes32 value) public {\n        bool result = _set.add(value);\n        emit OperationResult(result);\n    }\n\n    function remove(bytes32 value) public {\n        bool result = _set.remove(value);\n        emit OperationResult(result);\n    }\n\n    function length() public view returns (uint256) {\n        return _set.length();\n    }\n\n    function at(uint256 index) public view returns (bytes32) {\n        return _set.at(index);\n    }\n\n    function values() public view returns (bytes32[] memory) {\n        return _set.values();\n    }\n}\n\n// AddressSet\ncontract EnumerableAddressSetMock {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    event OperationResult(bool result);\n\n    EnumerableSet.AddressSet private _set;\n\n    function contains(address value) public view returns (bool) {\n        return _set.contains(value);\n    }\n\n    function add(address value) public {\n        bool result = _set.add(value);\n        emit OperationResult(result);\n    }\n\n    function remove(address value) public {\n        bool result = _set.remove(value);\n        emit OperationResult(result);\n    }\n\n    function length() public view returns (uint256) {\n        return _set.length();\n    }\n\n    function at(uint256 index) public view returns (address) {\n        return _set.at(index);\n    }\n\n    function values() public view returns (address[] memory) {\n        return _set.values();\n    }\n}\n\n// UintSet\ncontract EnumerableUintSetMock {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    event OperationResult(bool result);\n\n    EnumerableSet.UintSet private _set;\n\n    function contains(uint256 value) public view returns (bool) {\n        return _set.contains(value);\n    }\n\n    function add(uint256 value) public {\n        bool result = _set.add(value);\n        emit OperationResult(result);\n    }\n\n    function remove(uint256 value) public {\n        bool result = _set.remove(value);\n        emit OperationResult(result);\n    }\n\n    function length() public view returns (uint256) {\n        return _set.length();\n    }\n\n    function at(uint256 index) public view returns (uint256) {\n        return _set.at(index);\n    }\n\n    function values() public view returns (uint256[] memory) {\n        return _set.values();\n    }\n}\n","imports":["utils/structs/EnumerableSet.sol"],"references":[],"urls":[]},"mocks/EtherReceiverMock.sol":{"checksum":{"algorithm":"md5","hash":"0x03543c772b5715405d1847fe2a7e6ba4"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract EtherReceiverMock {\n    bool private _acceptEther;\n\n    function setAcceptEther(bool acceptEther) public {\n        _acceptEther = acceptEther;\n    }\n\n    receive() external payable {\n        if (!_acceptEther) {\n            revert();\n        }\n    }\n}\n","imports":[],"references":[],"urls":[]},"mocks/GovernorCompMock.sol":{"checksum":{"algorithm":"md5","hash":"0x54ce89d4d552d89e625f33c1c148e474"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../governance/extensions/GovernorCountingSimple.sol\";\nimport \"../governance/extensions/GovernorVotesComp.sol\";\n\ncontract GovernorCompMock is GovernorVotesComp, GovernorCountingSimple {\n    constructor(string memory name_, ERC20VotesComp token_) Governor(name_) GovernorVotesComp(token_) {}\n\n    function quorum(uint256) public pure override returns (uint256) {\n        return 0;\n    }\n\n    function votingDelay() public pure override returns (uint256) {\n        return 4;\n    }\n\n    function votingPeriod() public pure override returns (uint256) {\n        return 16;\n    }\n\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 salt\n    ) public returns (uint256 proposalId) {\n        return _cancel(targets, values, calldatas, salt);\n    }\n}\n","imports":["governance/extensions/GovernorCountingSimple.sol","governance/extensions/GovernorVotesComp.sol"],"references":[],"urls":[]},"mocks/GovernorCompatibilityBravoMock.sol":{"checksum":{"algorithm":"md5","hash":"0x7ff6e9df87add3830b5caa479fac4626"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../governance/compatibility/GovernorCompatibilityBravo.sol\";\nimport \"../governance/extensions/GovernorTimelockCompound.sol\";\nimport \"../governance/extensions/GovernorSettings.sol\";\nimport \"../governance/extensions/GovernorVotesComp.sol\";\n\ncontract GovernorCompatibilityBravoMock is\n    GovernorCompatibilityBravo,\n    GovernorSettings,\n    GovernorTimelockCompound,\n    GovernorVotesComp\n{\n    constructor(\n        string memory name_,\n        ERC20VotesComp token_,\n        uint256 votingDelay_,\n        uint256 votingPeriod_,\n        uint256 proposalThreshold_,\n        ICompoundTimelock timelock_\n    )\n        Governor(name_)\n        GovernorTimelockCompound(timelock_)\n        GovernorSettings(votingDelay_, votingPeriod_, proposalThreshold_)\n        GovernorVotesComp(token_)\n    {}\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(IERC165, Governor, GovernorTimelockCompound)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function quorum(uint256) public pure override returns (uint256) {\n        return 0;\n    }\n\n    function state(uint256 proposalId)\n        public\n        view\n        virtual\n        override(IGovernor, Governor, GovernorTimelockCompound)\n        returns (ProposalState)\n    {\n        return super.state(proposalId);\n    }\n\n    function proposalEta(uint256 proposalId)\n        public\n        view\n        virtual\n        override(IGovernorTimelock, GovernorTimelockCompound)\n        returns (uint256)\n    {\n        return super.proposalEta(proposalId);\n    }\n\n    function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) {\n        return super.proposalThreshold();\n    }\n\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override(IGovernor, Governor, GovernorCompatibilityBravo) returns (uint256) {\n        return super.propose(targets, values, calldatas, description);\n    }\n\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 salt\n    ) public virtual override(IGovernorTimelock, GovernorTimelockCompound) returns (uint256) {\n        return super.queue(targets, values, calldatas, salt);\n    }\n\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 salt\n    ) public payable virtual override(IGovernor, Governor) returns (uint256) {\n        return super.execute(targets, values, calldatas, salt);\n    }\n\n    function _execute(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override(Governor, GovernorTimelockCompound) {\n        super._execute(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    /**\n     * @notice WARNING: this is for mock purposes only. Ability to the _cancel function should be restricted for live\n     * deployments.\n     */\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 salt\n    ) public returns (uint256 proposalId) {\n        return _cancel(targets, values, calldatas, salt);\n    }\n\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 salt\n    ) internal virtual override(Governor, GovernorTimelockCompound) returns (uint256 proposalId) {\n        return super._cancel(targets, values, calldatas, salt);\n    }\n\n    function _executor() internal view virtual override(Governor, GovernorTimelockCompound) returns (address) {\n        return super._executor();\n    }\n}\n","imports":["governance/extensions/GovernorVotesComp.sol","governance/extensions/GovernorTimelockCompound.sol","governance/extensions/GovernorSettings.sol","governance/compatibility/GovernorCompatibilityBravo.sol"],"references":[],"urls":[]},"mocks/GovernorMock.sol":{"checksum":{"algorithm":"md5","hash":"0x45db2c5b7e63a87bac9107752de024e6"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../governance/extensions/GovernorProposalThreshold.sol\";\nimport \"../governance/extensions/GovernorSettings.sol\";\nimport \"../governance/extensions/GovernorCountingSimple.sol\";\nimport \"../governance/extensions/GovernorVotesQuorumFraction.sol\";\n\ncontract GovernorMock is\n    GovernorProposalThreshold,\n    GovernorSettings,\n    GovernorVotesQuorumFraction,\n    GovernorCountingSimple\n{\n    constructor(\n        string memory name_,\n        IVotes token_,\n        uint256 votingDelay_,\n        uint256 votingPeriod_,\n        uint256 quorumNumerator_\n    )\n        Governor(name_)\n        GovernorSettings(votingDelay_, votingPeriod_, 0)\n        GovernorVotes(token_)\n        GovernorVotesQuorumFraction(quorumNumerator_)\n    {}\n\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 salt\n    ) public returns (uint256 proposalId) {\n        return _cancel(targets, values, calldatas, salt);\n    }\n\n    function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) {\n        return super.proposalThreshold();\n    }\n\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override(Governor, GovernorProposalThreshold) returns (uint256) {\n        return super.propose(targets, values, calldatas, description);\n    }\n}\n","imports":["governance/extensions/GovernorProposalThreshold.sol","governance/extensions/GovernorCountingSimple.sol","governance/extensions/GovernorSettings.sol","governance/extensions/GovernorVotesQuorumFraction.sol"],"references":[],"urls":[]},"mocks/GovernorPreventLateQuorumMock.sol":{"checksum":{"algorithm":"md5","hash":"0x2a8108c43a64afcd361d69ff191305cb"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../governance/extensions/GovernorPreventLateQuorum.sol\";\nimport \"../governance/extensions/GovernorSettings.sol\";\nimport \"../governance/extensions/GovernorCountingSimple.sol\";\nimport \"../governance/extensions/GovernorVotes.sol\";\n\ncontract GovernorPreventLateQuorumMock is\n    GovernorSettings,\n    GovernorVotes,\n    GovernorCountingSimple,\n    GovernorPreventLateQuorum\n{\n    uint256 private _quorum;\n\n    constructor(\n        string memory name_,\n        IVotes token_,\n        uint256 votingDelay_,\n        uint256 votingPeriod_,\n        uint256 quorum_,\n        uint64 voteExtension_\n    )\n        Governor(name_)\n        GovernorSettings(votingDelay_, votingPeriod_, 0)\n        GovernorVotes(token_)\n        GovernorPreventLateQuorum(voteExtension_)\n    {\n        _quorum = quorum_;\n    }\n\n    function quorum(uint256) public view virtual override returns (uint256) {\n        return _quorum;\n    }\n\n    function proposalDeadline(uint256 proposalId)\n        public\n        view\n        virtual\n        override(Governor, GovernorPreventLateQuorum)\n        returns (uint256)\n    {\n        return super.proposalDeadline(proposalId);\n    }\n\n    function proposalThreshold() public view virtual override(Governor, GovernorSettings) returns (uint256) {\n        return super.proposalThreshold();\n    }\n\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual override(Governor, GovernorPreventLateQuorum) returns (uint256) {\n        return super._castVote(proposalId, account, support, reason, params);\n    }\n}\n","imports":["governance/extensions/GovernorCountingSimple.sol","governance/extensions/GovernorPreventLateQuorum.sol","governance/extensions/GovernorSettings.sol","governance/extensions/GovernorVotes.sol"],"references":[],"urls":[]},"mocks/GovernorTimelockCompoundMock.sol":{"checksum":{"algorithm":"md5","hash":"0xa9d38a78c4b1c4ee9fbdbc9f7208603a"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../governance/extensions/GovernorTimelockCompound.sol\";\nimport \"../governance/extensions/GovernorSettings.sol\";\nimport \"../governance/extensions/GovernorCountingSimple.sol\";\nimport \"../governance/extensions/GovernorVotesQuorumFraction.sol\";\n\ncontract GovernorTimelockCompoundMock is\n    GovernorSettings,\n    GovernorTimelockCompound,\n    GovernorVotesQuorumFraction,\n    GovernorCountingSimple\n{\n    constructor(\n        string memory name_,\n        IVotes token_,\n        uint256 votingDelay_,\n        uint256 votingPeriod_,\n        ICompoundTimelock timelock_,\n        uint256 quorumNumerator_\n    )\n        Governor(name_)\n        GovernorTimelockCompound(timelock_)\n        GovernorSettings(votingDelay_, votingPeriod_, 0)\n        GovernorVotes(token_)\n        GovernorVotesQuorumFraction(quorumNumerator_)\n    {}\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(Governor, GovernorTimelockCompound)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function quorum(uint256 blockNumber)\n        public\n        view\n        override(IGovernor, GovernorVotesQuorumFraction)\n        returns (uint256)\n    {\n        return super.quorum(blockNumber);\n    }\n\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 salt\n    ) public returns (uint256 proposalId) {\n        return _cancel(targets, values, calldatas, salt);\n    }\n\n    /**\n     * Overriding nightmare\n     */\n    function state(uint256 proposalId)\n        public\n        view\n        virtual\n        override(Governor, GovernorTimelockCompound)\n        returns (ProposalState)\n    {\n        return super.state(proposalId);\n    }\n\n    function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) {\n        return super.proposalThreshold();\n    }\n\n    function _execute(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override(Governor, GovernorTimelockCompound) {\n        super._execute(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 salt\n    ) internal virtual override(Governor, GovernorTimelockCompound) returns (uint256 proposalId) {\n        return super._cancel(targets, values, calldatas, salt);\n    }\n\n    function _executor() internal view virtual override(Governor, GovernorTimelockCompound) returns (address) {\n        return super._executor();\n    }\n}\n","imports":["governance/extensions/GovernorTimelockCompound.sol","governance/extensions/GovernorCountingSimple.sol","governance/extensions/GovernorSettings.sol","governance/extensions/GovernorVotesQuorumFraction.sol"],"references":[],"urls":[]},"mocks/GovernorTimelockControlMock.sol":{"checksum":{"algorithm":"md5","hash":"0x9e92284e6dd1bf2c60690ae8d8af88e8"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../governance/extensions/GovernorTimelockControl.sol\";\nimport \"../governance/extensions/GovernorSettings.sol\";\nimport \"../governance/extensions/GovernorCountingSimple.sol\";\nimport \"../governance/extensions/GovernorVotesQuorumFraction.sol\";\n\ncontract GovernorTimelockControlMock is\n    GovernorSettings,\n    GovernorTimelockControl,\n    GovernorVotesQuorumFraction,\n    GovernorCountingSimple\n{\n    constructor(\n        string memory name_,\n        IVotes token_,\n        uint256 votingDelay_,\n        uint256 votingPeriod_,\n        TimelockController timelock_,\n        uint256 quorumNumerator_\n    )\n        Governor(name_)\n        GovernorTimelockControl(timelock_)\n        GovernorSettings(votingDelay_, votingPeriod_, 0)\n        GovernorVotes(token_)\n        GovernorVotesQuorumFraction(quorumNumerator_)\n    {}\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(Governor, GovernorTimelockControl)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function quorum(uint256 blockNumber)\n        public\n        view\n        override(IGovernor, GovernorVotesQuorumFraction)\n        returns (uint256)\n    {\n        return super.quorum(blockNumber);\n    }\n\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public returns (uint256 proposalId) {\n        return _cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    /**\n     * Overriding nightmare\n     */\n    function state(uint256 proposalId)\n        public\n        view\n        virtual\n        override(Governor, GovernorTimelockControl)\n        returns (ProposalState)\n    {\n        return super.state(proposalId);\n    }\n\n    function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) {\n        return super.proposalThreshold();\n    }\n\n    function _execute(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override(Governor, GovernorTimelockControl) {\n        super._execute(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override(Governor, GovernorTimelockControl) returns (uint256 proposalId) {\n        return super._cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    function _executor() internal view virtual override(Governor, GovernorTimelockControl) returns (address) {\n        return super._executor();\n    }\n\n    function nonGovernanceFunction() external {}\n}\n","imports":["governance/extensions/GovernorTimelockControl.sol","governance/extensions/GovernorCountingSimple.sol","governance/extensions/GovernorSettings.sol","governance/extensions/GovernorVotesQuorumFraction.sol"],"references":[],"urls":[]},"mocks/GovernorVoteMock.sol":{"checksum":{"algorithm":"md5","hash":"0xbc6348e9ab76d49ed079b959f98b2523"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../governance/extensions/GovernorCountingSimple.sol\";\nimport \"../governance/extensions/GovernorVotes.sol\";\n\ncontract GovernorVoteMocks is GovernorVotes, GovernorCountingSimple {\n    constructor(string memory name_, IVotes token_) Governor(name_) GovernorVotes(token_) {}\n\n    function quorum(uint256) public pure override returns (uint256) {\n        return 0;\n    }\n\n    function votingDelay() public pure override returns (uint256) {\n        return 4;\n    }\n\n    function votingPeriod() public pure override returns (uint256) {\n        return 16;\n    }\n\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 salt\n    ) public returns (uint256 proposalId) {\n        return _cancel(targets, values, calldatas, salt);\n    }\n}\n","imports":["governance/extensions/GovernorCountingSimple.sol","governance/extensions/GovernorVotes.sol"],"references":[],"urls":[]},"mocks/GovernorWithParamsMock.sol":{"checksum":{"algorithm":"md5","hash":"0x944ff9ddab4ac57f2c36a21abff1f723"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../governance/extensions/GovernorCountingSimple.sol\";\nimport \"../governance/extensions/GovernorVotes.sol\";\n\ncontract GovernorWithParamsMock is GovernorVotes, GovernorCountingSimple {\n    event CountParams(uint256 uintParam, string strParam);\n\n    constructor(string memory name_, IVotes token_) Governor(name_) GovernorVotes(token_) {}\n\n    function quorum(uint256) public pure override returns (uint256) {\n        return 0;\n    }\n\n    function votingDelay() public pure override returns (uint256) {\n        return 4;\n    }\n\n    function votingPeriod() public pure override returns (uint256) {\n        return 16;\n    }\n\n    function _getVotes(\n        address account,\n        uint256 blockNumber,\n        bytes memory params\n    ) internal view virtual override(Governor, GovernorVotes) returns (uint256) {\n        uint256 reduction = 0;\n        // If the user provides parameters, we reduce the voting weight by the amount of the integer param\n        if (params.length > 0) {\n            (reduction, ) = abi.decode(params, (uint256, string));\n        }\n        // reverts on overflow\n        return super._getVotes(account, blockNumber, params) - reduction;\n    }\n\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory params\n    ) internal virtual override(Governor, GovernorCountingSimple) {\n        if (params.length > 0) {\n            (uint256 _uintParam, string memory _strParam) = abi.decode(params, (uint256, string));\n            emit CountParams(_uintParam, _strParam);\n        }\n        return super._countVote(proposalId, account, support, weight, params);\n    }\n\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 salt\n    ) public returns (uint256 proposalId) {\n        return _cancel(targets, values, calldatas, salt);\n    }\n}\n","imports":["governance/extensions/GovernorCountingSimple.sol","governance/extensions/GovernorVotes.sol"],"references":[],"urls":[]},"mocks/InitializableMock.sol":{"checksum":{"algorithm":"md5","hash":"0xe79a498cb01359b4264157a57c2f0ec1"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @title InitializableMock\n * @dev This contract is a mock to test initializable functionality\n */\ncontract InitializableMock is Initializable {\n    bool public initializerRan;\n    bool public onlyInitializingRan;\n    uint256 public x;\n\n    function initialize() public initializer {\n        initializerRan = true;\n    }\n\n    function initializeOnlyInitializing() public onlyInitializing {\n        onlyInitializingRan = true;\n    }\n\n    function initializerNested() public initializer {\n        initialize();\n    }\n\n    function onlyInitializingNested() public initializer {\n        initializeOnlyInitializing();\n    }\n\n    function initializeWithX(uint256 _x) public payable initializer {\n        x = _x;\n    }\n\n    function nonInitializable(uint256 _x) public payable {\n        x = _x;\n    }\n\n    function fail() public pure {\n        require(false, \"InitializableMock forced failure\");\n    }\n}\n\ncontract ConstructorInitializableMock is Initializable {\n    bool public initializerRan;\n    bool public onlyInitializingRan;\n\n    constructor() initializer {\n        initialize();\n        initializeOnlyInitializing();\n    }\n\n    function initialize() public initializer {\n        initializerRan = true;\n    }\n\n    function initializeOnlyInitializing() public onlyInitializing {\n        onlyInitializingRan = true;\n    }\n}\n\ncontract ChildConstructorInitializableMock is ConstructorInitializableMock {\n    bool public childInitializerRan;\n\n    constructor() initializer {\n        childInitialize();\n    }\n\n    function childInitialize() public initializer {\n        childInitializerRan = true;\n    }\n}\n\ncontract ReinitializerMock is Initializable {\n    uint256 public counter;\n\n    function initialize() public initializer {\n        doStuff();\n    }\n\n    function reinitialize(uint8 i) public reinitializer(i) {\n        doStuff();\n    }\n\n    function nestedReinitialize(uint8 i, uint8 j) public reinitializer(i) {\n        reinitialize(j);\n    }\n\n    function chainReinitialize(uint8 i, uint8 j) public {\n        reinitialize(i);\n        reinitialize(j);\n    }\n\n    function disableInitializers() public {\n        _disableInitializers();\n    }\n\n    function doStuff() public onlyInitializing {\n        counter++;\n    }\n}\n\ncontract DisableNew is Initializable {\n    constructor() {\n        _disableInitializers();\n    }\n}\n\ncontract DisableOld is Initializable {\n    constructor() initializer {}\n}\n\ncontract DisableBad1 is DisableNew, DisableOld {}\n\ncontract DisableBad2 is Initializable {\n    constructor() initializer {\n        _disableInitializers();\n    }\n}\n\ncontract DisableOk is DisableOld, DisableNew {}\n","imports":["proxy/utils/Initializable.sol"],"references":[],"urls":[]},"mocks/MathMock.sol":{"checksum":{"algorithm":"md5","hash":"0x6ae0bcf6d2f003f455eb53e86abcd4ee"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/math/Math.sol\";\n\ncontract MathMock {\n    function max(uint256 a, uint256 b) public pure returns (uint256) {\n        return Math.max(a, b);\n    }\n\n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return Math.min(a, b);\n    }\n\n    function average(uint256 a, uint256 b) public pure returns (uint256) {\n        return Math.average(a, b);\n    }\n\n    function ceilDiv(uint256 a, uint256 b) public pure returns (uint256) {\n        return Math.ceilDiv(a, b);\n    }\n\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator,\n        Math.Rounding direction\n    ) public pure returns (uint256) {\n        return Math.mulDiv(a, b, denominator, direction);\n    }\n\n    function sqrt(uint256 a, Math.Rounding direction) public pure returns (uint256) {\n        return Math.sqrt(a, direction);\n    }\n}\n","imports":["utils/math/Math.sol"],"references":[],"urls":[]},"mocks/MerkleProofWrapper.sol":{"checksum":{"algorithm":"md5","hash":"0x33253d3ba09f9cbda5051c3571f83e9d"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/cryptography/MerkleProof.sol\";\n\ncontract MerkleProofWrapper {\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) public pure returns (bool) {\n        return MerkleProof.verify(proof, root, leaf);\n    }\n\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) public pure returns (bool) {\n        return MerkleProof.verifyCalldata(proof, root, leaf);\n    }\n\n    function processProof(bytes32[] memory proof, bytes32 leaf) public pure returns (bytes32) {\n        return MerkleProof.processProof(proof, leaf);\n    }\n\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) public pure returns (bytes32) {\n        return MerkleProof.processProofCalldata(proof, leaf);\n    }\n\n    function multiProofVerify(\n        bytes32[] memory proofs,\n        bool[] memory proofFlag,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) public pure returns (bool) {\n        return MerkleProof.multiProofVerify(proofs, proofFlag, root, leaves);\n    }\n\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proofs,\n        bool[] calldata proofFlag,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) public pure returns (bool) {\n        return MerkleProof.multiProofVerifyCalldata(proofs, proofFlag, root, leaves);\n    }\n\n    function processMultiProof(\n        bytes32[] memory proofs,\n        bool[] memory proofFlag,\n        bytes32[] memory leaves\n    ) public pure returns (bytes32) {\n        return MerkleProof.processMultiProof(proofs, proofFlag, leaves);\n    }\n\n    function processMultiProofCalldata(\n        bytes32[] calldata proofs,\n        bool[] calldata proofFlag,\n        bytes32[] memory leaves\n    ) public pure returns (bytes32) {\n        return MerkleProof.processMultiProofCalldata(proofs, proofFlag, leaves);\n    }\n}\n","imports":["utils/cryptography/MerkleProof.sol"],"references":[],"urls":[]},"mocks/MulticallTest.sol":{"checksum":{"algorithm":"md5","hash":"0x0471bdc492e4d2505a3e89478217a62a"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./MulticallTokenMock.sol\";\n\ncontract MulticallTest {\n    function testReturnValues(\n        MulticallTokenMock multicallToken,\n        address[] calldata recipients,\n        uint256[] calldata amounts\n    ) external {\n        bytes[] memory calls = new bytes[](recipients.length);\n        for (uint256 i = 0; i < recipients.length; i++) {\n            calls[i] = abi.encodeWithSignature(\"transfer(address,uint256)\", recipients[i], amounts[i]);\n        }\n\n        bytes[] memory results = multicallToken.multicall(calls);\n        for (uint256 i = 0; i < results.length; i++) {\n            require(abi.decode(results[i], (bool)));\n        }\n    }\n}\n","imports":["mocks/MulticallTokenMock.sol"],"references":[],"urls":[]},"mocks/MulticallTokenMock.sol":{"checksum":{"algorithm":"md5","hash":"0xf3d490698b1a7cdcf440f9d64eca2c57"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Multicall.sol\";\nimport \"./ERC20Mock.sol\";\n\ncontract MulticallTokenMock is ERC20Mock, Multicall {\n    constructor(uint256 initialBalance) ERC20Mock(\"MulticallToken\", \"BCT\", msg.sender, initialBalance) {}\n}\n","imports":["mocks/ERC20Mock.sol","utils/Multicall.sol"],"references":["mocks/MulticallTest.sol"],"urls":[]},"mocks/MultipleInheritanceInitializableMocks.sol":{"checksum":{"algorithm":"md5","hash":"0x92983a5e9a4d6baa9fa2655f068867f5"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../proxy/utils/Initializable.sol\";\n\n// Sample contracts showing upgradeability with multiple inheritance.\n// Child contract inherits from Father and Mother contracts, and Father extends from Gramps.\n//\n//         Human\n//       /       \\\n//      |       Gramps\n//      |         |\n//    Mother    Father\n//      |         |\n//      -- Child --\n\n/**\n * Sample base intializable contract that is a human\n */\ncontract SampleHuman is Initializable {\n    bool public isHuman;\n\n    function initialize() public initializer {\n        __SampleHuman_init();\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __SampleHuman_init() internal onlyInitializing {\n        __SampleHuman_init_unchained();\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __SampleHuman_init_unchained() internal onlyInitializing {\n        isHuman = true;\n    }\n}\n\n/**\n * Sample base intializable contract that defines a field mother\n */\ncontract SampleMother is Initializable, SampleHuman {\n    uint256 public mother;\n\n    function initialize(uint256 value) public virtual initializer {\n        __SampleMother_init(value);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __SampleMother_init(uint256 value) internal onlyInitializing {\n        __SampleHuman_init();\n        __SampleMother_init_unchained(value);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __SampleMother_init_unchained(uint256 value) internal onlyInitializing {\n        mother = value;\n    }\n}\n\n/**\n * Sample base intializable contract that defines a field gramps\n */\ncontract SampleGramps is Initializable, SampleHuman {\n    string public gramps;\n\n    function initialize(string memory value) public virtual initializer {\n        __SampleGramps_init(value);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __SampleGramps_init(string memory value) internal onlyInitializing {\n        __SampleHuman_init();\n        __SampleGramps_init_unchained(value);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __SampleGramps_init_unchained(string memory value) internal onlyInitializing {\n        gramps = value;\n    }\n}\n\n/**\n * Sample base intializable contract that defines a field father and extends from gramps\n */\ncontract SampleFather is Initializable, SampleGramps {\n    uint256 public father;\n\n    function initialize(string memory _gramps, uint256 _father) public initializer {\n        __SampleFather_init(_gramps, _father);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __SampleFather_init(string memory _gramps, uint256 _father) internal onlyInitializing {\n        __SampleGramps_init(_gramps);\n        __SampleFather_init_unchained(_father);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __SampleFather_init_unchained(uint256 _father) internal onlyInitializing {\n        father = _father;\n    }\n}\n\n/**\n * Child extends from mother, father (gramps)\n */\ncontract SampleChild is Initializable, SampleMother, SampleFather {\n    uint256 public child;\n\n    function initialize(\n        uint256 _mother,\n        string memory _gramps,\n        uint256 _father,\n        uint256 _child\n    ) public initializer {\n        __SampleChild_init(_mother, _gramps, _father, _child);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __SampleChild_init(\n        uint256 _mother,\n        string memory _gramps,\n        uint256 _father,\n        uint256 _child\n    ) internal onlyInitializing {\n        __SampleMother_init(_mother);\n        __SampleFather_init(_gramps, _father);\n        __SampleChild_init_unchained(_child);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __SampleChild_init_unchained(uint256 _child) internal onlyInitializing {\n        child = _child;\n    }\n}\n","imports":["proxy/utils/Initializable.sol"],"references":[],"urls":[]},"mocks/OwnableMock.sol":{"checksum":{"algorithm":"md5","hash":"0x3115355f79ef5589879d1bd20de82b32"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../access/Ownable.sol\";\n\ncontract OwnableMock is Ownable {}\n","imports":["access/Ownable.sol"],"references":[],"urls":[]},"mocks/PausableMock.sol":{"checksum":{"algorithm":"md5","hash":"0xa5683047c5c3ab9159768ea312956fc6"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../security/Pausable.sol\";\n\ncontract PausableMock is Pausable {\n    bool public drasticMeasureTaken;\n    uint256 public count;\n\n    constructor() {\n        drasticMeasureTaken = false;\n        count = 0;\n    }\n\n    function normalProcess() external whenNotPaused {\n        count++;\n    }\n\n    function drasticMeasure() external whenPaused {\n        drasticMeasureTaken = true;\n    }\n\n    function pause() external {\n        _pause();\n    }\n\n    function unpause() external {\n        _unpause();\n    }\n}\n","imports":["security/Pausable.sol"],"references":[],"urls":[]},"mocks/PullPaymentMock.sol":{"checksum":{"algorithm":"md5","hash":"0xadf7049bf6c48f7c5fe7681ed4f2bd54"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../security/PullPayment.sol\";\n\n// mock class using PullPayment\ncontract PullPaymentMock is PullPayment {\n    constructor() payable {}\n\n    // test helper function to call asyncTransfer\n    function callTransfer(address dest, uint256 amount) public {\n        _asyncTransfer(dest, amount);\n    }\n}\n","imports":["security/PullPayment.sol"],"references":[],"urls":[]},"mocks/ReentrancyAttack.sol":{"checksum":{"algorithm":"md5","hash":"0x365700b7d522712a4b8df63604a1f9df"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\ncontract ReentrancyAttack is Context {\n    function callSender(bytes4 data) public {\n        (bool success, ) = _msgSender().call(abi.encodeWithSelector(data));\n        require(success, \"ReentrancyAttack: failed call\");\n    }\n}\n","imports":["utils/Context.sol"],"references":["mocks/ReentrancyMock.sol"],"urls":[]},"mocks/ReentrancyMock.sol":{"checksum":{"algorithm":"md5","hash":"0x318e72355ec39e830288ec04dc4c76a7"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../security/ReentrancyGuard.sol\";\nimport \"./ReentrancyAttack.sol\";\n\ncontract ReentrancyMock is ReentrancyGuard {\n    uint256 public counter;\n\n    constructor() {\n        counter = 0;\n    }\n\n    function callback() external nonReentrant {\n        _count();\n    }\n\n    function countLocalRecursive(uint256 n) public nonReentrant {\n        if (n > 0) {\n            _count();\n            countLocalRecursive(n - 1);\n        }\n    }\n\n    function countThisRecursive(uint256 n) public nonReentrant {\n        if (n > 0) {\n            _count();\n            (bool success, ) = address(this).call(abi.encodeWithSignature(\"countThisRecursive(uint256)\", n - 1));\n            require(success, \"ReentrancyMock: failed call\");\n        }\n    }\n\n    function countAndCall(ReentrancyAttack attacker) public nonReentrant {\n        _count();\n        bytes4 func = bytes4(keccak256(\"callback()\"));\n        attacker.callSender(func);\n    }\n\n    function _count() private {\n        counter += 1;\n    }\n}\n","imports":["mocks/ReentrancyAttack.sol","security/ReentrancyGuard.sol"],"references":[],"urls":[]},"mocks/RegressionImplementation.sol":{"checksum":{"algorithm":"md5","hash":"0x427d4c71d64926b9de5d60e5686380bf"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../proxy/utils/Initializable.sol\";\n\ncontract Implementation1 is Initializable {\n    uint256 internal _value;\n\n    function initialize() public initializer {}\n\n    function setValue(uint256 _number) public {\n        _value = _number;\n    }\n}\n\ncontract Implementation2 is Initializable {\n    uint256 internal _value;\n\n    function initialize() public initializer {}\n\n    function setValue(uint256 _number) public {\n        _value = _number;\n    }\n\n    function getValue() public view returns (uint256) {\n        return _value;\n    }\n}\n\ncontract Implementation3 is Initializable {\n    uint256 internal _value;\n\n    function initialize() public initializer {}\n\n    function setValue(uint256 _number) public {\n        _value = _number;\n    }\n\n    function getValue(uint256 _number) public view returns (uint256) {\n        return _value + _number;\n    }\n}\n\ncontract Implementation4 is Initializable {\n    uint256 internal _value;\n\n    function initialize() public initializer {}\n\n    function setValue(uint256 _number) public {\n        _value = _number;\n    }\n\n    function getValue() public view returns (uint256) {\n        return _value;\n    }\n\n    fallback() external {\n        _value = 1;\n    }\n}\n","imports":["proxy/utils/Initializable.sol"],"references":[],"urls":[]},"mocks/SafeCastMock.sol":{"checksum":{"algorithm":"md5","hash":"0xa0d0e974d1a9dcab787dcedcff5a290d"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/math/SafeCast.sol\";\n\ncontract SafeCastMock {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    function toUint256(int256 a) public pure returns (uint256) {\n        return a.toUint256();\n    }\n\n    function toUint248(uint256 a) public pure returns (uint248) {\n        return a.toUint248();\n    }\n\n    function toUint240(uint256 a) public pure returns (uint240) {\n        return a.toUint240();\n    }\n\n    function toUint232(uint256 a) public pure returns (uint232) {\n        return a.toUint232();\n    }\n\n    function toUint224(uint256 a) public pure returns (uint224) {\n        return a.toUint224();\n    }\n\n    function toUint216(uint256 a) public pure returns (uint216) {\n        return a.toUint216();\n    }\n\n    function toUint208(uint256 a) public pure returns (uint208) {\n        return a.toUint208();\n    }\n\n    function toUint200(uint256 a) public pure returns (uint200) {\n        return a.toUint200();\n    }\n\n    function toUint192(uint256 a) public pure returns (uint192) {\n        return a.toUint192();\n    }\n\n    function toUint184(uint256 a) public pure returns (uint184) {\n        return a.toUint184();\n    }\n\n    function toUint176(uint256 a) public pure returns (uint176) {\n        return a.toUint176();\n    }\n\n    function toUint168(uint256 a) public pure returns (uint168) {\n        return a.toUint168();\n    }\n\n    function toUint160(uint256 a) public pure returns (uint160) {\n        return a.toUint160();\n    }\n\n    function toUint152(uint256 a) public pure returns (uint152) {\n        return a.toUint152();\n    }\n\n    function toUint144(uint256 a) public pure returns (uint144) {\n        return a.toUint144();\n    }\n\n    function toUint136(uint256 a) public pure returns (uint136) {\n        return a.toUint136();\n    }\n\n    function toUint128(uint256 a) public pure returns (uint128) {\n        return a.toUint128();\n    }\n\n    function toUint120(uint256 a) public pure returns (uint120) {\n        return a.toUint120();\n    }\n\n    function toUint112(uint256 a) public pure returns (uint112) {\n        return a.toUint112();\n    }\n\n    function toUint104(uint256 a) public pure returns (uint104) {\n        return a.toUint104();\n    }\n\n    function toUint96(uint256 a) public pure returns (uint96) {\n        return a.toUint96();\n    }\n\n    function toUint88(uint256 a) public pure returns (uint88) {\n        return a.toUint88();\n    }\n\n    function toUint80(uint256 a) public pure returns (uint80) {\n        return a.toUint80();\n    }\n\n    function toUint72(uint256 a) public pure returns (uint72) {\n        return a.toUint72();\n    }\n\n    function toUint64(uint256 a) public pure returns (uint64) {\n        return a.toUint64();\n    }\n\n    function toUint56(uint256 a) public pure returns (uint56) {\n        return a.toUint56();\n    }\n\n    function toUint48(uint256 a) public pure returns (uint48) {\n        return a.toUint48();\n    }\n\n    function toUint40(uint256 a) public pure returns (uint40) {\n        return a.toUint40();\n    }\n\n    function toUint32(uint256 a) public pure returns (uint32) {\n        return a.toUint32();\n    }\n\n    function toUint24(uint256 a) public pure returns (uint24) {\n        return a.toUint24();\n    }\n\n    function toUint16(uint256 a) public pure returns (uint16) {\n        return a.toUint16();\n    }\n\n    function toUint8(uint256 a) public pure returns (uint8) {\n        return a.toUint8();\n    }\n\n    function toInt256(uint256 a) public pure returns (int256) {\n        return a.toInt256();\n    }\n\n    function toInt248(int256 a) public pure returns (int248) {\n        return a.toInt248();\n    }\n\n    function toInt240(int256 a) public pure returns (int240) {\n        return a.toInt240();\n    }\n\n    function toInt232(int256 a) public pure returns (int232) {\n        return a.toInt232();\n    }\n\n    function toInt224(int256 a) public pure returns (int224) {\n        return a.toInt224();\n    }\n\n    function toInt216(int256 a) public pure returns (int216) {\n        return a.toInt216();\n    }\n\n    function toInt208(int256 a) public pure returns (int208) {\n        return a.toInt208();\n    }\n\n    function toInt200(int256 a) public pure returns (int200) {\n        return a.toInt200();\n    }\n\n    function toInt192(int256 a) public pure returns (int192) {\n        return a.toInt192();\n    }\n\n    function toInt184(int256 a) public pure returns (int184) {\n        return a.toInt184();\n    }\n\n    function toInt176(int256 a) public pure returns (int176) {\n        return a.toInt176();\n    }\n\n    function toInt168(int256 a) public pure returns (int168) {\n        return a.toInt168();\n    }\n\n    function toInt160(int256 a) public pure returns (int160) {\n        return a.toInt160();\n    }\n\n    function toInt152(int256 a) public pure returns (int152) {\n        return a.toInt152();\n    }\n\n    function toInt144(int256 a) public pure returns (int144) {\n        return a.toInt144();\n    }\n\n    function toInt136(int256 a) public pure returns (int136) {\n        return a.toInt136();\n    }\n\n    function toInt128(int256 a) public pure returns (int128) {\n        return a.toInt128();\n    }\n\n    function toInt120(int256 a) public pure returns (int120) {\n        return a.toInt120();\n    }\n\n    function toInt112(int256 a) public pure returns (int112) {\n        return a.toInt112();\n    }\n\n    function toInt104(int256 a) public pure returns (int104) {\n        return a.toInt104();\n    }\n\n    function toInt96(int256 a) public pure returns (int96) {\n        return a.toInt96();\n    }\n\n    function toInt88(int256 a) public pure returns (int88) {\n        return a.toInt88();\n    }\n\n    function toInt80(int256 a) public pure returns (int80) {\n        return a.toInt80();\n    }\n\n    function toInt72(int256 a) public pure returns (int72) {\n        return a.toInt72();\n    }\n\n    function toInt64(int256 a) public pure returns (int64) {\n        return a.toInt64();\n    }\n\n    function toInt56(int256 a) public pure returns (int56) {\n        return a.toInt56();\n    }\n\n    function toInt48(int256 a) public pure returns (int48) {\n        return a.toInt48();\n    }\n\n    function toInt40(int256 a) public pure returns (int40) {\n        return a.toInt40();\n    }\n\n    function toInt32(int256 a) public pure returns (int32) {\n        return a.toInt32();\n    }\n\n    function toInt24(int256 a) public pure returns (int24) {\n        return a.toInt24();\n    }\n\n    function toInt16(int256 a) public pure returns (int16) {\n        return a.toInt16();\n    }\n\n    function toInt8(int256 a) public pure returns (int8) {\n        return a.toInt8();\n    }\n}\n","imports":["utils/math/SafeCast.sol"],"references":[],"urls":[]},"mocks/SafeERC20Helper.sol":{"checksum":{"algorithm":"md5","hash":"0x1b6624fdacb14a05d535e259212bf72d"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\nimport \"../token/ERC20/IERC20.sol\";\nimport \"../token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"../token/ERC20/utils/SafeERC20.sol\";\n\ncontract ERC20ReturnFalseMock is Context {\n    uint256 private _allowance;\n\n    // IERC20's functions are not pure, but these mock implementations are: to prevent Solidity from issuing warnings,\n    // we write to a dummy state variable.\n    uint256 private _dummy;\n\n    function transfer(address, uint256) public returns (bool) {\n        _dummy = 0;\n        return false;\n    }\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public returns (bool) {\n        _dummy = 0;\n        return false;\n    }\n\n    function approve(address, uint256) public returns (bool) {\n        _dummy = 0;\n        return false;\n    }\n\n    function allowance(address, address) public view returns (uint256) {\n        require(_dummy == 0); // Dummy read from a state variable so that the function is view\n        return 0;\n    }\n}\n\ncontract ERC20ReturnTrueMock is Context {\n    mapping(address => uint256) private _allowances;\n\n    // IERC20's functions are not pure, but these mock implementations are: to prevent Solidity from issuing warnings,\n    // we write to a dummy state variable.\n    uint256 private _dummy;\n\n    function transfer(address, uint256) public returns (bool) {\n        _dummy = 0;\n        return true;\n    }\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public returns (bool) {\n        _dummy = 0;\n        return true;\n    }\n\n    function approve(address, uint256) public returns (bool) {\n        _dummy = 0;\n        return true;\n    }\n\n    function setAllowance(uint256 allowance_) public {\n        _allowances[_msgSender()] = allowance_;\n    }\n\n    function allowance(address owner, address) public view returns (uint256) {\n        return _allowances[owner];\n    }\n}\n\ncontract ERC20NoReturnMock is Context {\n    mapping(address => uint256) private _allowances;\n\n    // IERC20's functions are not pure, but these mock implementations are: to prevent Solidity from issuing warnings,\n    // we write to a dummy state variable.\n    uint256 private _dummy;\n\n    function transfer(address, uint256) public {\n        _dummy = 0;\n    }\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public {\n        _dummy = 0;\n    }\n\n    function approve(address, uint256) public {\n        _dummy = 0;\n    }\n\n    function setAllowance(uint256 allowance_) public {\n        _allowances[_msgSender()] = allowance_;\n    }\n\n    function allowance(address owner, address) public view returns (uint256) {\n        return _allowances[owner];\n    }\n}\n\ncontract ERC20PermitNoRevertMock is\n    ERC20(\"ERC20PermitNoRevertMock\", \"ERC20PermitNoRevertMock\"),\n    ERC20Permit(\"ERC20PermitNoRevertMock\")\n{\n    function getChainId() external view returns (uint256) {\n        return block.chainid;\n    }\n\n    function permitThatMayRevert(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        super.permit(owner, spender, value, deadline, v, r, s);\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        try this.permitThatMayRevert(owner, spender, value, deadline, v, r, s) {\n            // do nothing\n        } catch {\n            // do nothing\n        }\n    }\n}\n\ncontract SafeERC20Wrapper is Context {\n    using SafeERC20 for IERC20;\n\n    IERC20 private _token;\n\n    constructor(IERC20 token) {\n        _token = token;\n    }\n\n    function transfer() public {\n        _token.safeTransfer(address(0), 0);\n    }\n\n    function transferFrom() public {\n        _token.safeTransferFrom(address(0), address(0), 0);\n    }\n\n    function approve(uint256 amount) public {\n        _token.safeApprove(address(0), amount);\n    }\n\n    function increaseAllowance(uint256 amount) public {\n        _token.safeIncreaseAllowance(address(0), amount);\n    }\n\n    function decreaseAllowance(uint256 amount) public {\n        _token.safeDecreaseAllowance(address(0), amount);\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        SafeERC20.safePermit(IERC20Permit(address(_token)), owner, spender, value, deadline, v, r, s);\n    }\n\n    function setAllowance(uint256 allowance_) public {\n        ERC20ReturnTrueMock(address(_token)).setAllowance(allowance_);\n    }\n\n    function allowance() public view returns (uint256) {\n        return _token.allowance(address(0), address(0));\n    }\n}\n","imports":["token/ERC20/utils/SafeERC20.sol","token/ERC20/IERC20.sol","token/ERC20/extensions/draft-ERC20Permit.sol","utils/Context.sol"],"references":[],"urls":[]},"mocks/SafeMathMock.sol":{"checksum":{"algorithm":"md5","hash":"0x0f2e411c240cab2951bf7856ffe04b98"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/math/SafeMath.sol\";\n\ncontract SafeMathMock {\n    function tryAdd(uint256 a, uint256 b) public pure returns (bool flag, uint256 value) {\n        return SafeMath.tryAdd(a, b);\n    }\n\n    function trySub(uint256 a, uint256 b) public pure returns (bool flag, uint256 value) {\n        return SafeMath.trySub(a, b);\n    }\n\n    function tryMul(uint256 a, uint256 b) public pure returns (bool flag, uint256 value) {\n        return SafeMath.tryMul(a, b);\n    }\n\n    function tryDiv(uint256 a, uint256 b) public pure returns (bool flag, uint256 value) {\n        return SafeMath.tryDiv(a, b);\n    }\n\n    function tryMod(uint256 a, uint256 b) public pure returns (bool flag, uint256 value) {\n        return SafeMath.tryMod(a, b);\n    }\n\n    // using the do* naming convention to avoid warnings due to clashing opcode names\n\n    function doAdd(uint256 a, uint256 b) public pure returns (uint256) {\n        return SafeMath.add(a, b);\n    }\n\n    function doSub(uint256 a, uint256 b) public pure returns (uint256) {\n        return SafeMath.sub(a, b);\n    }\n\n    function doMul(uint256 a, uint256 b) public pure returns (uint256) {\n        return SafeMath.mul(a, b);\n    }\n\n    function doDiv(uint256 a, uint256 b) public pure returns (uint256) {\n        return SafeMath.div(a, b);\n    }\n\n    function doMod(uint256 a, uint256 b) public pure returns (uint256) {\n        return SafeMath.mod(a, b);\n    }\n\n    function subWithMessage(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) public pure returns (uint256) {\n        return SafeMath.sub(a, b, errorMessage);\n    }\n\n    function divWithMessage(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) public pure returns (uint256) {\n        return SafeMath.div(a, b, errorMessage);\n    }\n\n    function modWithMessage(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) public pure returns (uint256) {\n        return SafeMath.mod(a, b, errorMessage);\n    }\n\n    function addMemoryCheck() public pure returns (uint256 mem) {\n        uint256 length = 32;\n        assembly {\n            mem := mload(0x40)\n        }\n        for (uint256 i = 0; i < length; ++i) {\n            SafeMath.add(1, 1);\n        }\n        assembly {\n            mem := sub(mload(0x40), mem)\n        }\n    }\n\n    function subMemoryCheck() public pure returns (uint256 mem) {\n        uint256 length = 32;\n        assembly {\n            mem := mload(0x40)\n        }\n        for (uint256 i = 0; i < length; ++i) {\n            SafeMath.sub(1, 1);\n        }\n        assembly {\n            mem := sub(mload(0x40), mem)\n        }\n    }\n\n    function mulMemoryCheck() public pure returns (uint256 mem) {\n        uint256 length = 32;\n        assembly {\n            mem := mload(0x40)\n        }\n        for (uint256 i = 0; i < length; ++i) {\n            SafeMath.mul(1, 1);\n        }\n        assembly {\n            mem := sub(mload(0x40), mem)\n        }\n    }\n\n    function divMemoryCheck() public pure returns (uint256 mem) {\n        uint256 length = 32;\n        assembly {\n            mem := mload(0x40)\n        }\n        for (uint256 i = 0; i < length; ++i) {\n            SafeMath.div(1, 1);\n        }\n        assembly {\n            mem := sub(mload(0x40), mem)\n        }\n    }\n\n    function modMemoryCheck() public pure returns (uint256 mem) {\n        uint256 length = 32;\n        assembly {\n            mem := mload(0x40)\n        }\n        for (uint256 i = 0; i < length; ++i) {\n            SafeMath.mod(1, 1);\n        }\n        assembly {\n            mem := sub(mload(0x40), mem)\n        }\n    }\n}\n","imports":["utils/math/SafeMath.sol"],"references":[],"urls":[]},"mocks/SignatureCheckerMock.sol":{"checksum":{"algorithm":"md5","hash":"0x3d0fda24d5d77624d5a7b158a6762681"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/cryptography/SignatureChecker.sol\";\n\ncontract SignatureCheckerMock {\n    using SignatureChecker for address;\n\n    function isValidSignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) public view returns (bool) {\n        return signer.isValidSignatureNow(hash, signature);\n    }\n}\n","imports":["utils/cryptography/SignatureChecker.sol"],"references":[],"urls":[]},"mocks/SignedMathMock.sol":{"checksum":{"algorithm":"md5","hash":"0x308d0dce452ce69f428e742968d1adc2"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/math/SignedMath.sol\";\n\ncontract SignedMathMock {\n    function max(int256 a, int256 b) public pure returns (int256) {\n        return SignedMath.max(a, b);\n    }\n\n    function min(int256 a, int256 b) public pure returns (int256) {\n        return SignedMath.min(a, b);\n    }\n\n    function average(int256 a, int256 b) public pure returns (int256) {\n        return SignedMath.average(a, b);\n    }\n\n    function abs(int256 n) public pure returns (uint256) {\n        return SignedMath.abs(n);\n    }\n}\n","imports":["utils/math/SignedMath.sol"],"references":[],"urls":[]},"mocks/SignedSafeMathMock.sol":{"checksum":{"algorithm":"md5","hash":"0xc0abc8207b2fe94f7e6e14bc8f32e130"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/math/SignedSafeMath.sol\";\n\ncontract SignedSafeMathMock {\n    function mul(int256 a, int256 b) public pure returns (int256) {\n        return SignedSafeMath.mul(a, b);\n    }\n\n    function div(int256 a, int256 b) public pure returns (int256) {\n        return SignedSafeMath.div(a, b);\n    }\n\n    function sub(int256 a, int256 b) public pure returns (int256) {\n        return SignedSafeMath.sub(a, b);\n    }\n\n    function add(int256 a, int256 b) public pure returns (int256) {\n        return SignedSafeMath.add(a, b);\n    }\n}\n","imports":["utils/math/SignedSafeMath.sol"],"references":[],"urls":[]},"mocks/SingleInheritanceInitializableMocks.sol":{"checksum":{"algorithm":"md5","hash":"0xa0f7ac0b67fdf84c854701706691731e"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @title MigratableMockV1\n * @dev This contract is a mock to test initializable functionality through migrations\n */\ncontract MigratableMockV1 is Initializable {\n    uint256 public x;\n\n    function initialize(uint256 value) public payable initializer {\n        x = value;\n    }\n}\n\n/**\n * @title MigratableMockV2\n * @dev This contract is a mock to test migratable functionality with params\n */\ncontract MigratableMockV2 is MigratableMockV1 {\n    bool internal _migratedV2;\n    uint256 public y;\n\n    function migrate(uint256 value, uint256 anotherValue) public payable {\n        require(!_migratedV2);\n        x = value;\n        y = anotherValue;\n        _migratedV2 = true;\n    }\n}\n\n/**\n * @title MigratableMockV3\n * @dev This contract is a mock to test migratable functionality without params\n */\ncontract MigratableMockV3 is MigratableMockV2 {\n    bool internal _migratedV3;\n\n    function migrate() public payable {\n        require(!_migratedV3);\n        uint256 oldX = x;\n        x = y;\n        y = oldX;\n        _migratedV3 = true;\n    }\n}\n","imports":["proxy/utils/Initializable.sol"],"references":[],"urls":[]},"mocks/StorageSlotMock.sol":{"checksum":{"algorithm":"md5","hash":"0x681082aac12d55520958e456fe2a8850"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/StorageSlot.sol\";\n\ncontract StorageSlotMock {\n    using StorageSlot for bytes32;\n\n    function setBoolean(bytes32 slot, bool value) public {\n        slot.getBooleanSlot().value = value;\n    }\n\n    function setAddress(bytes32 slot, address value) public {\n        slot.getAddressSlot().value = value;\n    }\n\n    function setBytes32(bytes32 slot, bytes32 value) public {\n        slot.getBytes32Slot().value = value;\n    }\n\n    function setUint256(bytes32 slot, uint256 value) public {\n        slot.getUint256Slot().value = value;\n    }\n\n    function getBoolean(bytes32 slot) public view returns (bool) {\n        return slot.getBooleanSlot().value;\n    }\n\n    function getAddress(bytes32 slot) public view returns (address) {\n        return slot.getAddressSlot().value;\n    }\n\n    function getBytes32(bytes32 slot) public view returns (bytes32) {\n        return slot.getBytes32Slot().value;\n    }\n\n    function getUint256(bytes32 slot) public view returns (uint256) {\n        return slot.getUint256Slot().value;\n    }\n}\n","imports":["utils/StorageSlot.sol"],"references":[],"urls":[]},"mocks/StringsMock.sol":{"checksum":{"algorithm":"md5","hash":"0xb1c44ef7e61d3f0721b8430a4b741aae"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Strings.sol\";\n\ncontract StringsMock {\n    function fromUint256(uint256 value) public pure returns (string memory) {\n        return Strings.toString(value);\n    }\n\n    function fromUint256Hex(uint256 value) public pure returns (string memory) {\n        return Strings.toHexString(value);\n    }\n\n    function fromUint256HexFixed(uint256 value, uint256 length) public pure returns (string memory) {\n        return Strings.toHexString(value, length);\n    }\n\n    function fromAddressHexFixed(address addr) public pure returns (string memory) {\n        return Strings.toHexString(addr);\n    }\n}\n","imports":["utils/Strings.sol"],"references":[],"urls":[]},"mocks/TimersBlockNumberImpl.sol":{"checksum":{"algorithm":"md5","hash":"0x251e6f75ef0655071e414aa17f406ef0"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Timers.sol\";\n\ncontract TimersBlockNumberImpl {\n    using Timers for Timers.BlockNumber;\n\n    Timers.BlockNumber private _timer;\n\n    function getDeadline() public view returns (uint64) {\n        return _timer.getDeadline();\n    }\n\n    function setDeadline(uint64 timestamp) public {\n        _timer.setDeadline(timestamp);\n    }\n\n    function reset() public {\n        _timer.reset();\n    }\n\n    function isUnset() public view returns (bool) {\n        return _timer.isUnset();\n    }\n\n    function isStarted() public view returns (bool) {\n        return _timer.isStarted();\n    }\n\n    function isPending() public view returns (bool) {\n        return _timer.isPending();\n    }\n\n    function isExpired() public view returns (bool) {\n        return _timer.isExpired();\n    }\n}\n","imports":["utils/Timers.sol"],"references":[],"urls":[]},"mocks/TimersTimestampImpl.sol":{"checksum":{"algorithm":"md5","hash":"0x4da7cc0f188c4b4b0571dd3741158dd0"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Timers.sol\";\n\ncontract TimersTimestampImpl {\n    using Timers for Timers.Timestamp;\n\n    Timers.Timestamp private _timer;\n\n    function getDeadline() public view returns (uint64) {\n        return _timer.getDeadline();\n    }\n\n    function setDeadline(uint64 timestamp) public {\n        _timer.setDeadline(timestamp);\n    }\n\n    function reset() public {\n        _timer.reset();\n    }\n\n    function isUnset() public view returns (bool) {\n        return _timer.isUnset();\n    }\n\n    function isStarted() public view returns (bool) {\n        return _timer.isStarted();\n    }\n\n    function isPending() public view returns (bool) {\n        return _timer.isPending();\n    }\n\n    function isExpired() public view returns (bool) {\n        return _timer.isExpired();\n    }\n}\n","imports":["utils/Timers.sol"],"references":[],"urls":[]},"mocks/UUPS/UUPSLegacy.sol":{"checksum":{"algorithm":"md5","hash":"0xaa65be99dff42d67f13f46a97c8f5b47"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./UUPSUpgradeableMock.sol\";\n\n// This contract implements the pre-4.5 UUPS upgrade function with a rollback test.\n// It's used to test that newer UUPS contracts are considered valid upgrades by older UUPS contracts.\ncontract UUPSUpgradeableLegacyMock is UUPSUpgradeableMock {\n    // Inlined from ERC1967Upgrade\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    // ERC1967Upgrade._setImplementation is private so we reproduce it here.\n    // An extra underscore prevents a name clash error.\n    function __setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    function _upgradeToAndCallSecureLegacyV1(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        __setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    // hooking into the old mechanism\n    function upgradeTo(address newImplementation) external virtual override {\n        _upgradeToAndCallSecureLegacyV1(newImplementation, bytes(\"\"), false);\n    }\n\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual override {\n        _upgradeToAndCallSecureLegacyV1(newImplementation, data, false);\n    }\n}\n","imports":["mocks/UUPS/UUPSUpgradeableMock.sol"],"references":[],"urls":[]},"mocks/UUPS/UUPSUpgradeableMock.sol":{"checksum":{"algorithm":"md5","hash":"0xd61a2048368cbcaf9dd1b9cfa383987a"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../CountersImpl.sol\";\nimport \"../../proxy/utils/UUPSUpgradeable.sol\";\n\ncontract UUPSUpgradeableMock is CountersImpl, UUPSUpgradeable {\n    // Not having any checks in this function is dangerous! Do not do this outside tests!\n    function _authorizeUpgrade(address) internal virtual override {}\n}\n\ncontract UUPSUpgradeableUnsafeMock is UUPSUpgradeableMock {\n    function upgradeTo(address newImplementation) external virtual override {\n        ERC1967Upgrade._upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual override {\n        ERC1967Upgrade._upgradeToAndCall(newImplementation, data, false);\n    }\n}\n","imports":["mocks/CountersImpl.sol","proxy/utils/UUPSUpgradeable.sol"],"references":["mocks/UUPS/UUPSLegacy.sol"],"urls":[]},"mocks/VotesMock.sol":{"checksum":{"algorithm":"md5","hash":"0xbd5c2352015a3953b6ec7532d85bcd48"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../governance/utils/Votes.sol\";\n\ncontract VotesMock is Votes {\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _owners;\n\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    function getTotalSupply() public view returns (uint256) {\n        return _getTotalSupply();\n    }\n\n    function delegate(address account, address newDelegation) public {\n        return _delegate(account, newDelegation);\n    }\n\n    function _getVotingUnits(address account) internal view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function mint(address account, uint256 voteId) external {\n        _balances[account] += 1;\n        _owners[voteId] = account;\n        _transferVotingUnits(address(0), account, 1);\n    }\n\n    function burn(uint256 voteId) external {\n        address owner = _owners[voteId];\n        _balances[owner] -= 1;\n        _transferVotingUnits(owner, address(0), 1);\n    }\n\n    function getChainId() external view returns (uint256) {\n        return block.chainid;\n    }\n}\n","imports":["governance/utils/Votes.sol"],"references":[],"urls":[]},"mocks/compound/CompTimelock.sol":{"checksum":{"algorithm":"md5","hash":"0xfd7ad8322337afa2448279b3c8c88b3b"},"content":"// SPDX-License-Identifier: BSD-3-Clause\n// solhint-disable private-vars-leading-underscore\n/**\n * Copyright 2020 Compound Labs, Inc.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the\n * following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following\n *    disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the\n *    following disclaimer in the documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote\n *    products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npragma solidity ^0.8.0;\n\ncontract CompTimelock {\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint256 indexed newDelay);\n    event CancelTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event ExecuteTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event QueueTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n\n    uint256 public constant GRACE_PERIOD = 14 days;\n    uint256 public constant MINIMUM_DELAY = 2 days;\n    uint256 public constant MAXIMUM_DELAY = 30 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint256 public delay;\n\n    mapping(bytes32 => bool) public queuedTransactions;\n\n    constructor(address admin_, uint256 delay_) {\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    receive() external payable {}\n\n    function setDelay(uint256 delay_) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public {\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(\n            eta >= getBlockTimestamp() + delay,\n            \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\n        );\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta + GRACE_PERIOD, \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint256) {\n        // solium-disable-next-line security/no-block-members\n        return block.timestamp;\n    }\n}\n","imports":[],"references":[],"urls":[]},"mocks/crosschain/bridges.sol":{"checksum":{"algorithm":"md5","hash":"0xc8545d2e6348390d9b0e43c1b612364e"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/Address.sol\";\nimport \"../../vendor/polygon/IFxMessageProcessor.sol\";\n\nabstract contract BaseRelayMock {\n    // needed to parse custom errors\n    error NotCrossChainCall();\n    error InvalidCrossChainSender(address sender, address expected);\n\n    address internal _currentSender;\n\n    function relayAs(\n        address target,\n        bytes calldata data,\n        address sender\n    ) external virtual {\n        address previousSender = _currentSender;\n\n        _currentSender = sender;\n\n        (bool success, bytes memory returndata) = target.call(data);\n        Address.verifyCallResult(success, returndata, \"low-level call reverted\");\n\n        _currentSender = previousSender;\n    }\n}\n\n/**\n * AMB\n */\ncontract BridgeAMBMock is BaseRelayMock {\n    function messageSender() public view returns (address) {\n        return _currentSender;\n    }\n}\n\n/**\n * Arbitrum\n */\ncontract BridgeArbitrumL1Mock is BaseRelayMock {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address public immutable inbox = address(new BridgeArbitrumL1Inbox());\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address public immutable outbox = address(new BridgeArbitrumL1Outbox());\n\n    function activeOutbox() public view returns (address) {\n        return outbox;\n    }\n\n    function currentSender() public view returns (address) {\n        return _currentSender;\n    }\n}\n\ncontract BridgeArbitrumL1Inbox {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address public immutable bridge = msg.sender;\n}\n\ncontract BridgeArbitrumL1Outbox {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address public immutable bridge = msg.sender;\n\n    function l2ToL1Sender() public view returns (address) {\n        return BridgeArbitrumL1Mock(bridge).currentSender();\n    }\n}\n\ncontract BridgeArbitrumL2Mock is BaseRelayMock {\n    function isTopLevelCall() public view returns (bool) {\n        return _currentSender != address(0);\n    }\n\n    function wasMyCallersAddressAliased() public pure returns (bool) {\n        return true;\n    }\n\n    function myCallersAddressWithoutAliasing() public view returns (address) {\n        return _currentSender;\n    }\n}\n\n/**\n * Optimism\n */\ncontract BridgeOptimismMock is BaseRelayMock {\n    function xDomainMessageSender() public view returns (address) {\n        return _currentSender;\n    }\n}\n\n/**\n * Polygon\n */\ncontract BridgePolygonChildMock is BaseRelayMock {\n    function relayAs(\n        address target,\n        bytes calldata data,\n        address sender\n    ) external override {\n        IFxMessageProcessor(target).processMessageFromRoot(0, sender, data);\n    }\n}\n","imports":["vendor/polygon/IFxMessageProcessor.sol","utils/Address.sol"],"references":[],"urls":[]},"mocks/crosschain/receivers.sol":{"checksum":{"algorithm":"md5","hash":"0xfe0f8e2c2115a7f381ea427d69b3cf55"},"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"../../access/Ownable.sol\";\nimport \"../../crosschain/amb/CrossChainEnabledAMB.sol\";\nimport \"../../crosschain/arbitrum/CrossChainEnabledArbitrumL1.sol\";\nimport \"../../crosschain/arbitrum/CrossChainEnabledArbitrumL2.sol\";\nimport \"../../crosschain/optimism/CrossChainEnabledOptimism.sol\";\nimport \"../../crosschain/polygon/CrossChainEnabledPolygonChild.sol\";\n\nabstract contract Receiver is CrossChainEnabled {\n    // we don't use Ownable because it messes up testing for the upgradeable contracts\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address public immutable owner = msg.sender;\n\n    function crossChainRestricted() external onlyCrossChain {}\n\n    function crossChainOwnerRestricted() external onlyCrossChainSender(owner) {}\n}\n\n/**\n * AMB\n */\ncontract CrossChainEnabledAMBMock is Receiver, CrossChainEnabledAMB {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address bridge) CrossChainEnabledAMB(bridge) {}\n}\n\n/**\n * Arbitrum\n */\ncontract CrossChainEnabledArbitrumL1Mock is Receiver, CrossChainEnabledArbitrumL1 {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address bridge) CrossChainEnabledArbitrumL1(bridge) {}\n}\n\ncontract CrossChainEnabledArbitrumL2Mock is Receiver, CrossChainEnabledArbitrumL2 {}\n\n/**\n * Optimism\n */\ncontract CrossChainEnabledOptimismMock is Receiver, CrossChainEnabledOptimism {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address bridge) CrossChainEnabledOptimism(bridge) {}\n}\n\n/**\n * Polygon\n */\ncontract CrossChainEnabledPolygonChildMock is Receiver, CrossChainEnabledPolygonChild {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address bridge) CrossChainEnabledPolygonChild(bridge) {}\n}\n","imports":["crosschain/polygon/CrossChainEnabledPolygonChild.sol","crosschain/arbitrum/CrossChainEnabledArbitrumL2.sol","crosschain/optimism/CrossChainEnabledOptimism.sol","crosschain/arbitrum/CrossChainEnabledArbitrumL1.sol","access/Ownable.sol","crosschain/amb/CrossChainEnabledAMB.sol"],"references":[],"urls":[]},"mocks/wizard/MyGovernor1.sol":{"checksum":{"algorithm":"md5","hash":"0xaee784c515ed752a3028c77aacfe94fe"},"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"../../governance/Governor.sol\";\nimport \"../../governance/extensions/GovernorCountingSimple.sol\";\nimport \"../../governance/extensions/GovernorVotes.sol\";\nimport \"../../governance/extensions/GovernorVotesQuorumFraction.sol\";\nimport \"../../governance/extensions/GovernorTimelockControl.sol\";\n\ncontract MyGovernor1 is\n    Governor,\n    GovernorTimelockControl,\n    GovernorVotes,\n    GovernorVotesQuorumFraction,\n    GovernorCountingSimple\n{\n    constructor(IVotes _token, TimelockController _timelock)\n        Governor(\"MyGovernor\")\n        GovernorVotes(_token)\n        GovernorVotesQuorumFraction(4)\n        GovernorTimelockControl(_timelock)\n    {}\n\n    function votingDelay() public pure override returns (uint256) {\n        return 1; // 1 block\n    }\n\n    function votingPeriod() public pure override returns (uint256) {\n        return 45818; // 1 week\n    }\n\n    // The following functions are overrides required by Solidity.\n\n    function quorum(uint256 blockNumber)\n        public\n        view\n        override(IGovernor, GovernorVotesQuorumFraction)\n        returns (uint256)\n    {\n        return super.quorum(blockNumber);\n    }\n\n    function state(uint256 proposalId) public view override(Governor, GovernorTimelockControl) returns (ProposalState) {\n        return super.state(proposalId);\n    }\n\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public override(Governor, IGovernor) returns (uint256) {\n        return super.propose(targets, values, calldatas, description);\n    }\n\n    function _execute(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(Governor, GovernorTimelockControl) {\n        super._execute(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(Governor, GovernorTimelockControl) returns (uint256) {\n        return super._cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    function _executor() internal view override(Governor, GovernorTimelockControl) returns (address) {\n        return super._executor();\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(Governor, GovernorTimelockControl)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n","imports":["governance/extensions/GovernorCountingSimple.sol","governance/extensions/GovernorTimelockControl.sol","governance/Governor.sol","governance/extensions/GovernorVotes.sol","governance/extensions/GovernorVotesQuorumFraction.sol"],"references":[],"urls":[]},"mocks/wizard/MyGovernor2.sol":{"checksum":{"algorithm":"md5","hash":"0xc6df239ecee0f2179eb306643bfb0774"},"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"../../governance/Governor.sol\";\nimport \"../../governance/extensions/GovernorProposalThreshold.sol\";\nimport \"../../governance/extensions/GovernorCountingSimple.sol\";\nimport \"../../governance/extensions/GovernorVotes.sol\";\nimport \"../../governance/extensions/GovernorVotesQuorumFraction.sol\";\nimport \"../../governance/extensions/GovernorTimelockControl.sol\";\n\ncontract MyGovernor2 is\n    Governor,\n    GovernorTimelockControl,\n    GovernorProposalThreshold,\n    GovernorVotes,\n    GovernorVotesQuorumFraction,\n    GovernorCountingSimple\n{\n    constructor(IVotes _token, TimelockController _timelock)\n        Governor(\"MyGovernor\")\n        GovernorVotes(_token)\n        GovernorVotesQuorumFraction(4)\n        GovernorTimelockControl(_timelock)\n    {}\n\n    function votingDelay() public pure override returns (uint256) {\n        return 1; // 1 block\n    }\n\n    function votingPeriod() public pure override returns (uint256) {\n        return 45818; // 1 week\n    }\n\n    function proposalThreshold() public pure override returns (uint256) {\n        return 1000e18;\n    }\n\n    // The following functions are overrides required by Solidity.\n\n    function quorum(uint256 blockNumber)\n        public\n        view\n        override(IGovernor, GovernorVotesQuorumFraction)\n        returns (uint256)\n    {\n        return super.quorum(blockNumber);\n    }\n\n    function state(uint256 proposalId) public view override(Governor, GovernorTimelockControl) returns (ProposalState) {\n        return super.state(proposalId);\n    }\n\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public override(Governor, GovernorProposalThreshold, IGovernor) returns (uint256) {\n        return super.propose(targets, values, calldatas, description);\n    }\n\n    function _execute(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(Governor, GovernorTimelockControl) {\n        super._execute(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(Governor, GovernorTimelockControl) returns (uint256) {\n        return super._cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    function _executor() internal view override(Governor, GovernorTimelockControl) returns (address) {\n        return super._executor();\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(Governor, GovernorTimelockControl)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n","imports":["governance/extensions/GovernorCountingSimple.sol","governance/extensions/GovernorTimelockControl.sol","governance/extensions/GovernorProposalThreshold.sol","governance/Governor.sol","governance/extensions/GovernorVotes.sol","governance/extensions/GovernorVotesQuorumFraction.sol"],"references":[],"urls":[]},"mocks/wizard/MyGovernor3.sol":{"checksum":{"algorithm":"md5","hash":"0xda0bb04a6c63bed9771a552cfb0a6eec"},"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"../../governance/Governor.sol\";\nimport \"../../governance/compatibility/GovernorCompatibilityBravo.sol\";\nimport \"../../governance/extensions/GovernorVotes.sol\";\nimport \"../../governance/extensions/GovernorVotesQuorumFraction.sol\";\nimport \"../../governance/extensions/GovernorTimelockControl.sol\";\n\ncontract MyGovernor is\n    Governor,\n    GovernorTimelockControl,\n    GovernorCompatibilityBravo,\n    GovernorVotes,\n    GovernorVotesQuorumFraction\n{\n    constructor(IVotes _token, TimelockController _timelock)\n        Governor(\"MyGovernor\")\n        GovernorVotes(_token)\n        GovernorVotesQuorumFraction(4)\n        GovernorTimelockControl(_timelock)\n    {}\n\n    function votingDelay() public pure override returns (uint256) {\n        return 1; // 1 block\n    }\n\n    function votingPeriod() public pure override returns (uint256) {\n        return 45818; // 1 week\n    }\n\n    function proposalThreshold() public pure override returns (uint256) {\n        return 1000e18;\n    }\n\n    // The following functions are overrides required by Solidity.\n\n    function quorum(uint256 blockNumber)\n        public\n        view\n        override(IGovernor, GovernorVotesQuorumFraction)\n        returns (uint256)\n    {\n        return super.quorum(blockNumber);\n    }\n\n    function state(uint256 proposalId)\n        public\n        view\n        override(Governor, IGovernor, GovernorTimelockControl)\n        returns (ProposalState)\n    {\n        return super.state(proposalId);\n    }\n\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public override(Governor, GovernorCompatibilityBravo, IGovernor) returns (uint256) {\n        return super.propose(targets, values, calldatas, description);\n    }\n\n    function _execute(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(Governor, GovernorTimelockControl) {\n        super._execute(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(Governor, GovernorTimelockControl) returns (uint256) {\n        return super._cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    function _executor() internal view override(Governor, GovernorTimelockControl) returns (address) {\n        return super._executor();\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(Governor, IERC165, GovernorTimelockControl)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n","imports":["governance/extensions/GovernorTimelockControl.sol","governance/Governor.sol","governance/extensions/GovernorVotesQuorumFraction.sol","governance/extensions/GovernorVotes.sol","governance/compatibility/GovernorCompatibilityBravo.sol"],"references":[],"urls":[]},"proxy/Clones.sol":{"checksum":{"algorithm":"md5","hash":"0x8d03477cb67af28579646fdb2508ddb0"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n","imports":[],"references":["mocks/ClonesMock.sol"],"urls":[]},"proxy/ERC1967/ERC1967Proxy.sol":{"checksum":{"algorithm":"md5","hash":"0x3fc3c7c0a2956f36e766691bb9473b06"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n","imports":["proxy/ERC1967/ERC1967Upgrade.sol","proxy/Proxy.sol"],"references":["proxy/transparent/TransparentUpgradeableProxy.sol"],"urls":[]},"proxy/ERC1967/ERC1967Upgrade.sol":{"checksum":{"algorithm":"md5","hash":"0x6baa887a798e95b14f34e093f117e9b2"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n","imports":["interfaces/draft-IERC1822.sol","proxy/beacon/IBeacon.sol","utils/StorageSlot.sol","utils/Address.sol"],"references":["proxy/ERC1967/ERC1967Proxy.sol","proxy/beacon/BeaconProxy.sol","proxy/utils/UUPSUpgradeable.sol"],"urls":[]},"proxy/Proxy.sol":{"checksum":{"algorithm":"md5","hash":"0x40b3d81a836d50ff47e03893dcaaf204"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n","imports":[],"references":["proxy/ERC1967/ERC1967Proxy.sol","proxy/beacon/BeaconProxy.sol"],"urls":[]},"proxy/README.adoc":{"checksum":{"algorithm":"md5","hash":"0xc41d7b5e32024b7c65e8cf5111ebbd36"},"content":"= Proxies\n\n[.readme-notice]\nNOTE: This document is better viewed at https://docs.openzeppelin.com/contracts/api/proxy\n\nThis is a low-level set of contracts implementing different proxy patterns with and without upgradeability. For an in-depth overview of this pattern check out the xref:upgrades-plugins::proxies.adoc[Proxy Upgrade Pattern] page.\n\nMost of the proxies below are built on an abstract base contract.\n\n- {Proxy}: Abstract contract implementing the core delegation functionality.\n\nIn order to avoid clashes with the storage variables of the implementation contract behind a proxy, we use https://eips.ethereum.org/EIPS/eip-1967[EIP1967] storage slots.\n\n- {ERC1967Upgrade}: Internal functions to get and set the storage slots defined in EIP1967.\n- {ERC1967Proxy}: A proxy using EIP1967 storage slots. Not upgradeable by default.\n\nThere are two alternative ways to add upgradeability to an ERC1967 proxy. Their differences are explained below in <<transparent-vs-uups>>.\n\n- {TransparentUpgradeableProxy}: A proxy with a built in admin and upgrade interface.\n- {UUPSUpgradeable}: An upgradeability mechanism to be included in the implementation contract.\n\nCAUTION: Using upgradeable proxies correctly and securely is a difficult task that requires deep knowledge of the proxy pattern, Solidity, and the EVM. Unless you want a lot of low level control, we recommend using the xref:upgrades-plugins::index.adoc[OpenZeppelin Upgrades Plugins] for Truffle and Hardhat.\n\nA different family of proxies are beacon proxies. This pattern, popularized by Dharma, allows multiple proxies to be upgraded to a different implementation in a single transaction.\n\n- {BeaconProxy}: A proxy that retrieves its implementation from a beacon contract.\n- {UpgradeableBeacon}: A beacon contract with a built in admin that can upgrade the {BeaconProxy} pointing to it.\n\nIn this pattern, the proxy contract doesn't hold the implementation address in storage like an ERC1967 proxy, instead the address is stored in a separate beacon contract. The `upgrade` operations that are sent to the beacon instead of to the proxy contract, and all proxies that follow that beacon are automatically upgraded.\n\nOutside the realm of upgradeability, proxies can also be useful to make cheap contract clones, such as those created by an on-chain factory contract that creates many instances of the same contract. These instances are designed to be both cheap to deploy, and cheap to call.\n\n- {Clones}: A library that can deploy cheap minimal non-upgradeable proxies.\n\n[[transparent-vs-uups]]\n== Transparent vs UUPS Proxies\n\nThe original proxies included in OpenZeppelin followed the https://blog.openzeppelin.com/the-transparent-proxy-pattern/[Transparent Proxy Pattern]. While this pattern is still provided, our recommendation is now shifting towards UUPS proxies, which are both lightweight and versatile. The name UUPS comes from https://eips.ethereum.org/EIPS/eip-1822[EIP1822], which first documented the pattern.\n\nWhile both of these share the same interface for upgrades, in UUPS proxies the upgrade is handled by the implementation, and can eventually be removed. Transparent proxies, on the other hand, include the upgrade and admin logic in the proxy itself. This means {TransparentUpgradeableProxy} is more expensive to deploy than what is possible with UUPS proxies.\n\nUUPS proxies are implemented using an {ERC1967Proxy}. Note that this proxy is not by itself upgradeable. It is the role of the implementation to include, alongside the contract's logic, all the code necessary to update the implementation's address that is stored at a specific slot in the proxy's storage space. This is where the {UUPSUpgradeable} contract comes in. Inheriting from it (and overriding the {xref-UUPSUpgradeable-_authorizeUpgrade-address-}[`_authorizeUpgrade`] function with the relevant access control mechanism) will turn your contract into a UUPS compliant implementation.\n\nNote that since both proxies use the same storage slot for the implementation address, using a UUPS compliant implementation with a {TransparentUpgradeableProxy} might allow non-admins to perform upgrade operations.\n\nBy default, the upgrade functionality included in {UUPSUpgradeable} contains a security mechanism that will prevent any upgrades to a non UUPS compliant implementation. This prevents upgrades to an implementation contract that wouldn't contain the necessary upgrade mechanism, as it would lock the upgradeability of the proxy forever. This security mechanism can be bypassed by either of:\n\n- Adding a flag mechanism in the implementation that will disable the upgrade function when triggered.\n- Upgrading to an implementation that features an upgrade mechanism without the additional security check, and then upgrading again to another implementation without the upgrade mechanism.\n\nThe current implementation of this security mechanism uses https://eips.ethereum.org/EIPS/eip-1822[EIP1822] to detect the storage slot used by the implementation. A previous implementation, now deprecated, relied on a rollback check. It is possible to upgrade from a contract using the old mechanism to a new one. The inverse is however not possible, as old implementations (before version 4.5) did not include the `ERC1822` interface.\n\n== Core\n\n{{Proxy}}\n\n== ERC1967\n\n{{ERC1967Proxy}}\n\n{{ERC1967Upgrade}}\n\n== Transparent Proxy\n\n{{TransparentUpgradeableProxy}}\n\n{{ProxyAdmin}}\n\n== Beacon\n\n{{BeaconProxy}}\n\n{{IBeacon}}\n\n{{UpgradeableBeacon}}\n\n== Minimal Clones\n\n{{Clones}}\n\n== Utils\n\n{{Initializable}}\n\n{{UUPSUpgradeable}}\n","imports":[],"references":[],"urls":[]},"proxy/beacon/BeaconProxy.sol":{"checksum":{"algorithm":"md5","hash":"0xdc9dcb6e542154d9cfbfaece646c1092"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../Proxy.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}\n","imports":["proxy/beacon/IBeacon.sol","proxy/ERC1967/ERC1967Upgrade.sol","proxy/Proxy.sol"],"references":[],"urls":[]},"proxy/beacon/IBeacon.sol":{"checksum":{"algorithm":"md5","hash":"0xb6bd23bf19e90b771337037706470933"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n","imports":[],"references":["proxy/ERC1967/ERC1967Upgrade.sol","proxy/beacon/BeaconProxy.sol","proxy/beacon/UpgradeableBeacon.sol"],"urls":[]},"proxy/beacon/UpgradeableBeacon.sol":{"checksum":{"algorithm":"md5","hash":"0x8ffefb755605824cf730ce4092b2f581"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../../access/Ownable.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    constructor(address implementation_) {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual override returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableBeacon: implementation is not a contract\");\n        _implementation = newImplementation;\n    }\n}\n","imports":["proxy/beacon/IBeacon.sol","utils/Address.sol","access/Ownable.sol"],"references":[],"urls":[]},"proxy/transparent/ProxyAdmin.sol":{"checksum":{"algorithm":"md5","hash":"0xa947492251ac15d6bfd899c9fdb4d82b"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n","imports":["access/Ownable.sol","proxy/transparent/TransparentUpgradeableProxy.sol"],"references":[],"urls":[]},"proxy/transparent/TransparentUpgradeableProxy.sol":{"checksum":{"algorithm":"md5","hash":"0xea48b4a63fd733eec048191be006daa8"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n","imports":["proxy/ERC1967/ERC1967Proxy.sol"],"references":["proxy/transparent/ProxyAdmin.sol"],"urls":[]},"proxy/utils/Initializable.sol":{"checksum":{"algorithm":"md5","hash":"0xbcba485bbfd0aab6b8875b58224f6330"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n","imports":["utils/Address.sol"],"references":["mocks/MultipleInheritanceInitializableMocks.sol","mocks/SingleInheritanceInitializableMocks.sol","mocks/InitializableMock.sol","mocks/RegressionImplementation.sol"],"urls":[]},"proxy/utils/UUPSUpgradeable.sol":{"checksum":{"algorithm":"md5","hash":"0x5e95368c9b763cfa31ba0fe1309acc60"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is IERC1822Proxiable, ERC1967Upgrade {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate that the this implementation remains valid after an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n}\n","imports":["interfaces/draft-IERC1822.sol","proxy/ERC1967/ERC1967Upgrade.sol"],"references":["mocks/UUPS/UUPSUpgradeableMock.sol"],"urls":[]},"security/Pausable.sol":{"checksum":{"algorithm":"md5","hash":"0x25c8108f36fdd472bc78d4c4af240c11"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n","imports":["utils/Context.sol"],"references":["token/ERC1155/extensions/ERC1155Pausable.sol","token/ERC20/extensions/ERC20Pausable.sol","token/ERC721/extensions/ERC721Pausable.sol","mocks/PausableMock.sol"],"urls":[]},"security/PullPayment.sol":{"checksum":{"algorithm":"md5","hash":"0x1d368000dd657f1c37562ae4b728e220"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/PullPayment.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/escrow/Escrow.sol\";\n\n/**\n * @dev Simple implementation of a\n * https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls[pull-payment]\n * strategy, where the paying contract doesn't interact directly with the\n * receiver account, which must withdraw its payments itself.\n *\n * Pull-payments are often considered the best practice when it comes to sending\n * Ether, security-wise. It prevents recipients from blocking execution, and\n * eliminates reentrancy concerns.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n *\n * To use, derive from the `PullPayment` contract, and use {_asyncTransfer}\n * instead of Solidity's `transfer` function. Payees can query their due\n * payments with {payments}, and retrieve them with {withdrawPayments}.\n */\nabstract contract PullPayment {\n    Escrow private immutable _escrow;\n\n    constructor() {\n        _escrow = new Escrow();\n    }\n\n    /**\n     * @dev Withdraw accumulated payments, forwarding all gas to the recipient.\n     *\n     * Note that _any_ account can call this function, not just the `payee`.\n     * This means that contracts unaware of the `PullPayment` protocol can still\n     * receive funds this way, by having a separate account call\n     * {withdrawPayments}.\n     *\n     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.\n     * Make sure you trust the recipient, or are either following the\n     * checks-effects-interactions pattern or using {ReentrancyGuard}.\n     *\n     * @param payee Whose payments will be withdrawn.\n     *\n     * Causes the `escrow` to emit a {Withdrawn} event.\n     */\n    function withdrawPayments(address payable payee) public virtual {\n        _escrow.withdraw(payee);\n    }\n\n    /**\n     * @dev Returns the payments owed to an address.\n     * @param dest The creditor's address.\n     */\n    function payments(address dest) public view returns (uint256) {\n        return _escrow.depositsOf(dest);\n    }\n\n    /**\n     * @dev Called by the payer to store the sent amount as credit to be pulled.\n     * Funds sent in this way are stored in an intermediate {Escrow} contract, so\n     * there is no danger of them being spent before withdrawal.\n     *\n     * @param dest The destination address of the funds.\n     * @param amount The amount to transfer.\n     *\n     * Causes the `escrow` to emit a {Deposited} event.\n     */\n    function _asyncTransfer(address dest, uint256 amount) internal virtual {\n        _escrow.deposit{value: amount}(dest);\n    }\n}\n","imports":["utils/escrow/Escrow.sol"],"references":["mocks/PullPaymentMock.sol"],"urls":[]},"security/README.adoc":{"checksum":{"algorithm":"md5","hash":"0x2b5989b0e7173bedd19c78e182004c7f"},"content":"= Security\n\n[.readme-notice]\nNOTE: This document is better viewed at https://docs.openzeppelin.com/contracts/api/security\n\nThese contracts aim to cover common security practices.\n\n* {PullPayment}: A pattern that can be used to avoid reentrancy attacks.\n* {ReentrancyGuard}: A modifier that can prevent reentrancy during certain functions.\n* {Pausable}: A common emergency response mechanism that can pause functionality while a remediation is pending.\n\nTIP: For an overview on reentrancy and the possible mechanisms to prevent it, read our article https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n\n== Contracts\n\n{{PullPayment}}\n\n{{ReentrancyGuard}}\n\n{{Pausable}}\n","imports":[],"references":[],"urls":[]},"security/ReentrancyGuard.sol":{"checksum":{"algorithm":"md5","hash":"0x92f9448b23a90ea3bb932ee55cc3ccce"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n","imports":[],"references":["crosschain/polygon/CrossChainEnabledPolygonChild.sol","mocks/ReentrancyMock.sol"],"urls":[]},"token/ERC1155/ERC1155.sol":{"checksum":{"algorithm":"md5","hash":"0x9be05ac5a08ad0370e3cc36665ca490c"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n","imports":["token/ERC1155/extensions/IERC1155MetadataURI.sol","token/ERC1155/IERC1155.sol","utils/introspection/ERC165.sol","utils/Address.sol","token/ERC1155/IERC1155Receiver.sol","utils/Context.sol"],"references":["mocks/ERC1155Mock.sol","token/ERC1155/extensions/ERC1155Supply.sol","token/ERC1155/extensions/ERC1155Pausable.sol","token/ERC1155/presets/ERC1155PresetMinterPauser.sol","token/ERC1155/extensions/ERC1155URIStorage.sol","token/ERC1155/extensions/ERC1155Burnable.sol"],"urls":[]},"token/ERC1155/IERC1155.sol":{"checksum":{"algorithm":"md5","hash":"0xd5a8f6e07ca38ec384856cfe9f08a867"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n","imports":["utils/introspection/IERC165.sol"],"references":["token/ERC1155/extensions/IERC1155MetadataURI.sol","token/ERC1155/ERC1155.sol","interfaces/IERC1155.sol"],"urls":[]},"token/ERC1155/IERC1155Receiver.sol":{"checksum":{"algorithm":"md5","hash":"0x9f8822b72fe2702979e40160cb6d9636"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n","imports":["utils/introspection/IERC165.sol"],"references":["mocks/ERC1155ReceiverMock.sol","token/ERC1155/ERC1155.sol","interfaces/IERC1155Receiver.sol","governance/TimelockController.sol","governance/Governor.sol","token/ERC1155/utils/ERC1155Receiver.sol"],"urls":[]},"token/ERC1155/README.adoc":{"checksum":{"algorithm":"md5","hash":"0x97928eebcbed7d6e0bdee0a62b945742"},"content":"= ERC 1155\n\n[.readme-notice]\nNOTE: This document is better viewed at https://docs.openzeppelin.com/contracts/api/token/erc1155\n\nThis set of interfaces and contracts are all related to the https://eips.ethereum.org/EIPS/eip-1155[ERC1155 Multi Token Standard].\n\nThe EIP consists of three interfaces which fulfill different roles, found here as {IERC1155}, {IERC1155MetadataURI} and {IERC1155Receiver}.\n\n{ERC1155} implements the mandatory {IERC1155} interface, as well as the optional extension {IERC1155MetadataURI}, by relying on the substitution mechanism to use the same URI for all token types, dramatically reducing gas costs.\n\nAdditionally there are multiple custom extensions, including:\n\n* designation of addresses that can pause token transfers for all users ({ERC1155Pausable}).\n* destruction of own tokens ({ERC1155Burnable}).\n\nNOTE: This core set of contracts is designed to be unopinionated, allowing developers to access the internal functions in ERC1155 (such as <<ERC1155-_mint-address-uint256-uint256-bytes-,`_mint`>>) and expose them as external functions in the way they prefer. On the other hand, xref:ROOT:erc1155.adoc#Presets[ERC1155 Presets] (such as {ERC1155PresetMinterPauser}) are designed using opinionated patterns to provide developers with ready to use, deployable contracts.\n\n== Core\n\n{{IERC1155}}\n\n{{IERC1155MetadataURI}}\n\n{{ERC1155}}\n\n{{IERC1155Receiver}}\n\n{{ERC1155Receiver}}\n\n== Extensions\n\n{{ERC1155Pausable}}\n\n{{ERC1155Burnable}}\n\n{{ERC1155Supply}}\n\n{{ERC1155URIStorage}}\n\n== Presets\n\nThese contracts are preconfigured combinations of the above features. They can be used through inheritance or as models to copy and paste their source code.\n\n{{ERC1155PresetMinterPauser}}\n\n== Utilities\n\n{{ERC1155Holder}}\n","imports":[],"references":[],"urls":[]},"token/ERC1155/extensions/ERC1155Burnable.sol":{"checksum":{"algorithm":"md5","hash":"0x1b5f1bf9f75114e7bc22fd5fea1f87cd"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\n/**\n * @dev Extension of {ERC1155} that allows token holders to destroy both their\n * own tokens and those that they have been approved to use.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155Burnable is ERC1155 {\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n}\n","imports":["token/ERC1155/ERC1155.sol"],"references":["token/ERC1155/presets/ERC1155PresetMinterPauser.sol","mocks/ERC1155BurnableMock.sol"],"urls":[]},"token/ERC1155/extensions/ERC1155Pausable.sol":{"checksum":{"algorithm":"md5","hash":"0x8c76f015a31a093020b83ba53a33c84d"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC1155 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n    /**\n     * @dev See {ERC1155-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n","imports":["token/ERC1155/ERC1155.sol","security/Pausable.sol"],"references":["token/ERC1155/presets/ERC1155PresetMinterPauser.sol","mocks/ERC1155PausableMock.sol"],"urls":[]},"token/ERC1155/extensions/ERC1155Supply.sol":{"checksum":{"algorithm":"md5","hash":"0x6a99607f60a77d468b7ed41303ea4a6c"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/extensions/ERC1155Supply.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\n/**\n * @dev Extension of ERC1155 that adds tracking of total supply per id.\n *\n * Useful for scenarios where Fungible and Non-fungible tokens have to be\n * clearly identified. Note: While a totalSupply of 1 might mean the\n * corresponding is an NFT, there is no guarantees that no other token with the\n * same id are not going to be minted.\n */\nabstract contract ERC1155Supply is ERC1155 {\n    mapping(uint256 => uint256) private _totalSupply;\n\n    /**\n     * @dev Total amount of tokens in with a given id.\n     */\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    /**\n     * @dev Indicates whether any token exist with a given id, or not.\n     */\n    function exists(uint256 id) public view virtual returns (bool) {\n        return ERC1155Supply.totalSupply(id) > 0;\n    }\n\n    /**\n     * @dev See {ERC1155-_beforeTokenTransfer}.\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                _totalSupply[ids[i]] += amounts[i];\n            }\n        }\n\n        if (to == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                uint256 id = ids[i];\n                uint256 amount = amounts[i];\n                uint256 supply = _totalSupply[id];\n                require(supply >= amount, \"ERC1155: burn amount exceeds totalSupply\");\n                unchecked {\n                    _totalSupply[id] = supply - amount;\n                }\n            }\n        }\n    }\n}\n","imports":["token/ERC1155/ERC1155.sol"],"references":["mocks/ERC1155SupplyMock.sol"],"urls":[]},"token/ERC1155/extensions/ERC1155URIStorage.sol":{"checksum":{"algorithm":"md5","hash":"0x6046dbdf9591874037a20159d431e11f"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/extensions/ERC1155URIStorage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../../utils/Strings.sol\";\nimport \"../ERC1155.sol\";\n\n/**\n * @dev ERC1155 token with storage based token URI management.\n * Inspired by the ERC721URIStorage extension\n *\n * _Available since v4.6._\n */\nabstract contract ERC1155URIStorage is ERC1155 {\n    using Strings for uint256;\n\n    // Optional base URI\n    string private _baseURI = \"\";\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the concatenation of the `_baseURI`\n     * and the token-specific uri if the latter is set\n     *\n     * This enables the following behaviors:\n     *\n     * - if `_tokenURIs[tokenId]` is set, then the result is the concatenation\n     *   of `_baseURI` and `_tokenURIs[tokenId]` (keep in mind that `_baseURI`\n     *   is empty per default);\n     *\n     * - if `_tokenURIs[tokenId]` is NOT set then we fallback to `super.uri()`\n     *   which in most cases will contain `ERC1155._uri`;\n     *\n     * - if `_tokenURIs[tokenId]` is NOT set, and if the parents do not have a\n     *   uri value set, then the result is empty.\n     */\n    function uri(uint256 tokenId) public view virtual override returns (string memory) {\n        string memory tokenURI = _tokenURIs[tokenId];\n\n        // If token URI is set, concatenate base URI and tokenURI (via abi.encodePacked).\n        return bytes(tokenURI).length > 0 ? string(abi.encodePacked(_baseURI, tokenURI)) : super.uri(tokenId);\n    }\n\n    /**\n     * @dev Sets `tokenURI` as the tokenURI of `tokenId`.\n     */\n    function _setURI(uint256 tokenId, string memory tokenURI) internal virtual {\n        _tokenURIs[tokenId] = tokenURI;\n        emit URI(uri(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Sets `baseURI` as the `_baseURI` for all tokens\n     */\n    function _setBaseURI(string memory baseURI) internal virtual {\n        _baseURI = baseURI;\n    }\n}\n","imports":["token/ERC1155/ERC1155.sol","utils/Strings.sol"],"references":["mocks/ERC1155URIStorageMock.sol"],"urls":[]},"token/ERC1155/extensions/IERC1155MetadataURI.sol":{"checksum":{"algorithm":"md5","hash":"0x9148c2e10c4efb12c71a7f080da5559b"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n","imports":["token/ERC1155/IERC1155.sol"],"references":["token/ERC1155/ERC1155.sol","interfaces/IERC1155MetadataURI.sol"],"urls":[]},"token/ERC1155/presets/ERC1155PresetMinterPauser.sol":{"checksum":{"algorithm":"md5","hash":"0xce9333438d295d2c4bebc7951ad33d93"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/presets/ERC1155PresetMinterPauser.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../extensions/ERC1155Burnable.sol\";\nimport \"../extensions/ERC1155Pausable.sol\";\nimport \"../../../access/AccessControlEnumerable.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev {ERC1155} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n *\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\n */\ncontract ERC1155PresetMinterPauser is Context, AccessControlEnumerable, ERC1155Burnable, ERC1155Pausable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE`, and `PAUSER_ROLE` to the account that\n     * deploys the contract.\n     */\n    constructor(string memory uri) ERC1155(uri) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`, of token type `id`.\n     *\n     * See {ERC1155-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have minter role to mint\");\n\n        _mint(to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] variant of {mint}.\n     */\n    function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have minter role to mint\");\n\n        _mintBatch(to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC1155Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC1155Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlEnumerable, ERC1155)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override(ERC1155, ERC1155Pausable) {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n}\n","imports":["token/ERC1155/extensions/ERC1155Burnable.sol","token/ERC1155/extensions/ERC1155Pausable.sol","access/AccessControlEnumerable.sol","token/ERC1155/ERC1155.sol","utils/Context.sol"],"references":[],"urls":[]},"token/ERC1155/presets/README.md":{"checksum":{"algorithm":"md5","hash":"0x85edc842d25d732b734782e2d22be650"},"content":"Contract presets are now deprecated in favor of [Contracts Wizard](https://wizard.openzeppelin.com/) as a more powerful alternative.\n","imports":[],"references":[],"urls":[]},"token/ERC1155/utils/ERC1155Holder.sol":{"checksum":{"algorithm":"md5","hash":"0x88079762e28b246888129028f757e047"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155Receiver.sol\";\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n","imports":["token/ERC1155/utils/ERC1155Receiver.sol"],"references":[],"urls":[]},"token/ERC1155/utils/ERC1155Receiver.sol":{"checksum":{"algorithm":"md5","hash":"0x55b180cf664783e9a2baac20e82683fb"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n","imports":["token/ERC1155/IERC1155Receiver.sol","utils/introspection/ERC165.sol"],"references":["token/ERC1155/utils/ERC1155Holder.sol"],"urls":[]},"token/ERC20/ERC20.sol":{"checksum":{"algorithm":"md5","hash":"0xaf7bd64e1cfefbf6cb07f2adc1a25392"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n","imports":["token/ERC20/IERC20.sol","utils/Context.sol","token/ERC20/extensions/IERC20Metadata.sol"],"references":["mocks/ERC20DecimalsMock.sol","token/ERC20/extensions/ERC20Burnable.sol","token/ERC20/extensions/draft-ERC20Permit.sol","token/ERC20/extensions/ERC20Wrapper.sol","token/ERC20/extensions/ERC20Snapshot.sol","token/ERC20/extensions/ERC20Capped.sol","token/ERC20/extensions/ERC20Pausable.sol","mocks/ERC20Mock.sol","token/ERC20/extensions/ERC4626.sol","token/ERC20/extensions/ERC20FlashMint.sol","token/ERC20/presets/ERC20PresetMinterPauser.sol"],"urls":[]},"token/ERC20/IERC20.sol":{"checksum":{"algorithm":"md5","hash":"0xad7c2d0af148c8f9f097d65deeb4da6b"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n","imports":[],"references":["interfaces/IERC20.sol","interfaces/IERC4626.sol","mocks/ERC3156FlashBorrowerMock.sol","token/ERC20/extensions/IERC20Metadata.sol","token/ERC20/utils/SafeERC20.sol","mocks/SafeERC20Helper.sol","token/ERC20/ERC20.sol","token/ERC777/ERC777.sol"],"urls":[]},"token/ERC20/README.adoc":{"checksum":{"algorithm":"md5","hash":"0xea809159f18323d3bde30d25b2f7dbc6"},"content":"= ERC 20\n\n[.readme-notice]\nNOTE: This document is better viewed at https://docs.openzeppelin.com/contracts/api/token/erc20\n\nThis set of interfaces, contracts, and utilities are all related to the https://eips.ethereum.org/EIPS/eip-20[ERC20 Token Standard].\n\nTIP: For an overview of ERC20 tokens and a walk through on how to create a token contract read our xref:ROOT:erc20.adoc[ERC20 guide].\n\nThere are a few core contracts that implement the behavior specified in the EIP:\n\n* {IERC20}: the interface all ERC20 implementations should conform to.\n* {IERC20Metadata}: the extended ERC20 interface including the <<ERC20-name,`name`>>, <<ERC20-symbol,`symbol`>> and <<ERC20-decimals,`decimals`>> functions.\n* {ERC20}: the implementation of the ERC20 interface, including the <<ERC20-name,`name`>>, <<ERC20-symbol,`symbol`>> and <<ERC20-decimals,`decimals`>> optional standard extension to the base interface.\n\nAdditionally there are multiple custom extensions, including:\n\n* {ERC20Burnable}: destruction of own tokens.\n* {ERC20Capped}: enforcement of a cap to the total supply when minting tokens.\n* {ERC20Pausable}: ability to pause token transfers.\n* {ERC20Snapshot}: efficient storage of past token balances to be later queried at any point in time.\n* {ERC20Permit}: gasless approval of tokens (standardized as ERC2612).\n* {ERC20FlashMint}: token level support for flash loans through the minting and burning of ephemeral tokens (standardized as ERC3156).\n* {ERC20Votes}: support for voting and vote delegation.\n* {ERC20VotesComp}: support for voting and vote delegation (compatible with Compound's token, with uint96 restrictions).\n* {ERC20Wrapper}: wrapper to create an ERC20 backed by another ERC20, with deposit and withdraw methods. Useful in conjunction with {ERC20Votes}.\n* {ERC4626}: tokenized vault that manages shares (represented as ERC20) that are backed by assets (another ERC20).\n\nFinally, there are some utilities to interact with ERC20 contracts in various ways.\n\n* {SafeERC20}: a wrapper around the interface that eliminates the need to handle boolean return values.\n* {TokenTimelock}: hold tokens for a beneficiary until a specified time.\n\nThe following related EIPs are in draft status.\n\n- {ERC20Permit}\n\nNOTE: This core set of contracts is designed to be unopinionated, allowing developers to access the internal functions in ERC20 (such as <<ERC20-_mint-address-uint256-,`_mint`>>) and expose them as external functions in the way they prefer. On the other hand, xref:ROOT:erc20.adoc#Presets[ERC20 Presets] (such as {ERC20PresetMinterPauser}) are designed using opinionated patterns to provide developers with ready to use, deployable contracts.\n\n== Core\n\n{{IERC20}}\n\n{{IERC20Metadata}}\n\n{{ERC20}}\n\n== Extensions\n\n{{ERC20Burnable}}\n\n{{ERC20Capped}}\n\n{{ERC20Pausable}}\n\n{{ERC20Snapshot}}\n\n{{ERC20Votes}}\n\n{{ERC20VotesComp}}\n\n{{ERC20Wrapper}}\n\n{{ERC20FlashMint}}\n\n{{ERC4626}}\n\n== Draft EIPs\n\nThe following EIPs are still in Draft status. Due to their nature as drafts, the details of these contracts may change and we cannot guarantee their xref:ROOT:releases-stability.adoc[stability]. Minor releases of OpenZeppelin Contracts may contain breaking changes for the contracts in this directory, which will be duly announced in the https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/CHANGELOG.md[changelog]. The EIPs included here are used by projects in production and this may make them less likely to change significantly.\n\n{{ERC20Permit}}\n\n== Presets\n\nThese contracts are preconfigured combinations of the above features. They can be used through inheritance or as models to copy and paste their source code.\n\n{{ERC20PresetMinterPauser}}\n\n{{ERC20PresetFixedSupply}}\n\n== Utilities\n\n{{SafeERC20}}\n\n{{TokenTimelock}}\n","imports":[],"references":[],"urls":[]},"token/ERC20/extensions/ERC20Burnable.sol":{"checksum":{"algorithm":"md5","hash":"0xa1c7f80ae26f5b2d7d563475627fbf25"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n","imports":["token/ERC20/ERC20.sol","utils/Context.sol"],"references":["token/ERC20/presets/ERC20PresetFixedSupply.sol","mocks/ERC20BurnableMock.sol","token/ERC20/presets/ERC20PresetMinterPauser.sol"],"urls":[]},"token/ERC20/extensions/ERC20Capped.sol":{"checksum":{"algorithm":"md5","hash":"0xda89e343119284763a5a135243cdb338"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Capped.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\n\n/**\n * @dev Extension of {ERC20} that adds a cap to the supply of tokens.\n */\nabstract contract ERC20Capped is ERC20 {\n    uint256 private immutable _cap;\n\n    /**\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\n     * set once during construction.\n     */\n    constructor(uint256 cap_) {\n        require(cap_ > 0, \"ERC20Capped: cap is 0\");\n        _cap = cap_;\n    }\n\n    /**\n     * @dev Returns the cap on the token's total supply.\n     */\n    function cap() public view virtual returns (uint256) {\n        return _cap;\n    }\n\n    /**\n     * @dev See {ERC20-_mint}.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        require(ERC20.totalSupply() + amount <= cap(), \"ERC20Capped: cap exceeded\");\n        super._mint(account, amount);\n    }\n}\n","imports":["token/ERC20/ERC20.sol"],"references":["mocks/ERC20CappedMock.sol"],"urls":[]},"token/ERC20/extensions/ERC20FlashMint.sol":{"checksum":{"algorithm":"md5","hash":"0x7b5905f842b04687d13b4696fa037e65"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/extensions/ERC20FlashMint.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../../interfaces/IERC3156FlashBorrower.sol\";\nimport \"../../../interfaces/IERC3156FlashLender.sol\";\nimport \"../ERC20.sol\";\n\n/**\n * @dev Implementation of the ERC3156 Flash loans extension, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * Adds the {flashLoan} method, which provides flash loan support at the token\n * level. By default there is no fee, but this can be changed by overriding {flashFee}.\n *\n * _Available since v4.1._\n */\nabstract contract ERC20FlashMint is ERC20, IERC3156FlashLender {\n    bytes32 private constant _RETURN_VALUE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /**\n     * @dev Returns the maximum amount of tokens available for loan.\n     * @param token The address of the token that is requested.\n     * @return The amount of token that can be loaned.\n     */\n    function maxFlashLoan(address token) public view virtual override returns (uint256) {\n        return token == address(this) ? type(uint256).max - ERC20.totalSupply() : 0;\n    }\n\n    /**\n     * @dev Returns the fee applied when doing flash loans. By default this\n     * implementation has 0 fees. This function can be overloaded to make\n     * the flash loan mechanism deflationary.\n     * @param token The token to be flash loaned.\n     * @param amount The amount of tokens to be loaned.\n     * @return The fees applied to the corresponding flash loan.\n     */\n    function flashFee(address token, uint256 amount) public view virtual override returns (uint256) {\n        require(token == address(this), \"ERC20FlashMint: wrong token\");\n        // silence warning about unused variable without the addition of bytecode.\n        amount;\n        return 0;\n    }\n\n    /**\n     * @dev Returns the receiver address of the flash fee. By default this\n     * implementation returns the address(0) which means the fee amount will be burnt.\n     * This function can be overloaded to change the fee receiver.\n     * @return The address for which the flash fee will be sent to.\n     */\n    function _flashFeeReceiver() internal view virtual returns (address) {\n        return address(0);\n    }\n\n    /**\n     * @dev Performs a flash loan. New tokens are minted and sent to the\n     * `receiver`, who is required to implement the {IERC3156FlashBorrower}\n     * interface. By the end of the flash loan, the receiver is expected to own\n     * amount + fee tokens and have them approved back to the token contract itself so\n     * they can be burned.\n     * @param receiver The receiver of the flash loan. Should implement the\n     * {IERC3156FlashBorrower.onFlashLoan} interface.\n     * @param token The token to be flash loaned. Only `address(this)` is\n     * supported.\n     * @param amount The amount of tokens to be loaned.\n     * @param data An arbitrary datafield that is passed to the receiver.\n     * @return `true` if the flash loan was successful.\n     */\n    // This function can reenter, but it doesn't pose a risk because it always preserves the property that the amount\n    // minted at the beginning is always recovered and burned at the end, or else the entire function will revert.\n    // slither-disable-next-line reentrancy-no-eth\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override returns (bool) {\n        require(amount <= maxFlashLoan(token), \"ERC20FlashMint: amount exceeds maxFlashLoan\");\n        uint256 fee = flashFee(token, amount);\n        _mint(address(receiver), amount);\n        require(\n            receiver.onFlashLoan(msg.sender, token, amount, fee, data) == _RETURN_VALUE,\n            \"ERC20FlashMint: invalid return value\"\n        );\n        address flashFeeReceiver = _flashFeeReceiver();\n        _spendAllowance(address(receiver), address(this), amount + fee);\n        if (fee == 0 || flashFeeReceiver == address(0)) {\n            _burn(address(receiver), amount + fee);\n        } else {\n            _burn(address(receiver), amount);\n            _transfer(address(receiver), flashFeeReceiver, fee);\n        }\n        return true;\n    }\n}\n","imports":["interfaces/IERC3156FlashLender.sol","token/ERC20/ERC20.sol","interfaces/IERC3156FlashBorrower.sol"],"references":["mocks/ERC20FlashMintMock.sol"],"urls":[]},"token/ERC20/extensions/ERC20Pausable.sol":{"checksum":{"algorithm":"md5","hash":"0xab4babe7912604097ae769a62fa08506"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n","imports":["token/ERC20/ERC20.sol","security/Pausable.sol"],"references":["token/ERC20/presets/ERC20PresetMinterPauser.sol","mocks/ERC20PausableMock.sol"],"urls":[]},"token/ERC20/extensions/ERC20Snapshot.sol":{"checksum":{"algorithm":"md5","hash":"0x40467b3c6e3da2ddaae40817859a9827"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/extensions/ERC20Snapshot.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Arrays.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and\n * total supply at the time are recorded for later access.\n *\n * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.\n * In naive implementations it's possible to perform a \"double spend\" attack by reusing the same balance from different\n * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be\n * used to create an efficient ERC20 forking mechanism.\n *\n * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a\n * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot\n * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id\n * and the account address.\n *\n * NOTE: Snapshot policy can be customized by overriding the {_getCurrentSnapshotId} method. For example, having it\n * return `block.number` will trigger the creation of snapshot at the beginning of each new block. When overriding this\n * function, be careful about the monotonicity of its result. Non-monotonic snapshot ids will break the contract.\n *\n * Implementing snapshots for every block using this method will incur significant gas costs. For a gas-efficient\n * alternative consider {ERC20Votes}.\n *\n * ==== Gas Costs\n *\n * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log\n * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much\n * smaller since identical balances in subsequent snapshots are stored as a single entry.\n *\n * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is\n * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent\n * transfers will have normal cost until the next snapshot, and so on.\n */\n\nabstract contract ERC20Snapshot is ERC20 {\n    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:\n    // https://github.com/Giveth/minime/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\n\n    using Arrays for uint256[];\n    using Counters for Counters.Counter;\n\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\n    // Snapshot struct, but that would impede usage of functions that work on an array.\n    struct Snapshots {\n        uint256[] ids;\n        uint256[] values;\n    }\n\n    mapping(address => Snapshots) private _accountBalanceSnapshots;\n    Snapshots private _totalSupplySnapshots;\n\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\n    Counters.Counter private _currentSnapshotId;\n\n    /**\n     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\n     */\n    event Snapshot(uint256 id);\n\n    /**\n     * @dev Creates a new snapshot and returns its snapshot id.\n     *\n     * Emits a {Snapshot} event that contains the same id.\n     *\n     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\n     * set of accounts, for example using {AccessControl}, or it may be open to the public.\n     *\n     * [WARNING]\n     * ====\n     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\n     * you must consider that it can potentially be used by attackers in two ways.\n     *\n     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\n     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\n     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\n     * section above.\n     *\n     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\n     * ====\n     */\n    function _snapshot() internal virtual returns (uint256) {\n        _currentSnapshotId.increment();\n\n        uint256 currentId = _getCurrentSnapshotId();\n        emit Snapshot(currentId);\n        return currentId;\n    }\n\n    /**\n     * @dev Get the current snapshotId\n     */\n    function _getCurrentSnapshotId() internal view virtual returns (uint256) {\n        return _currentSnapshotId.current();\n    }\n\n    /**\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\n     */\n    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\n\n        return snapshotted ? value : balanceOf(account);\n    }\n\n    /**\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\n     */\n    function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\n\n        return snapshotted ? value : totalSupply();\n    }\n\n    // Update balance and/or total supply snapshots before the values are modified. This is implemented\n    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from == address(0)) {\n            // mint\n            _updateAccountSnapshot(to);\n            _updateTotalSupplySnapshot();\n        } else if (to == address(0)) {\n            // burn\n            _updateAccountSnapshot(from);\n            _updateTotalSupplySnapshot();\n        } else {\n            // transfer\n            _updateAccountSnapshot(from);\n            _updateAccountSnapshot(to);\n        }\n    }\n\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {\n        require(snapshotId > 0, \"ERC20Snapshot: id is 0\");\n        require(snapshotId <= _getCurrentSnapshotId(), \"ERC20Snapshot: nonexistent id\");\n\n        // When a valid snapshot is queried, there are three possibilities:\n        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\n        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\n        //  to this id is the current one.\n        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\n        //  requested id, and its value is the one to return.\n        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\n        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\n        //  larger than the requested one.\n        //\n        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\n        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\n        // exactly this.\n\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\n\n        if (index == snapshots.ids.length) {\n            return (false, 0);\n        } else {\n            return (true, snapshots.values[index]);\n        }\n    }\n\n    function _updateAccountSnapshot(address account) private {\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\n    }\n\n    function _updateTotalSupplySnapshot() private {\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\n    }\n\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\n        uint256 currentId = _getCurrentSnapshotId();\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\n            snapshots.ids.push(currentId);\n            snapshots.values.push(currentValue);\n        }\n    }\n\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\n        if (ids.length == 0) {\n            return 0;\n        } else {\n            return ids[ids.length - 1];\n        }\n    }\n}\n","imports":["utils/Arrays.sol","token/ERC20/ERC20.sol","utils/Counters.sol"],"references":["mocks/ERC20SnapshotMock.sol"],"urls":[]},"token/ERC20/extensions/ERC20Votes.sol":{"checksum":{"algorithm":"md5","hash":"0xd750921452f3bf2ab170f55cf4f5dc71"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Votes.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-ERC20Permit.sol\";\nimport \"../../../utils/math/Math.sol\";\nimport \"../../../governance/utils/IVotes.sol\";\nimport \"../../../utils/math/SafeCast.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20Votes is IVotes, ERC20Permit {\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.\n     * It is but NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        //\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\n        // - If the middle checkpoint is before or equal to `blockNumber`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\n        // the same.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {DelegateChanged} and {DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCast.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)}));\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n}\n","imports":["utils/cryptography/ECDSA.sol","utils/math/SafeCast.sol","token/ERC20/extensions/draft-ERC20Permit.sol","utils/math/Math.sol","governance/utils/IVotes.sol"],"references":["mocks/ERC20VotesMock.sol","token/ERC20/extensions/ERC20VotesComp.sol"],"urls":[]},"token/ERC20/extensions/ERC20VotesComp.sol":{"checksum":{"algorithm":"md5","hash":"0x85de097d4da905cf320e89d73840291a"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20VotesComp.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC20Votes.sol\";\n\n/**\n * @dev Extension of ERC20 to support Compound's voting and delegation. This version exactly matches Compound's\n * interface, with the drawback of only supporting supply up to (2^96^ - 1).\n *\n * NOTE: You should use this contract if you need exact compatibility with COMP (for example in order to use your token\n * with Governor Alpha or Bravo) and if you are sure the supply cap of 2^96^ is enough for you. Otherwise, use the\n * {ERC20Votes} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getCurrentVotes} and {getPriorVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20VotesComp is ERC20Votes {\n    /**\n     * @dev Comp version of the {getVotes} accessor, with `uint96` return type.\n     */\n    function getCurrentVotes(address account) external view virtual returns (uint96) {\n        return SafeCast.toUint96(getVotes(account));\n    }\n\n    /**\n     * @dev Comp version of the {getPastVotes} accessor, with `uint96` return type.\n     */\n    function getPriorVotes(address account, uint256 blockNumber) external view virtual returns (uint96) {\n        return SafeCast.toUint96(getPastVotes(account, blockNumber));\n    }\n\n    /**\n     * @dev Maximum token supply. Reduced to `type(uint96).max` (2^96^ - 1) to fit COMP interface.\n     */\n    function _maxSupply() internal view virtual override returns (uint224) {\n        return type(uint96).max;\n    }\n}\n","imports":["token/ERC20/extensions/ERC20Votes.sol"],"references":["governance/extensions/GovernorVotesComp.sol","mocks/ERC20VotesCompMock.sol"],"urls":[]},"token/ERC20/extensions/ERC20Wrapper.sol":{"checksum":{"algorithm":"md5","hash":"0x681b2b596d6bace0deaa50655a1733ef"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/ERC20Wrapper.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../utils/SafeERC20.sol\";\n\n/**\n * @dev Extension of the ERC20 token contract to support token wrapping.\n *\n * Users can deposit and withdraw \"underlying tokens\" and receive a matching number of \"wrapped tokens\". This is useful\n * in conjunction with other modules. For example, combining this wrapping mechanism with {ERC20Votes} will allow the\n * wrapping of an existing \"basic\" ERC20 into a governance token.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20Wrapper is ERC20 {\n    IERC20 public immutable underlying;\n\n    constructor(IERC20 underlyingToken) {\n        underlying = underlyingToken;\n    }\n\n    /**\n     * @dev See {ERC20-decimals}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        try IERC20Metadata(address(underlying)).decimals() returns (uint8 value) {\n            return value;\n        } catch {\n            return super.decimals();\n        }\n    }\n\n    /**\n     * @dev Allow a user to deposit underlying tokens and mint the corresponding number of wrapped tokens.\n     */\n    function depositFor(address account, uint256 amount) public virtual returns (bool) {\n        SafeERC20.safeTransferFrom(underlying, _msgSender(), address(this), amount);\n        _mint(account, amount);\n        return true;\n    }\n\n    /**\n     * @dev Allow a user to burn a number of wrapped tokens and withdraw the corresponding number of underlying tokens.\n     */\n    function withdrawTo(address account, uint256 amount) public virtual returns (bool) {\n        _burn(_msgSender(), amount);\n        SafeERC20.safeTransfer(underlying, account, amount);\n        return true;\n    }\n\n    /**\n     * @dev Mint wrapped token to cover any underlyingTokens that would have been transferred by mistake. Internal\n     * function that can be exposed with access control if desired.\n     */\n    function _recover(address account) internal virtual returns (uint256) {\n        uint256 value = underlying.balanceOf(address(this)) - totalSupply();\n        _mint(account, value);\n        return value;\n    }\n}\n","imports":["token/ERC20/utils/SafeERC20.sol","token/ERC20/ERC20.sol"],"references":["mocks/ERC20WrapperMock.sol"],"urls":[]},"token/ERC20/extensions/ERC4626.sol":{"checksum":{"algorithm":"md5","hash":"0xec70848d1691effc990bb40bd2d10847"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/extensions/ERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../utils/SafeERC20.sol\";\nimport \"../../../interfaces/IERC4626.sol\";\nimport \"../../../utils/math/Math.sol\";\n\n/**\n * @dev Implementation of the ERC4626 \"Tokenized Vault Standard\" as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[EIP-4626].\n *\n * This extension allows the minting and burning of \"shares\" (represented using the ERC20 inheritance) in exchange for\n * underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\n * the ERC20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\n * contract and not the \"assets\" token which is an independent contract.\n *\n * CAUTION: Deposits and withdrawals may incur unexpected slippage. Users should verify that the amount received of\n * shares or assets is as expected. EOAs should operate through a wrapper that performs these checks such as\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\n *\n * _Available since v4.7._\n */\nabstract contract ERC4626 is ERC20, IERC4626 {\n    using Math for uint256;\n\n    IERC20Metadata private immutable _asset;\n\n    /**\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC20 or ERC777).\n     */\n    constructor(IERC20Metadata asset_) {\n        _asset = asset_;\n    }\n\n    /** @dev See {IERC4262-asset}. */\n    function asset() public view virtual override returns (address) {\n        return address(_asset);\n    }\n\n    /** @dev See {IERC4262-totalAssets}. */\n    function totalAssets() public view virtual override returns (uint256) {\n        return _asset.balanceOf(address(this));\n    }\n\n    /** @dev See {IERC4262-convertToShares}. */\n    function convertToShares(uint256 assets) public view virtual override returns (uint256 shares) {\n        return _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-convertToAssets}. */\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256 assets) {\n        return _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-maxDeposit}. */\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        return _isVaultCollateralized() ? type(uint256).max : 0;\n    }\n\n    /** @dev See {IERC4262-maxMint}. */\n    function maxMint(address) public view virtual override returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4262-maxWithdraw}. */\n    function maxWithdraw(address owner) public view virtual override returns (uint256) {\n        return _convertToAssets(balanceOf(owner), Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-maxRedeem}. */\n    function maxRedeem(address owner) public view virtual override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4262-previewDeposit}. */\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-previewMint}. */\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Up);\n    }\n\n    /** @dev See {IERC4262-previewWithdraw}. */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Up);\n    }\n\n    /** @dev See {IERC4262-previewRedeem}. */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-deposit}. */\n    function deposit(uint256 assets, address receiver) public virtual override returns (uint256) {\n        require(assets <= maxDeposit(receiver), \"ERC4626: deposit more than max\");\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4262-mint}. */\n    function mint(uint256 shares, address receiver) public virtual override returns (uint256) {\n        require(shares <= maxMint(receiver), \"ERC4626: mint more than max\");\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /** @dev See {IERC4262-withdraw}. */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        require(assets <= maxWithdraw(owner), \"ERC4626: withdraw more than max\");\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4262-redeem}. */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        require(shares <= maxRedeem(owner), \"ERC4626: redeem more than max\");\n\n        uint256 assets = previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     *\n     * Will revert if assets > 0, totalSupply > 0 and totalAssets = 0. That corresponds to a case where any asset\n     * would represent an infinite amout of shares.\n     */\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        return\n            (assets == 0 || supply == 0)\n                ? assets.mulDiv(10**decimals(), 10**_asset.decimals(), rounding)\n                : assets.mulDiv(supply, totalAssets(), rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\n     */\n    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        return\n            (supply == 0)\n                ? shares.mulDiv(10**_asset.decimals(), 10**decimals(), rounding)\n                : shares.mulDiv(totalAssets(), supply, rounding);\n    }\n\n    /**\n     * @dev Deposit/mint common workflow.\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        // If _asset is ERC777, `transferFrom` can trigger a reenterancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transfered and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        SafeERC20.safeTransferFrom(_asset, caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Withdraw/redeem common workflow.\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // If _asset is ERC777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n        // shares are burned and after the assets are transfered, which is a valid state.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(_asset, receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    function _isVaultCollateralized() private view returns (bool) {\n        return totalAssets() > 0 || totalSupply() == 0;\n    }\n}\n","imports":["token/ERC20/utils/SafeERC20.sol","token/ERC20/ERC20.sol","interfaces/IERC4626.sol","utils/math/Math.sol"],"references":["mocks/ERC4626Mock.sol"],"urls":[]},"token/ERC20/extensions/IERC20Metadata.sol":{"checksum":{"algorithm":"md5","hash":"0x909ab67fc5c25033fe6cd364f8c056f9"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n","imports":["token/ERC20/IERC20.sol"],"references":["interfaces/IERC4626.sol","interfaces/IERC20Metadata.sol","token/ERC20/ERC20.sol"],"urls":[]},"token/ERC20/extensions/draft-ERC20Permit.sol":{"checksum":{"algorithm":"md5","hash":"0x3c98f8ccc741d97ece615ce32d638d4c"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n","imports":["token/ERC20/extensions/draft-IERC20Permit.sol","utils/cryptography/ECDSA.sol","utils/cryptography/draft-EIP712.sol","utils/Counters.sol","token/ERC20/ERC20.sol"],"references":["token/ERC20/extensions/ERC20Votes.sol","mocks/SafeERC20Helper.sol","mocks/ERC20PermitMock.sol"],"urls":[]},"token/ERC20/extensions/draft-IERC20Permit.sol":{"checksum":{"algorithm":"md5","hash":"0xfb77f144244b9ab12533aa6ce85ef8c5"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n","imports":[],"references":["interfaces/draft-IERC2612.sol","token/ERC20/extensions/draft-ERC20Permit.sol","token/ERC20/utils/SafeERC20.sol"],"urls":[]},"token/ERC20/presets/ERC20PresetFixedSupply.sol":{"checksum":{"algorithm":"md5","hash":"0xd4d35c0977f3c87ab399a75a45d6fc19"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/presets/ERC20PresetFixedSupply.sol)\npragma solidity ^0.8.0;\n\nimport \"../extensions/ERC20Burnable.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - Preminted initial supply\n *  - Ability for holders to burn (destroy) their tokens\n *  - No access control mechanism (for minting/pausing) and hence no governance\n *\n * This contract uses {ERC20Burnable} to include burn capabilities - head to\n * its documentation for details.\n *\n * _Available since v3.4._\n *\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\n */\ncontract ERC20PresetFixedSupply is ERC20Burnable {\n    /**\n     * @dev Mints `initialSupply` amount of token and transfers them to `owner`.\n     *\n     * See {ERC20-constructor}.\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply,\n        address owner\n    ) ERC20(name, symbol) {\n        _mint(owner, initialSupply);\n    }\n}\n","imports":["token/ERC20/extensions/ERC20Burnable.sol"],"references":[],"urls":[]},"token/ERC20/presets/ERC20PresetMinterPauser.sol":{"checksum":{"algorithm":"md5","hash":"0xca6cd8d752c4e75efa2a15734be0cb94"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/presets/ERC20PresetMinterPauser.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../extensions/ERC20Burnable.sol\";\nimport \"../extensions/ERC20Pausable.sol\";\nimport \"../../../access/AccessControlEnumerable.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n *\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\n */\ncontract ERC20PresetMinterPauser is Context, AccessControlEnumerable, ERC20Burnable, ERC20Pausable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * See {ERC20-constructor}.\n     */\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to, uint256 amount) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20, ERC20Pausable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n","imports":["token/ERC20/ERC20.sol","access/AccessControlEnumerable.sol","token/ERC20/extensions/ERC20Burnable.sol","token/ERC20/extensions/ERC20Pausable.sol","utils/Context.sol"],"references":[],"urls":[]},"token/ERC20/presets/README.md":{"checksum":{"algorithm":"md5","hash":"0x85edc842d25d732b734782e2d22be650"},"content":"Contract presets are now deprecated in favor of [Contracts Wizard](https://wizard.openzeppelin.com/) as a more powerful alternative.\n","imports":[],"references":[],"urls":[]},"token/ERC20/utils/SafeERC20.sol":{"checksum":{"algorithm":"md5","hash":"0x3a843b05b85a270e9455e3d2e804e633"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n","imports":["token/ERC20/extensions/draft-IERC20Permit.sol","token/ERC20/IERC20.sol","utils/Address.sol"],"references":["token/ERC20/utils/TokenTimelock.sol","token/ERC20/extensions/ERC20Wrapper.sol","token/ERC20/extensions/ERC4626.sol","mocks/SafeERC20Helper.sol","finance/PaymentSplitter.sol","finance/VestingWallet.sol"],"urls":[]},"token/ERC20/utils/TokenTimelock.sol":{"checksum":{"algorithm":"md5","hash":"0x5d2b54b53436cb1d51e9aed8f2b27982"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/utils/TokenTimelock.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./SafeERC20.sol\";\n\n/**\n * @dev A token holder contract that will allow a beneficiary to extract the\n * tokens after a given release time.\n *\n * Useful for simple vesting schedules like \"advisors get all of their tokens\n * after 1 year\".\n */\ncontract TokenTimelock {\n    using SafeERC20 for IERC20;\n\n    // ERC20 basic token contract being held\n    IERC20 private immutable _token;\n\n    // beneficiary of tokens after they are released\n    address private immutable _beneficiary;\n\n    // timestamp when token release is enabled\n    uint256 private immutable _releaseTime;\n\n    /**\n     * @dev Deploys a timelock instance that is able to hold the token specified, and will only release it to\n     * `beneficiary_` when {release} is invoked after `releaseTime_`. The release time is specified as a Unix timestamp\n     * (in seconds).\n     */\n    constructor(\n        IERC20 token_,\n        address beneficiary_,\n        uint256 releaseTime_\n    ) {\n        require(releaseTime_ > block.timestamp, \"TokenTimelock: release time is before current time\");\n        _token = token_;\n        _beneficiary = beneficiary_;\n        _releaseTime = releaseTime_;\n    }\n\n    /**\n     * @dev Returns the token being held.\n     */\n    function token() public view virtual returns (IERC20) {\n        return _token;\n    }\n\n    /**\n     * @dev Returns the beneficiary that will receive the tokens.\n     */\n    function beneficiary() public view virtual returns (address) {\n        return _beneficiary;\n    }\n\n    /**\n     * @dev Returns the time when the tokens are released in seconds since Unix epoch (i.e. Unix timestamp).\n     */\n    function releaseTime() public view virtual returns (uint256) {\n        return _releaseTime;\n    }\n\n    /**\n     * @dev Transfers tokens held by the timelock to the beneficiary. Will only succeed if invoked after the release\n     * time.\n     */\n    function release() public virtual {\n        require(block.timestamp >= releaseTime(), \"TokenTimelock: current time is before release time\");\n\n        uint256 amount = token().balanceOf(address(this));\n        require(amount > 0, \"TokenTimelock: no tokens to release\");\n\n        token().safeTransfer(beneficiary(), amount);\n    }\n}\n","imports":["token/ERC20/utils/SafeERC20.sol"],"references":[],"urls":[]},"token/ERC721/ERC721.sol":{"checksum":{"algorithm":"md5","hash":"0x79ff1a7eb801a525aa315fb7a679eede"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n","imports":["token/ERC721/IERC721Receiver.sol","utils/Strings.sol","token/ERC721/IERC721.sol","utils/introspection/ERC165.sol","utils/Address.sol","token/ERC721/extensions/IERC721Metadata.sol","utils/Context.sol"],"references":["token/ERC721/extensions/ERC721Enumerable.sol","token/ERC721/extensions/ERC721URIStorage.sol","token/ERC721/extensions/draft-ERC721Votes.sol","mocks/ERC721Mock.sol","token/ERC721/extensions/ERC721Pausable.sol","token/ERC721/extensions/ERC721Burnable.sol","token/ERC721/extensions/ERC721Royalty.sol","token/ERC721/presets/ERC721PresetMinterPauserAutoId.sol"],"urls":[]},"token/ERC721/IERC721.sol":{"checksum":{"algorithm":"md5","hash":"0xec99d946db3685a3630554aa6055bd7f"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n","imports":["utils/introspection/IERC165.sol"],"references":["interfaces/IERC721.sol","token/ERC721/ERC721.sol","token/ERC721/extensions/IERC721Metadata.sol","token/ERC721/extensions/IERC721Enumerable.sol"],"urls":[]},"token/ERC721/IERC721Receiver.sol":{"checksum":{"algorithm":"md5","hash":"0xc22d4395e33763de693fd440c6fd10e1"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n","imports":[],"references":["interfaces/IERC721Receiver.sol","mocks/ERC721ReceiverMock.sol","token/ERC721/ERC721.sol","governance/TimelockController.sol","governance/Governor.sol","token/ERC721/utils/ERC721Holder.sol"],"urls":[]},"token/ERC721/README.adoc":{"checksum":{"algorithm":"md5","hash":"0xb77b15d6efb6ca2f9f8666e30ea1f9ac"},"content":"= ERC 721\n\n[.readme-notice]\nNOTE: This document is better viewed at https://docs.openzeppelin.com/contracts/api/token/erc721\n\nThis set of interfaces, contracts, and utilities are all related to the https://eips.ethereum.org/EIPS/eip-721[ERC721 Non-Fungible Token Standard].\n\nTIP: For a walk through on how to create an ERC721 token read our xref:ROOT:erc721.adoc[ERC721 guide].\n\nThe EIP specifies four interfaces:\n\n* {IERC721}: Core functionality required in all compliant implementation.\n* {IERC721Metadata}: Optional extension that adds name, symbol, and token URI, almost always included.\n* {IERC721Enumerable}: Optional extension that allows enumerating the tokens on chain, often not included since it requires large gas overhead.\n* {IERC721Receiver}: An interface that must be implemented by contracts if they want to accept tokens through `safeTransferFrom`.\n\nOpenZeppelin Contracts provides implementations of all four interfaces:\n\n* {ERC721}: The core and metadata extensions, with a base URI mechanism.\n* {ERC721Enumerable}: The enumerable extension.\n* {ERC721Holder}: A bare bones implementation of the receiver interface.\n\nAdditionally there are a few of other extensions:\n\n* {ERC721URIStorage}: A more flexible but more expensive way of storing metadata.\n* {ERC721Votes}: Support for voting and vote delegation.\n* {ERC721Royalty}: A way to signal royalty information following ERC2981.\n* {ERC721Pausable}: A primitive to pause contract operation.\n* {ERC721Burnable}: A way for token holders to burn their own tokens.\n\nNOTE: This core set of contracts is designed to be unopinionated, allowing developers to access the internal functions in ERC721 (such as <<ERC721-_mint-address-uint256-,`_mint`>>) and expose them as external functions in the way they prefer. On the other hand, xref:ROOT:erc721.adoc#Presets[ERC721 Presets] (such as {ERC721PresetMinterPauserAutoId}) are designed using opinionated patterns to provide developers with ready to use, deployable contracts.\n\n== Core\n\n{{IERC721}}\n\n{{IERC721Metadata}}\n\n{{IERC721Enumerable}}\n\n{{ERC721}}\n\n{{ERC721Enumerable}}\n\n{{IERC721Receiver}}\n\n== Extensions\n\n{{ERC721Pausable}}\n\n{{ERC721Burnable}}\n\n{{ERC721URIStorage}}\n\n{{ERC721Votes}}\n\n{{ERC721Royalty}}\n\n== Presets\n\nThese contracts are preconfigured combinations of the above features. They can be used through inheritance or as models to copy and paste their source code.\n\n{{ERC721PresetMinterPauserAutoId}}\n\n== Utilities\n\n{{ERC721Holder}}\n","imports":[],"references":[],"urls":[]},"token/ERC721/extensions/ERC721Burnable.sol":{"checksum":{"algorithm":"md5","hash":"0x527e36af89e16c5f3cf37c35a26c2b1b"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _burn(tokenId);\n    }\n}\n","imports":["token/ERC721/ERC721.sol","utils/Context.sol"],"references":["mocks/ERC721BurnableMock.sol","token/ERC721/presets/ERC721PresetMinterPauserAutoId.sol"],"urls":[]},"token/ERC721/extensions/ERC721Enumerable.sol":{"checksum":{"algorithm":"md5","hash":"0x88095889e59d16821879a8083f906503"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n","imports":["token/ERC721/ERC721.sol","token/ERC721/extensions/IERC721Enumerable.sol"],"references":["mocks/ERC721EnumerableMock.sol","token/ERC721/presets/ERC721PresetMinterPauserAutoId.sol"],"urls":[]},"token/ERC721/extensions/ERC721Pausable.sol":{"checksum":{"algorithm":"md5","hash":"0x2bc2d361b7e7bda979021da66e1696af"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC721 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC721Pausable is ERC721, Pausable {\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        require(!paused(), \"ERC721Pausable: token transfer while paused\");\n    }\n}\n","imports":["token/ERC721/ERC721.sol","security/Pausable.sol"],"references":["mocks/ERC721PausableMock.sol","token/ERC721/presets/ERC721PresetMinterPauserAutoId.sol"],"urls":[]},"token/ERC721/extensions/ERC721Royalty.sol":{"checksum":{"algorithm":"md5","hash":"0x538c93f1c25e40421fbe0c2c820c2fbe"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/ERC721Royalty.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../common/ERC2981.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Extension of ERC721 with the ERC2981 NFT Royalty Standard, a standardized way to retrieve royalty payment\n * information.\n *\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\n *\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\n *\n * _Available since v4.5._\n */\nabstract contract ERC721Royalty is ERC2981, ERC721 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC2981) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {ERC721-_burn}. This override additionally clears the royalty information for the token.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n        _resetTokenRoyalty(tokenId);\n    }\n}\n","imports":["token/common/ERC2981.sol","token/ERC721/ERC721.sol","utils/introspection/ERC165.sol"],"references":["mocks/ERC721RoyaltyMock.sol"],"urls":[]},"token/ERC721/extensions/ERC721URIStorage.sol":{"checksum":{"algorithm":"md5","hash":"0x8af32effd0536e2971ff8496812a5016"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev See {ERC721-_burn}. This override additionally checks to see if a\n     * token-specific URI was set for the token, and if so, it deletes the token URI from\n     * the storage mapping.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n","imports":["token/ERC721/ERC721.sol"],"references":["mocks/ERC721URIStorageMock.sol"],"urls":[]},"token/ERC721/extensions/IERC721Enumerable.sol":{"checksum":{"algorithm":"md5","hash":"0xf4dd06783f321aa26179bc2b6e361c29"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n","imports":["token/ERC721/IERC721.sol"],"references":["token/ERC721/extensions/ERC721Enumerable.sol","interfaces/IERC721Enumerable.sol"],"urls":[]},"token/ERC721/extensions/IERC721Metadata.sol":{"checksum":{"algorithm":"md5","hash":"0xefbc0d15b80a74e34dbe8da0f3e879bb"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n","imports":["token/ERC721/IERC721.sol"],"references":["token/ERC721/ERC721.sol","interfaces/IERC721Metadata.sol"],"urls":[]},"token/ERC721/extensions/draft-ERC721Votes.sol":{"checksum":{"algorithm":"md5","hash":"0x393b6576742f451e365d603310c83adf"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/extensions/draft-ERC721Votes.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../../governance/utils/Votes.sol\";\n\n/**\n * @dev Extension of ERC721 to support voting and delegation as implemented by {Votes}, where each individual NFT counts\n * as 1 vote unit.\n *\n * Tokens do not count as votes until they are delegated, because votes must be tracked which incurs an additional cost\n * on every transfer. Token holders can either delegate to a trusted representative who will decide how to make use of\n * the votes in governance decisions, or they can delegate to themselves to be their own representative.\n *\n * _Available since v4.5._\n */\nabstract contract ERC721Votes is ERC721, Votes {\n    /**\n     * @dev Adjusts votes when tokens are transferred.\n     *\n     * Emits a {Votes-DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        _transferVotingUnits(from, to, 1);\n        super._afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Returns the balance of `account`.\n     */\n    function _getVotingUnits(address account) internal view virtual override returns (uint256) {\n        return balanceOf(account);\n    }\n}\n","imports":["token/ERC721/ERC721.sol","governance/utils/Votes.sol"],"references":["mocks/ERC721VotesMock.sol"],"urls":[]},"token/ERC721/presets/ERC721PresetMinterPauserAutoId.sol":{"checksum":{"algorithm":"md5","hash":"0x27d2c7c209f2fae42c6b90832f2669aa"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/presets/ERC721PresetMinterPauserAutoId.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../extensions/ERC721Enumerable.sol\";\nimport \"../extensions/ERC721Burnable.sol\";\nimport \"../extensions/ERC721Pausable.sol\";\nimport \"../../../access/AccessControlEnumerable.sol\";\nimport \"../../../utils/Context.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev {ERC721} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *  - token ID and URI autogeneration\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n *\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\n */\ncontract ERC721PresetMinterPauserAutoId is\n    Context,\n    AccessControlEnumerable,\n    ERC721Enumerable,\n    ERC721Burnable,\n    ERC721Pausable\n{\n    using Counters for Counters.Counter;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    Counters.Counter private _tokenIdTracker;\n\n    string private _baseTokenURI;\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * Token URIs will be autogenerated based on `baseURI` and their token IDs.\n     * See {ERC721-tokenURI}.\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        string memory baseTokenURI\n    ) ERC721(name, symbol) {\n        _baseTokenURI = baseTokenURI;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseTokenURI;\n    }\n\n    /**\n     * @dev Creates a new token for `to`. Its token ID will be automatically\n     * assigned (and available on the emitted {IERC721-Transfer} event), and the token\n     * URI autogenerated based on the base URI passed at construction.\n     *\n     * See {ERC721-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have minter role to mint\");\n\n        // We cannot just use balanceOf to create the new tokenId because tokens\n        // can be burned (destroyed), so we need a separate counter.\n        _mint(to, _tokenIdTracker.current());\n        _tokenIdTracker.increment();\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC721Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC721Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlEnumerable, ERC721, ERC721Enumerable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n","imports":["token/ERC721/extensions/ERC721Enumerable.sol","utils/Counters.sol","token/ERC721/extensions/ERC721Burnable.sol","access/AccessControlEnumerable.sol","token/ERC721/extensions/ERC721Pausable.sol","token/ERC721/ERC721.sol","utils/Context.sol"],"references":[],"urls":[]},"token/ERC721/presets/README.md":{"checksum":{"algorithm":"md5","hash":"0x85edc842d25d732b734782e2d22be650"},"content":"Contract presets are now deprecated in favor of [Contracts Wizard](https://wizard.openzeppelin.com/) as a more powerful alternative.\n","imports":[],"references":[],"urls":[]},"token/ERC721/utils/ERC721Holder.sol":{"checksum":{"algorithm":"md5","hash":"0x54062ff887823a306b33ea6494a220bc"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n","imports":["token/ERC721/IERC721Receiver.sol"],"references":[],"urls":[]},"token/ERC777/ERC777.sol":{"checksum":{"algorithm":"md5","hash":"0xc599ea9bfe0447dd619a80d6c9e50eff"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC777/ERC777.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC777.sol\";\nimport \"./IERC777Recipient.sol\";\nimport \"./IERC777Sender.sol\";\nimport \"../ERC20/IERC20.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/IERC1820Registry.sol\";\n\n/**\n * @dev Implementation of the {IERC777} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * Support for ERC20 is included in this contract, as specified by the EIP: both\n * the ERC777 and ERC20 interfaces can be safely used when interacting with it.\n * Both {IERC777-Sent} and {IERC20-Transfer} events are emitted on token\n * movements.\n *\n * Additionally, the {IERC777-granularity} value is hard-coded to `1`, meaning that there\n * are no special restrictions in the amount of tokens that created, moved, or\n * destroyed. This makes integration with ERC20 applications seamless.\n */\ncontract ERC777 is Context, IERC777, IERC20 {\n    using Address for address;\n\n    IERC1820Registry internal constant _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n    mapping(address => uint256) private _balances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    bytes32 private constant _TOKENS_SENDER_INTERFACE_HASH = keccak256(\"ERC777TokensSender\");\n    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(\"ERC777TokensRecipient\");\n\n    // This isn't ever read from - it's only used to respond to the defaultOperators query.\n    address[] private _defaultOperatorsArray;\n\n    // Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).\n    mapping(address => bool) private _defaultOperators;\n\n    // For each account, a mapping of its operators and revoked default operators.\n    mapping(address => mapping(address => bool)) private _operators;\n    mapping(address => mapping(address => bool)) private _revokedDefaultOperators;\n\n    // ERC20-allowances\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    /**\n     * @dev `defaultOperators` may be an empty array.\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address[] memory defaultOperators_\n    ) {\n        _name = name_;\n        _symbol = symbol_;\n\n        _defaultOperatorsArray = defaultOperators_;\n        for (uint256 i = 0; i < defaultOperators_.length; i++) {\n            _defaultOperators[defaultOperators_[i]] = true;\n        }\n\n        // register interfaces\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC777Token\"), address(this));\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC20Token\"), address(this));\n    }\n\n    /**\n     * @dev See {IERC777-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC777-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {ERC20-decimals}.\n     *\n     * Always returns 18, as per the\n     * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\n     */\n    function decimals() public pure virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC777-granularity}.\n     *\n     * This implementation always returns `1`.\n     */\n    function granularity() public view virtual override returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @dev See {IERC777-totalSupply}.\n     */\n    function totalSupply() public view virtual override(IERC20, IERC777) returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`tokenHolder`).\n     */\n    function balanceOf(address tokenHolder) public view virtual override(IERC20, IERC777) returns (uint256) {\n        return _balances[tokenHolder];\n    }\n\n    /**\n     * @dev See {IERC777-send}.\n     *\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\n     */\n    function send(\n        address recipient,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        _send(_msgSender(), recipient, amount, data, \"\", true);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}\n     * interface if it is a contract.\n     *\n     * Also emits a {Sent} event.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _send(_msgSender(), recipient, amount, \"\", \"\", false);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC777-burn}.\n     *\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\n     */\n    function burn(uint256 amount, bytes memory data) public virtual override {\n        _burn(_msgSender(), amount, data, \"\");\n    }\n\n    /**\n     * @dev See {IERC777-isOperatorFor}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) public view virtual override returns (bool) {\n        return\n            operator == tokenHolder ||\n            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||\n            _operators[tokenHolder][operator];\n    }\n\n    /**\n     * @dev See {IERC777-authorizeOperator}.\n     */\n    function authorizeOperator(address operator) public virtual override {\n        require(_msgSender() != operator, \"ERC777: authorizing self as operator\");\n\n        if (_defaultOperators[operator]) {\n            delete _revokedDefaultOperators[_msgSender()][operator];\n        } else {\n            _operators[_msgSender()][operator] = true;\n        }\n\n        emit AuthorizedOperator(operator, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC777-revokeOperator}.\n     */\n    function revokeOperator(address operator) public virtual override {\n        require(operator != _msgSender(), \"ERC777: revoking self as operator\");\n\n        if (_defaultOperators[operator]) {\n            _revokedDefaultOperators[_msgSender()][operator] = true;\n        } else {\n            delete _operators[_msgSender()][operator];\n        }\n\n        emit RevokedOperator(operator, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC777-defaultOperators}.\n     */\n    function defaultOperators() public view virtual override returns (address[] memory) {\n        return _defaultOperatorsArray;\n    }\n\n    /**\n     * @dev See {IERC777-operatorSend}.\n     *\n     * Emits {Sent} and {IERC20-Transfer} events.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    ) public virtual override {\n        require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator for holder\");\n        _send(sender, recipient, amount, data, operatorData, true);\n    }\n\n    /**\n     * @dev See {IERC777-operatorBurn}.\n     *\n     * Emits {Burned} and {IERC20-Transfer} events.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    ) public virtual override {\n        require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator for holder\");\n        _burn(account, amount, data, operatorData);\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     *\n     * Note that operator and allowance concepts are orthogonal: operators may\n     * not have allowance, and accounts with allowance may not be operators\n     * themselves.\n     */\n    function allowance(address holder, address spender) public view virtual override returns (uint256) {\n        return _allowances[holder][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n    function approve(address spender, uint256 value) public virtual override returns (bool) {\n        address holder = _msgSender();\n        _approve(holder, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Note that operator and allowance concepts are orthogonal: operators cannot\n     * call `transferFrom` (unless they have allowance), and accounts with\n     * allowance cannot call `operatorSend` (unless they are operators).\n     *\n     * Emits {Sent}, {IERC20-Transfer} and {IERC20-Approval} events.\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(holder, spender, amount);\n        _send(holder, recipient, amount, \"\", \"\", false);\n        return true;\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with the caller address as the `operator` and with\n     * `userData` and `operatorData`.\n     *\n     * See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits {Minted} and {IERC20-Transfer} events.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function _mint(\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) internal virtual {\n        _mint(account, amount, userData, operatorData, true);\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * If `requireReceptionAck` is set to true, and if a send hook is\n     * registered for `account`, the corresponding function will be called with\n     * `operator`, `data` and `operatorData`.\n     *\n     * See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits {Minted} and {IERC20-Transfer} events.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function _mint(\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    ) internal virtual {\n        require(account != address(0), \"ERC777: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, amount);\n\n        // Update state variables\n        _totalSupply += amount;\n        _balances[account] += amount;\n\n        _callTokensReceived(operator, address(0), account, amount, userData, operatorData, requireReceptionAck);\n\n        emit Minted(operator, account, amount, userData, operatorData);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Send tokens\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _send(\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    ) internal virtual {\n        require(from != address(0), \"ERC777: transfer from the zero address\");\n        require(to != address(0), \"ERC777: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _callTokensToSend(operator, from, to, amount, userData, operatorData);\n\n        _move(operator, from, to, amount, userData, operatorData);\n\n        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\n    }\n\n    /**\n     * @dev Burn tokens\n     * @param from address token holder address\n     * @param amount uint256 amount of tokens to burn\n     * @param data bytes extra information provided by the token holder\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _burn(\n        address from,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    ) internal virtual {\n        require(from != address(0), \"ERC777: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _callTokensToSend(operator, from, address(0), amount, data, operatorData);\n\n        _beforeTokenTransfer(operator, from, address(0), amount);\n\n        // Update state variables\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC777: burn amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Burned(operator, from, amount, data, operatorData);\n        emit Transfer(from, address(0), amount);\n    }\n\n    function _move(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) private {\n        _beforeTokenTransfer(operator, from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC777: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Sent(operator, from, to, amount, userData, operatorData);\n        emit Transfer(from, to, amount);\n    }\n\n    /**\n     * @dev See {ERC20-_approve}.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n    function _approve(\n        address holder,\n        address spender,\n        uint256 value\n    ) internal virtual {\n        require(holder != address(0), \"ERC777: approve from the zero address\");\n        require(spender != address(0), \"ERC777: approve to the zero address\");\n\n        _allowances[holder][spender] = value;\n        emit Approval(holder, spender, value);\n    }\n\n    /**\n     * @dev Call from.tokensToSend() if the interface is registered\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _callTokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) private {\n        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(from, _TOKENS_SENDER_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\n        }\n    }\n\n    /**\n     * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but\n     * tokensReceived() was not registered for the recipient\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _callTokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    ) private {\n        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(to, _TOKENS_RECIPIENT_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\n        } else if (requireReceptionAck) {\n            require(!to.isContract(), \"ERC777: token recipient contract has no implementer for ERC777TokensRecipient\");\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC777: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes\n     * calls to {send}, {transfer}, {operatorSend}, minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n","imports":["token/ERC20/IERC20.sol","token/ERC777/IERC777Sender.sol","token/ERC777/IERC777.sol","token/ERC777/IERC777Recipient.sol","utils/Address.sol","utils/introspection/IERC1820Registry.sol","utils/Context.sol"],"references":["mocks/ERC777Mock.sol","token/ERC777/presets/ERC777PresetFixedSupply.sol"],"urls":[]},"token/ERC777/IERC777.sol":{"checksum":{"algorithm":"md5","hash":"0x840fa65314c73b948a5923169daa8cdc"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC777/IERC777.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777Token standard as defined in the EIP.\n *\n * This contract uses the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\n * token holders and recipients react to token movements by using setting implementers\n * for the associated interfaces in said registry. See {IERC1820Registry} and\n * {ERC1820Implementer}.\n */\ninterface IERC777 {\n    /**\n     * @dev Emitted when `amount` tokens are created by `operator` and assigned to `to`.\n     *\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\n     */\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n\n    /**\n     * @dev Emitted when `operator` destroys `amount` tokens from `account`.\n     *\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\n     */\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n\n    /**\n     * @dev Emitted when `operator` is made operator for `tokenHolder`\n     */\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n\n    /**\n     * @dev Emitted when `operator` is revoked its operator status for `tokenHolder`\n     */\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the smallest part of the token that is not divisible. This\n     * means all token operations (creation, movement and destruction) must have\n     * amounts that are a multiple of this number.\n     *\n     * For most token contracts, this value will equal 1.\n     */\n    function granularity() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`owner`).\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * If send or receive hooks are registered for the caller and `recipient`,\n     * the corresponding functions will be called with `data` and empty\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function send(\n        address recipient,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\n     * total supply.\n     *\n     * If a send hook is registered for the caller, the corresponding function\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     */\n    function burn(uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Returns true if an account is an operator of `tokenHolder`.\n     * Operators can send and burn tokens on behalf of their owners. All\n     * accounts are their own operator.\n     *\n     * See {operatorSend} and {operatorBurn}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See {isOperatorFor}.\n     *\n     * Emits an {AuthorizedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function authorizeOperator(address operator) external;\n\n    /**\n     * @dev Revoke an account's operator status for the caller.\n     *\n     * See {isOperatorFor} and {defaultOperators}.\n     *\n     * Emits a {RevokedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function revokeOperator(address operator) external;\n\n    /**\n     * @dev Returns the list of default operators. These accounts are operators\n     * for all token holders, even if {authorizeOperator} was never called on\n     * them.\n     *\n     * This list is immutable, but individual holders may revoke these via\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\n     */\n    function defaultOperators() external view returns (address[] memory);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n     * be an operator of `sender`.\n     *\n     * If send or receive hooks are registered for `sender` and `recipient`,\n     * the corresponding functions will be called with `data` and\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - `sender` cannot be the zero address.\n     * - `sender` must have at least `amount` tokens.\n     * - the caller must be an operator for `sender`.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\n     * The caller must be an operator of `account`.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     * - the caller must be an operator for `account`.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n}\n","imports":[],"references":["mocks/ERC777SenderRecipientMock.sol","interfaces/IERC777.sol","token/ERC777/ERC777.sol"],"urls":[]},"token/ERC777/IERC777Recipient.sol":{"checksum":{"algorithm":"md5","hash":"0x268af1696d7a83a7e78a1a8f5ba1c685"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC777/IERC777Recipient.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n *\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\n * contract implement this interface (contract holders can be their own\n * implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Recipient {\n    /**\n     * @dev Called by an {IERC777} token contract whenever tokens are being\n     * moved or created into a registered account (`to`). The type of operation\n     * is conveyed by `from` being the zero address or not.\n     *\n     * This call occurs _after_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n","imports":[],"references":["mocks/ERC777SenderRecipientMock.sol","interfaces/IERC777Recipient.sol","token/ERC777/ERC777.sol"],"urls":[]},"token/ERC777/IERC777Sender.sol":{"checksum":{"algorithm":"md5","hash":"0x7c1ce5bc5bc5f57fe7106ba767063e08"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC777/IERC777Sender.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\n *\n * {IERC777} Token holders can be notified of operations performed on their\n * tokens by having a contract implement this interface (contract holders can be\n * their own implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Sender {\n    /**\n     * @dev Called by an {IERC777} token contract whenever a registered holder's\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\n     * is conveyed by `to` being the zero address or not.\n     *\n     * This call occurs _before_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n","imports":[],"references":["mocks/ERC777SenderRecipientMock.sol","interfaces/IERC777Sender.sol","token/ERC777/ERC777.sol"],"urls":[]},"token/ERC777/README.adoc":{"checksum":{"algorithm":"md5","hash":"0x7b3435ddda44088232128df504a45ffe"},"content":"= ERC 777\n\n[.readme-notice]\nNOTE: This document is better viewed at https://docs.openzeppelin.com/contracts/api/token/erc777\n\nThis set of interfaces and contracts are all related to the https://eips.ethereum.org/EIPS/eip-777[ERC777 token standard].\n\nTIP: For an overview of ERC777 tokens and a walk through on how to create a token contract read our xref:ROOT:erc777.adoc[ERC777 guide].\n\nThe token behavior itself is implemented in the core contracts: {IERC777}, {ERC777}.\n\nAdditionally there are interfaces used to develop contracts that react to token movements: {IERC777Sender}, {IERC777Recipient}.\n\n== Core\n\n{{IERC777}}\n\n{{ERC777}}\n\n== Hooks\n\n{{IERC777Sender}}\n\n{{IERC777Recipient}}\n\n== Presets\n\nThese contracts are preconfigured combinations of features. They can be used through inheritance or as models to copy and paste their source code.\n\n{{ERC777PresetFixedSupply}}\n","imports":[],"references":[],"urls":[]},"token/ERC777/presets/ERC777PresetFixedSupply.sol":{"checksum":{"algorithm":"md5","hash":"0xcf632c608a0fc89ebfcd9870cb7e6ca2"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC777/presets/ERC777PresetFixedSupply.sol)\npragma solidity ^0.8.0;\n\nimport \"../ERC777.sol\";\n\n/**\n * @dev {ERC777} token, including:\n *\n *  - Preminted initial supply\n *  - No access control mechanism (for minting/pausing) and hence no governance\n *\n * _Available since v3.4._\n */\ncontract ERC777PresetFixedSupply is ERC777 {\n    /**\n     * @dev Mints `initialSupply` amount of token and transfers them to `owner`.\n     *\n     * See {ERC777-constructor}.\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        address[] memory defaultOperators,\n        uint256 initialSupply,\n        address owner\n    ) ERC777(name, symbol, defaultOperators) {\n        _mint(owner, initialSupply, \"\", \"\");\n    }\n}\n","imports":["token/ERC777/ERC777.sol"],"references":[],"urls":[]},"token/common/ERC2981.sol":{"checksum":{"algorithm":"md5","hash":"0xf995d6f70022823e60e85f41959c801d"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/IERC2981.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\n *\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\n *\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\n * fee is specified in basis points by default.\n *\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\n *\n * _Available since v4.5._\n */\nabstract contract ERC2981 is IERC2981, ERC165 {\n    struct RoyaltyInfo {\n        address receiver;\n        uint96 royaltyFraction;\n    }\n\n    RoyaltyInfo private _defaultRoyaltyInfo;\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc IERC2981\n     */\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[_tokenId];\n\n        if (royalty.receiver == address(0)) {\n            royalty = _defaultRoyaltyInfo;\n        }\n\n        uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / _feeDenominator();\n\n        return (royalty.receiver, royaltyAmount);\n    }\n\n    /**\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\n     * override.\n     */\n    function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }\n\n    /**\n     * @dev Sets the royalty information that all ids in this contract will default to.\n     *\n     * Requirements:\n     *\n     * - `receiver` cannot be the zero address.\n     * - `feeNumerator` cannot be greater than the fee denominator.\n     */\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        require(feeNumerator <= _feeDenominator(), \"ERC2981: royalty fee will exceed salePrice\");\n        require(receiver != address(0), \"ERC2981: invalid receiver\");\n\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\n    }\n\n    /**\n     * @dev Removes default royalty information.\n     */\n    function _deleteDefaultRoyalty() internal virtual {\n        delete _defaultRoyaltyInfo;\n    }\n\n    /**\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\n     *\n     * Requirements:\n     *\n     * - `receiver` cannot be the zero address.\n     * - `feeNumerator` cannot be greater than the fee denominator.\n     */\n    function _setTokenRoyalty(\n        uint256 tokenId,\n        address receiver,\n        uint96 feeNumerator\n    ) internal virtual {\n        require(feeNumerator <= _feeDenominator(), \"ERC2981: royalty fee will exceed salePrice\");\n        require(receiver != address(0), \"ERC2981: Invalid parameters\");\n\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\n    }\n\n    /**\n     * @dev Resets royalty information for the token id back to the global default.\n     */\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        delete _tokenRoyaltyInfo[tokenId];\n    }\n}\n","imports":["interfaces/IERC2981.sol","utils/introspection/ERC165.sol"],"references":["token/ERC721/extensions/ERC721Royalty.sol"],"urls":[]},"token/common/README.adoc":{"checksum":{"algorithm":"md5","hash":"0xc6b51e9ab786376596e3dde851d53dea"},"content":"= Common (Tokens)\n\nFunctionality that is common to multiple token standards.\n\n* {ERC2981}: NFT Royalties compatible with both ERC721 and ERC1155.\n** For ERC721 consider {ERC721Royalty} which clears the royalty information from storage on burn.\n\n== Contracts\n\n{{ERC2981}}\n","imports":[],"references":[],"urls":[]},"utils/Address.sol":{"checksum":{"algorithm":"md5","hash":"0xc476b3895a94798b88a4bb97399e6dfe"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n","imports":[],"references":["mocks/ERC3156FlashBorrowerMock.sol","crosschain/polygon/CrossChainEnabledPolygonChild.sol","token/ERC1155/ERC1155.sol","proxy/ERC1967/ERC1967Upgrade.sol","utils/Multicall.sol","token/ERC721/ERC721.sol","mocks/AddressImpl.sol","mocks/crosschain/bridges.sol","utils/escrow/Escrow.sol","token/ERC20/utils/SafeERC20.sol","utils/cryptography/SignatureChecker.sol","governance/TimelockController.sol","governance/Governor.sol","finance/PaymentSplitter.sol","token/ERC777/ERC777.sol","proxy/utils/Initializable.sol","finance/VestingWallet.sol","mocks/ClonesMock.sol","proxy/beacon/UpgradeableBeacon.sol"],"urls":[]},"utils/Arrays.sol":{"checksum":{"algorithm":"md5","hash":"0x2bd89f9eb95c317b3b21cc83fde01a32"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Arrays.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * `array` is expected to be sorted in ascending order, and to contain no\n     * repeated elements.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        if (array.length == 0) {\n            return 0;\n        }\n\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds down (it does integer division with truncation).\n            if (array[mid] > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && array[low - 1] == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n}\n","imports":["utils/math/Math.sol"],"references":["mocks/ArraysImpl.sol","token/ERC20/extensions/ERC20Snapshot.sol"],"urls":[]},"utils/Base64.sol":{"checksum":{"algorithm":"md5","hash":"0x8f868da0a90e46a85baa348a896d1702"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n *\n * _Available since v4.5._\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // Loads the table into memory\n        string memory table = _TABLE;\n\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n        // and split into 4 numbers of 6 bits.\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        string memory result = new string(4 * ((data.length + 2) / 3));\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 32)\n\n            // Run over the input, 3 bytes at a time\n            for {\n                let dataPtr := data\n                let endPtr := add(data, mload(data))\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 bytes (18 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F which is the number of\n                // the previous character in the ASCII table prior to the Base64 Table\n                // The result is then added to the table to get the character to write,\n                // and finally write it in the result pointer but with a left shift\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // When data `bytes` is not exactly 3 bytes long\n            // it is padded with `=` characters at the end\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n                mstore8(sub(resultPtr, 2), 0x3d)\n            }\n            case 2 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n            }\n        }\n\n        return result;\n    }\n}\n","imports":[],"references":["mocks/Base64Mock.sol"],"urls":[]},"utils/Checkpoints.sol":{"checksum":{"algorithm":"md5","hash":"0x6986896416b1f89cb9ddd3bafe0bf8d1"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Checkpoints.sol)\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SafeCast.sol\";\n\n/**\n * @dev This library defines the `History` struct, for checkpointing values as they change at different points in\n * time, and later looking up past values by block number. See {Votes} as an example.\n *\n * To create a history of checkpoints define a variable type `Checkpoints.History` in your contract, and store a new\n * checkpoint for the current transaction block using the {push} function.\n *\n * _Available since v4.5._\n */\nlibrary Checkpoints {\n    struct Checkpoint {\n        uint32 _blockNumber;\n        uint224 _value;\n    }\n\n    struct History {\n        Checkpoint[] _checkpoints;\n    }\n\n    /**\n     * @dev Returns the value in the latest checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(History storage self) internal view returns (uint256) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : self._checkpoints[pos - 1]._value;\n    }\n\n    /**\n     * @dev Returns the value at a given block number. If a checkpoint is not available at that block, the closest one\n     * before it is returned, or zero otherwise.\n     */\n    function getAtBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {\n        require(blockNumber < block.number, \"Checkpoints: block not yet mined\");\n\n        uint256 high = self._checkpoints.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (self._checkpoints[mid]._blockNumber > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? 0 : self._checkpoints[high - 1]._value;\n    }\n\n    /**\n     * @dev Pushes a value onto a History so that it is stored as the checkpoint for the current block.\n     *\n     * Returns previous value and new value.\n     */\n    function push(History storage self, uint256 value) internal returns (uint256, uint256) {\n        uint256 pos = self._checkpoints.length;\n        uint256 old = latest(self);\n        if (pos > 0 && self._checkpoints[pos - 1]._blockNumber == block.number) {\n            self._checkpoints[pos - 1]._value = SafeCast.toUint224(value);\n        } else {\n            self._checkpoints.push(\n                Checkpoint({_blockNumber: SafeCast.toUint32(block.number), _value: SafeCast.toUint224(value)})\n            );\n        }\n        return (old, value);\n    }\n\n    /**\n     * @dev Pushes a value onto a History, by updating the latest value using binary operation `op`. The new value will\n     * be set to `op(latest, delta)`.\n     *\n     * Returns previous value and new value.\n     */\n    function push(\n        History storage self,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) internal returns (uint256, uint256) {\n        return push(self, op(latest(self), delta));\n    }\n}\n","imports":["utils/math/SafeCast.sol","utils/math/Math.sol"],"references":["mocks/CheckpointsImpl.sol","governance/utils/Votes.sol"],"urls":[]},"utils/Context.sol":{"checksum":{"algorithm":"md5","hash":"0x5f2c5c4b6af2dd4551027144797bc8be"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n","imports":[],"references":["mocks/ReentrancyAttack.sol","access/Ownable.sol","mocks/ERC777Mock.sol","token/ERC1155/ERC1155.sol","metatx/ERC2771Context.sol","token/ERC20/extensions/ERC20Burnable.sol","access/AccessControl.sol","governance/utils/Votes.sol","mocks/ContextMock.sol","token/ERC721/ERC721.sol","token/ERC1155/presets/ERC1155PresetMinterPauser.sol","mocks/ERC777SenderRecipientMock.sol","token/ERC721/extensions/ERC721Burnable.sol","governance/Governor.sol","mocks/SafeERC20Helper.sol","token/ERC20/presets/ERC20PresetMinterPauser.sol","token/ERC20/ERC20.sol","finance/PaymentSplitter.sol","token/ERC777/ERC777.sol","token/ERC721/presets/ERC721PresetMinterPauserAutoId.sol","finance/VestingWallet.sol","security/Pausable.sol"],"urls":[]},"utils/Counters.sol":{"checksum":{"algorithm":"md5","hash":"0x74654e3ae5d7f39555055dfe244dab7a"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n","imports":[],"references":["mocks/CountersImpl.sol","token/ERC20/extensions/draft-ERC20Permit.sol","governance/utils/Votes.sol","governance/compatibility/GovernorCompatibilityBravo.sol","token/ERC20/extensions/ERC20Snapshot.sol","token/ERC721/presets/ERC721PresetMinterPauserAutoId.sol"],"urls":[]},"utils/Create2.sol":{"checksum":{"algorithm":"md5","hash":"0x8932e2855e9aac6e79af79e499863b10"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Create2.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(\n        uint256 amount,\n        bytes32 salt,\n        bytes memory bytecode\n    ) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(\n        bytes32 salt,\n        bytes32 bytecodeHash,\n        address deployer\n    ) internal pure returns (address) {\n        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash));\n        return address(uint160(uint256(_data)));\n    }\n}\n","imports":[],"references":["mocks/Create2Impl.sol"],"urls":[]},"utils/Multicall.sol":{"checksum":{"algorithm":"md5","hash":"0x8a997d859de7e871118021136bb5094e"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Address.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * _Available since v4.1._\n */\nabstract contract Multicall {\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\n        }\n        return results;\n    }\n}\n","imports":["utils/Address.sol"],"references":["mocks/MulticallTokenMock.sol"],"urls":[]},"utils/README.adoc":{"checksum":{"algorithm":"md5","hash":"0xa4267d31b3c8c78d3d4b23a5b4882b89"},"content":"= Utilities\n\n[.readme-notice]\nNOTE: This document is better viewed at https://docs.openzeppelin.com/contracts/api/utils\n\nMiscellaneous contracts and libraries containing utility functions you can use to improve security, work with new data types, or safely use low-level primitives.\n\nThe {Address}, {Arrays}, {Base64} and {Strings} libraries provide more operations related to these native data types, while {SafeCast} adds ways to safely convert between the different signed and unsigned numeric types.\n{Multicall} provides a function to batch together multiple calls in a single external call.\n\nFor new data types:\n\n * {Counters}: a simple way to get a counter that can only be incremented, decremented or reset. Very useful for ID generation, counting contract activity, among others.\n * {EnumerableMap}: like Solidity's https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`] type, but with key-value _enumeration_: this will let you know how many entries a mapping has, and iterate over them (which is not possible with `mapping`).\n * {EnumerableSet}: like {EnumerableMap}, but for https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets]. Can be used to store privileged accounts, issued IDs, etc.\n\n[NOTE]\n====\nBecause Solidity does not support generic types, {EnumerableMap} and {EnumerableSet} are specialized to a limited number of key-value types.\n\nAs of v3.0, {EnumerableMap} supports `uint256 -> address` (`UintToAddressMap`), and {EnumerableSet} supports `address` and `uint256` (`AddressSet` and `UintSet`).\n====\n\nFinally, {Create2} contains all necessary utilities to safely use the https://blog.openzeppelin.com/getting-the-most-out-of-create2/[`CREATE2` EVM opcode], without having to deal with low-level assembly.\n\n== Math\n\n{{Math}}\n\n{{SignedMath}}\n\n{{SafeCast}}\n\n{{SafeMath}}\n\n{{SignedSafeMath}}\n\n== Cryptography\n\n{{ECDSA}}\n\n{{SignatureChecker}}\n\n{{MerkleProof}}\n\n{{EIP712}}\n\n== Escrow\n\n{{ConditionalEscrow}}\n\n{{Escrow}}\n\n{{RefundEscrow}}\n\n== Introspection\n\nThis set of interfaces and contracts deal with https://en.wikipedia.org/wiki/Type_introspection[type introspection] of contracts, that is, examining which functions can be called on them. This is usually referred to as a contract's _interface_.\n\nEthereum contracts have no native concept of an interface, so applications must usually simply trust they are not making an incorrect call. For trusted setups this is a non-issue, but often unknown and untrusted third-party addresses need to be interacted with. There may even not be any direct calls to them! (e.g. `ERC20` tokens may be sent to a contract that lacks a way to transfer them out of it, locking them forever). In these cases, a contract _declaring_ its interface can be very helpful in preventing errors.\n\nThere are two main ways to approach this.\n\n* Locally, where a contract implements `IERC165` and declares an interface, and a second one queries it directly via `ERC165Checker`.\n* Globally, where a global and unique registry (`IERC1820Registry`) is used to register implementers of a certain interface (`IERC1820Implementer`). It is then the registry that is queried, which allows for more complex setups, like contracts implementing interfaces for externally-owned accounts.\n\nNote that, in all cases, accounts simply _declare_ their interfaces, but they are not required to actually implement them. This mechanism can therefore be used to both prevent errors and allow for complex interactions (see `ERC777`), but it must not be relied on for security.\n\n{{IERC165}}\n\n{{ERC165}}\n\n{{ERC165Storage}}\n\n{{ERC165Checker}}\n\n{{IERC1820Registry}}\n\n{{IERC1820Implementer}}\n\n{{ERC1820Implementer}}\n\n== Data Structures\n\n{{BitMaps}}\n\n{{EnumerableMap}}\n\n{{EnumerableSet}}\n\n{{DoubleEndedQueue}}\n\n{{Checkpoints}}\n\n== Libraries\n\n{{Create2}}\n\n{{Address}}\n\n{{Arrays}}\n\n{{Base64}}\n\n{{Counters}}\n\n{{Strings}}\n\n{{StorageSlot}}\n\n{{Multicall}}\n","imports":[],"references":[],"urls":[]},"utils/StorageSlot.sol":{"checksum":{"algorithm":"md5","hash":"0xf993f8f50186952a59ee5e3a30b68222"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n","imports":[],"references":["proxy/ERC1967/ERC1967Upgrade.sol","mocks/StorageSlotMock.sol"],"urls":[]},"utils/Strings.sol":{"checksum":{"algorithm":"md5","hash":"0xcf46906c4035f51639a22265066a9e78"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n","imports":[],"references":["access/AccessControl.sol","token/ERC721/ERC721.sol","token/ERC1155/extensions/ERC1155URIStorage.sol","mocks/StringsMock.sol","utils/cryptography/ECDSA.sol"],"urls":[]},"utils/Timers.sol":{"checksum":{"algorithm":"md5","hash":"0xae135102abee8b2fc88eed09a40cdb4c"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Timers.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Tooling for timepoints, timers and delays\n */\nlibrary Timers {\n    struct Timestamp {\n        uint64 _deadline;\n    }\n\n    function getDeadline(Timestamp memory timer) internal pure returns (uint64) {\n        return timer._deadline;\n    }\n\n    function setDeadline(Timestamp storage timer, uint64 timestamp) internal {\n        timer._deadline = timestamp;\n    }\n\n    function reset(Timestamp storage timer) internal {\n        timer._deadline = 0;\n    }\n\n    function isUnset(Timestamp memory timer) internal pure returns (bool) {\n        return timer._deadline == 0;\n    }\n\n    function isStarted(Timestamp memory timer) internal pure returns (bool) {\n        return timer._deadline > 0;\n    }\n\n    function isPending(Timestamp memory timer) internal view returns (bool) {\n        return timer._deadline > block.timestamp;\n    }\n\n    function isExpired(Timestamp memory timer) internal view returns (bool) {\n        return isStarted(timer) && timer._deadline <= block.timestamp;\n    }\n\n    struct BlockNumber {\n        uint64 _deadline;\n    }\n\n    function getDeadline(BlockNumber memory timer) internal pure returns (uint64) {\n        return timer._deadline;\n    }\n\n    function setDeadline(BlockNumber storage timer, uint64 timestamp) internal {\n        timer._deadline = timestamp;\n    }\n\n    function reset(BlockNumber storage timer) internal {\n        timer._deadline = 0;\n    }\n\n    function isUnset(BlockNumber memory timer) internal pure returns (bool) {\n        return timer._deadline == 0;\n    }\n\n    function isStarted(BlockNumber memory timer) internal pure returns (bool) {\n        return timer._deadline > 0;\n    }\n\n    function isPending(BlockNumber memory timer) internal view returns (bool) {\n        return timer._deadline > block.number;\n    }\n\n    function isExpired(BlockNumber memory timer) internal view returns (bool) {\n        return isStarted(timer) && timer._deadline <= block.number;\n    }\n}\n","imports":[],"references":["governance/Governor.sol","mocks/TimersBlockNumberImpl.sol","mocks/TimersTimestampImpl.sol"],"urls":[]},"utils/cryptography/ECDSA.sol":{"checksum":{"algorithm":"md5","hash":"0x1dfb7cf7c7e2edae73403d50a59cc967"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n","imports":["utils/Strings.sol"],"references":["mocks/ERC1271WalletMock.sol","token/ERC20/extensions/draft-ERC20Permit.sol","mocks/EIP712External.sol","utils/cryptography/draft-EIP712.sol","utils/cryptography/SignatureChecker.sol","governance/Governor.sol","token/ERC20/extensions/ERC20Votes.sol","mocks/ECDSAMock.sol","metatx/MinimalForwarder.sol"],"urls":[]},"utils/cryptography/MerkleProof.sol":{"checksum":{"algorithm":"md5","hash":"0x04d20a7656ab3b219a40d6dad3669ab5"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\n     * consuming from one or the other at each step according to the instructions given by\n     * `proofFlags`.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n","imports":[],"references":["mocks/MerkleProofWrapper.sol"],"urls":[]},"utils/cryptography/SignatureChecker.sol":{"checksum":{"algorithm":"md5","hash":"0x9eaf795cef868a6fd3b2353731f319e4"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.1) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\nimport \"../Address.sol\";\nimport \"../../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Gnosis Safe.\n *\n * _Available since v4.1._\n */\nlibrary SignatureChecker {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\n        if (error == ECDSA.RecoverError.NoError && recovered == signer) {\n            return true;\n        }\n\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\n        );\n        return (success &&\n            result.length == 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n}\n","imports":["interfaces/IERC1271.sol","utils/cryptography/ECDSA.sol","utils/Address.sol"],"references":["mocks/SignatureCheckerMock.sol"],"urls":[]},"utils/cryptography/draft-EIP712.sol":{"checksum":{"algorithm":"md5","hash":"0x161aae4dc1450371d0f324488f66a9cf"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n","imports":["utils/cryptography/ECDSA.sol"],"references":["token/ERC20/extensions/draft-ERC20Permit.sol","governance/utils/Votes.sol","mocks/EIP712External.sol","governance/Governor.sol","metatx/MinimalForwarder.sol"],"urls":[]},"utils/escrow/ConditionalEscrow.sol":{"checksum":{"algorithm":"md5","hash":"0xed8802b28f8eab3257dc05b5b09e5c5d"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/escrow/ConditionalEscrow.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Escrow.sol\";\n\n/**\n * @title ConditionalEscrow\n * @dev Base abstract escrow to only allow withdrawal if a condition is met.\n * @dev Intended usage: See {Escrow}. Same usage guidelines apply here.\n */\nabstract contract ConditionalEscrow is Escrow {\n    /**\n     * @dev Returns whether an address is allowed to withdraw their funds. To be\n     * implemented by derived contracts.\n     * @param payee The destination address of the funds.\n     */\n    function withdrawalAllowed(address payee) public view virtual returns (bool);\n\n    function withdraw(address payable payee) public virtual override {\n        require(withdrawalAllowed(payee), \"ConditionalEscrow: payee is not allowed to withdraw\");\n        super.withdraw(payee);\n    }\n}\n","imports":["utils/escrow/Escrow.sol"],"references":["mocks/ConditionalEscrowMock.sol","utils/escrow/RefundEscrow.sol"],"urls":[]},"utils/escrow/Escrow.sol":{"checksum":{"algorithm":"md5","hash":"0xb74451c81ede541b2d4b5d2300b94c4a"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/escrow/Escrow.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../access/Ownable.sol\";\nimport \"../Address.sol\";\n\n/**\n * @title Escrow\n * @dev Base escrow contract, holds funds designated for a payee until they\n * withdraw them.\n *\n * Intended usage: This contract (and derived escrow contracts) should be a\n * standalone contract, that only interacts with the contract that instantiated\n * it. That way, it is guaranteed that all Ether will be handled according to\n * the `Escrow` rules, and there is no need to check for payable functions or\n * transfers in the inheritance tree. The contract that uses the escrow as its\n * payment method should be its owner, and provide public methods redirecting\n * to the escrow's deposit and withdraw.\n */\ncontract Escrow is Ownable {\n    using Address for address payable;\n\n    event Deposited(address indexed payee, uint256 weiAmount);\n    event Withdrawn(address indexed payee, uint256 weiAmount);\n\n    mapping(address => uint256) private _deposits;\n\n    function depositsOf(address payee) public view returns (uint256) {\n        return _deposits[payee];\n    }\n\n    /**\n     * @dev Stores the sent amount as credit to be withdrawn.\n     * @param payee The destination address of the funds.\n     *\n     * Emits a {Deposited} event.\n     */\n    function deposit(address payee) public payable virtual onlyOwner {\n        uint256 amount = msg.value;\n        _deposits[payee] += amount;\n        emit Deposited(payee, amount);\n    }\n\n    /**\n     * @dev Withdraw accumulated balance for a payee, forwarding all gas to the\n     * recipient.\n     *\n     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.\n     * Make sure you trust the recipient, or are either following the\n     * checks-effects-interactions pattern or using {ReentrancyGuard}.\n     *\n     * @param payee The address whose funds will be withdrawn and transferred to.\n     *\n     * Emits a {Withdrawn} event.\n     */\n    function withdraw(address payable payee) public virtual onlyOwner {\n        uint256 payment = _deposits[payee];\n\n        _deposits[payee] = 0;\n\n        payee.sendValue(payment);\n\n        emit Withdrawn(payee, payment);\n    }\n}\n","imports":["utils/Address.sol","access/Ownable.sol"],"references":["utils/escrow/ConditionalEscrow.sol","security/PullPayment.sol"],"urls":[]},"utils/escrow/RefundEscrow.sol":{"checksum":{"algorithm":"md5","hash":"0xaee62e265ecc9a3b5f03a79e34b89158"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/escrow/RefundEscrow.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ConditionalEscrow.sol\";\n\n/**\n * @title RefundEscrow\n * @dev Escrow that holds funds for a beneficiary, deposited from multiple\n * parties.\n * @dev Intended usage: See {Escrow}. Same usage guidelines apply here.\n * @dev The owner account (that is, the contract that instantiates this\n * contract) may deposit, close the deposit period, and allow for either\n * withdrawal by the beneficiary, or refunds to the depositors. All interactions\n * with `RefundEscrow` will be made through the owner contract.\n */\ncontract RefundEscrow is ConditionalEscrow {\n    using Address for address payable;\n\n    enum State {\n        Active,\n        Refunding,\n        Closed\n    }\n\n    event RefundsClosed();\n    event RefundsEnabled();\n\n    State private _state;\n    address payable private immutable _beneficiary;\n\n    /**\n     * @dev Constructor.\n     * @param beneficiary_ The beneficiary of the deposits.\n     */\n    constructor(address payable beneficiary_) {\n        require(beneficiary_ != address(0), \"RefundEscrow: beneficiary is the zero address\");\n        _beneficiary = beneficiary_;\n        _state = State.Active;\n    }\n\n    /**\n     * @return The current state of the escrow.\n     */\n    function state() public view virtual returns (State) {\n        return _state;\n    }\n\n    /**\n     * @return The beneficiary of the escrow.\n     */\n    function beneficiary() public view virtual returns (address payable) {\n        return _beneficiary;\n    }\n\n    /**\n     * @dev Stores funds that may later be refunded.\n     * @param refundee The address funds will be sent to if a refund occurs.\n     */\n    function deposit(address refundee) public payable virtual override {\n        require(state() == State.Active, \"RefundEscrow: can only deposit while active\");\n        super.deposit(refundee);\n    }\n\n    /**\n     * @dev Allows for the beneficiary to withdraw their funds, rejecting\n     * further deposits.\n     */\n    function close() public virtual onlyOwner {\n        require(state() == State.Active, \"RefundEscrow: can only close while active\");\n        _state = State.Closed;\n        emit RefundsClosed();\n    }\n\n    /**\n     * @dev Allows for refunds to take place, rejecting further deposits.\n     */\n    function enableRefunds() public virtual onlyOwner {\n        require(state() == State.Active, \"RefundEscrow: can only enable refunds while active\");\n        _state = State.Refunding;\n        emit RefundsEnabled();\n    }\n\n    /**\n     * @dev Withdraws the beneficiary's funds.\n     */\n    function beneficiaryWithdraw() public virtual {\n        require(state() == State.Closed, \"RefundEscrow: beneficiary can only withdraw while closed\");\n        beneficiary().sendValue(address(this).balance);\n    }\n\n    /**\n     * @dev Returns whether refundees can withdraw their deposits (be refunded). The overridden function receives a\n     * 'payee' argument, but we ignore it here since the condition is global, not per-payee.\n     */\n    function withdrawalAllowed(address) public view override returns (bool) {\n        return state() == State.Refunding;\n    }\n}\n","imports":["utils/escrow/ConditionalEscrow.sol"],"references":[],"urls":[]},"utils/introspection/ERC165.sol":{"checksum":{"algorithm":"md5","hash":"0x0e7db055ce108f9da7bb6686a00287c0"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n","imports":["utils/introspection/IERC165.sol"],"references":["mocks/ERC1155ReceiverMock.sol","token/ERC1155/ERC1155.sol","access/AccessControl.sol","token/common/ERC2981.sol","token/ERC721/ERC721.sol","utils/introspection/ERC165Storage.sol","token/ERC721/extensions/ERC721Royalty.sol","governance/Governor.sol","governance/IGovernor.sol","mocks/ERC165Mock.sol","token/ERC1155/utils/ERC1155Receiver.sol"],"urls":[]},"utils/introspection/ERC165Checker.sol":{"checksum":{"algorithm":"md5","hash":"0x5a3534b728da5f342a0e8855476dee85"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.1) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface,\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);\n        if (result.length < 32) return false;\n        return success && abi.decode(result, (uint256)) > 0;\n    }\n}\n","imports":["utils/introspection/IERC165.sol"],"references":["mocks/ERC165CheckerMock.sol"],"urls":[]},"utils/introspection/ERC165Storage.sol":{"checksum":{"algorithm":"md5","hash":"0xa391733d3f579314de328ba879bc4f2d"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Storage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC165.sol\";\n\n/**\n * @dev Storage based implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165Storage is ERC165 {\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return super.supportsInterface(interfaceId) || _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n","imports":["utils/introspection/ERC165.sol"],"references":["mocks/ERC165StorageMock.sol"],"urls":[]},"utils/introspection/ERC1820Implementer.sol":{"checksum":{"algorithm":"md5","hash":"0x267e2fa54d5923930fc121c178403487"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC1820Implementer.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1820Implementer.sol\";\n\n/**\n * @dev Implementation of the {IERC1820Implementer} interface.\n *\n * Contracts may inherit from this and call {_registerInterfaceForAddress} to\n * declare their willingness to be implementers.\n * {IERC1820Registry-setInterfaceImplementer} should then be called for the\n * registration to be complete.\n */\ncontract ERC1820Implementer is IERC1820Implementer {\n    bytes32 private constant _ERC1820_ACCEPT_MAGIC = keccak256(\"ERC1820_ACCEPT_MAGIC\");\n\n    mapping(bytes32 => mapping(address => bool)) private _supportedInterfaces;\n\n    /**\n     * @dev See {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function canImplementInterfaceForAddress(bytes32 interfaceHash, address account)\n        public\n        view\n        virtual\n        override\n        returns (bytes32)\n    {\n        return _supportedInterfaces[interfaceHash][account] ? _ERC1820_ACCEPT_MAGIC : bytes32(0x00);\n    }\n\n    /**\n     * @dev Declares the contract as willing to be an implementer of\n     * `interfaceHash` for `account`.\n     *\n     * See {IERC1820Registry-setInterfaceImplementer} and\n     * {IERC1820Registry-interfaceHash}.\n     */\n    function _registerInterfaceForAddress(bytes32 interfaceHash, address account) internal virtual {\n        _supportedInterfaces[interfaceHash][account] = true;\n    }\n}\n","imports":["utils/introspection/IERC1820Implementer.sol"],"references":["mocks/ERC1820ImplementerMock.sol","mocks/Create2Impl.sol","mocks/ERC777SenderRecipientMock.sol"],"urls":[]},"utils/introspection/IERC165.sol":{"checksum":{"algorithm":"md5","hash":"0x03e6768535ac4da0e9756f1d8a4a018a"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n","imports":[],"references":["token/ERC1155/IERC1155.sol","token/ERC721/IERC721.sol","interfaces/IERC2981.sol","utils/introspection/ERC165Checker.sol","mocks/ERC165/ERC165InterfacesSupported.sol","interfaces/IERC165.sol","token/ERC1155/IERC1155Receiver.sol","utils/introspection/ERC165.sol"],"urls":[]},"utils/introspection/IERC1820Implementer.sol":{"checksum":{"algorithm":"md5","hash":"0x0612f1c8beee4b227de51b49174b9bc2"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC1820Implementer.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface for an ERC1820 implementer, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820#interface-implementation-erc1820implementerinterface[EIP].\n * Used by contracts that will be registered as implementers in the\n * {IERC1820Registry}.\n */\ninterface IERC1820Implementer {\n    /**\n     * @dev Returns a special value (`ERC1820_ACCEPT_MAGIC`) if this contract\n     * implements `interfaceHash` for `account`.\n     *\n     * See {IERC1820Registry-setInterfaceImplementer}.\n     */\n    function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) external view returns (bytes32);\n}\n","imports":[],"references":["utils/introspection/ERC1820Implementer.sol","interfaces/IERC1820Implementer.sol"],"urls":[]},"utils/introspection/IERC1820Registry.sol":{"checksum":{"algorithm":"md5","hash":"0xb6d012794ce0d001210e52233bf439fc"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/introspection/IERC1820Registry.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(\n        address account,\n        bytes32 _interfaceHash,\n        address implementer\n    ) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     * @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     * @param account Address of the contract for which to update the cache.\n     * @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     * @notice Checks whether a contract implements an ERC165 interface or not.\n     * If the result is not cached a direct lookup on the contract address is performed.\n     * If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     * {updateERC165Cache} with the contract address.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     * @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n}\n","imports":[],"references":["interfaces/IERC1820Registry.sol","mocks/ERC777SenderRecipientMock.sol","token/ERC777/ERC777.sol"],"urls":[]},"utils/math/Math.sol":{"checksum":{"algorithm":"md5","hash":"0xfb23b534599db16bb969dc6afcdc4261"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)` \u2192 `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n","imports":[],"references":["utils/Checkpoints.sol","governance/extensions/GovernorPreventLateQuorum.sol","token/ERC20/extensions/ERC4626.sol","mocks/MathMock.sol","token/ERC20/extensions/ERC20Votes.sol","finance/VestingWallet.sol","utils/Arrays.sol"],"urls":[]},"utils/math/SafeCast.sol":{"checksum":{"algorithm":"md5","hash":"0x64e3f111253497ba40c2ad9bdf48a191"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248) {\n        require(value >= type(int248).min && value <= type(int248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return int248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240) {\n        require(value >= type(int240).min && value <= type(int240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return int240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232) {\n        require(value >= type(int232).min && value <= type(int232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return int232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224) {\n        require(value >= type(int224).min && value <= type(int224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return int224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216) {\n        require(value >= type(int216).min && value <= type(int216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return int216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208) {\n        require(value >= type(int208).min && value <= type(int208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return int208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200) {\n        require(value >= type(int200).min && value <= type(int200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return int200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192) {\n        require(value >= type(int192).min && value <= type(int192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return int192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184) {\n        require(value >= type(int184).min && value <= type(int184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return int184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176) {\n        require(value >= type(int176).min && value <= type(int176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return int176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168) {\n        require(value >= type(int168).min && value <= type(int168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return int168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160) {\n        require(value >= type(int160).min && value <= type(int160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return int160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152) {\n        require(value >= type(int152).min && value <= type(int152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return int152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144) {\n        require(value >= type(int144).min && value <= type(int144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return int144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136) {\n        require(value >= type(int136).min && value <= type(int136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return int136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120) {\n        require(value >= type(int120).min && value <= type(int120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return int120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112) {\n        require(value >= type(int112).min && value <= type(int112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return int112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104) {\n        require(value >= type(int104).min && value <= type(int104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return int104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96) {\n        require(value >= type(int96).min && value <= type(int96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return int96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88) {\n        require(value >= type(int88).min && value <= type(int88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return int88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80) {\n        require(value >= type(int80).min && value <= type(int80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return int80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72) {\n        require(value >= type(int72).min && value <= type(int72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return int72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56) {\n        require(value >= type(int56).min && value <= type(int56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return int56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48) {\n        require(value >= type(int48).min && value <= type(int48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return int48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40) {\n        require(value >= type(int40).min && value <= type(int40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return int40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24) {\n        require(value >= type(int24).min && value <= type(int24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return int24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n","imports":[],"references":["utils/Checkpoints.sol","governance/compatibility/GovernorCompatibilityBravo.sol","governance/extensions/GovernorTimelockCompound.sol","utils/structs/DoubleEndedQueue.sol","governance/Governor.sol","token/ERC20/extensions/ERC20Votes.sol","mocks/SafeCastMock.sol"],"urls":[]},"utils/math/SafeMath.sol":{"checksum":{"algorithm":"md5","hash":"0x2337f0279507b5edf14a07067adf0d05"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n","imports":[],"references":["mocks/SafeMathMock.sol"],"urls":[]},"utils/math/SignedMath.sol":{"checksum":{"algorithm":"md5","hash":"0x226875d0edb508420f74e7a1c2786ad8"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n","imports":[],"references":["mocks/SignedMathMock.sol"],"urls":[]},"utils/math/SignedSafeMath.sol":{"checksum":{"algorithm":"md5","hash":"0xf7b3809e202b5547e9ddd97aaeb1d907"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SignedSafeMath {\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        return a + b;\n    }\n}\n","imports":[],"references":["mocks/SignedSafeMathMock.sol"],"urls":[]},"utils/structs/BitMaps.sol":{"checksum":{"algorithm":"md5","hash":"0xa4862458388199138bffd4fa18f6c8ba"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/BitMaps.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.\n * Largelly inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].\n */\nlibrary BitMaps {\n    struct BitMap {\n        mapping(uint256 => uint256) _data;\n    }\n\n    /**\n     * @dev Returns whether the bit at `index` is set.\n     */\n    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        return bitmap._data[bucket] & mask != 0;\n    }\n\n    /**\n     * @dev Sets the bit at `index` to the boolean `value`.\n     */\n    function setTo(\n        BitMap storage bitmap,\n        uint256 index,\n        bool value\n    ) internal {\n        if (value) {\n            set(bitmap, index);\n        } else {\n            unset(bitmap, index);\n        }\n    }\n\n    /**\n     * @dev Sets the bit at `index`.\n     */\n    function set(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] |= mask;\n    }\n\n    /**\n     * @dev Unsets the bit at `index`.\n     */\n    function unset(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] &= ~mask;\n    }\n}\n","imports":[],"references":["mocks/BitmapMock.sol"],"urls":[]},"utils/structs/DoubleEndedQueue.sol":{"checksum":{"algorithm":"md5","hash":"0x1252685551a5afdb6005499e0f549eff"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/DoubleEndedQueue.sol)\npragma solidity ^0.8.4;\n\nimport \"../math/SafeCast.sol\";\n\n/**\n * @dev A sequence of items with the ability to efficiently push and pop items (i.e. insert and remove) on both ends of\n * the sequence (called front and back). Among other access patterns, it can be used to implement efficient LIFO and\n * FIFO queues. Storage use is optimized, and all operations are O(1) constant time. This includes {clear}, given that\n * the existing queue contents are left in storage.\n *\n * The struct is called `Bytes32Deque`. Other types can be cast to and from `bytes32`. This data structure can only be\n * used in storage, and not in memory.\n * ```\n * DoubleEndedQueue.Bytes32Deque queue;\n * ```\n *\n * _Available since v4.6._\n */\nlibrary DoubleEndedQueue {\n    /**\n     * @dev An operation (e.g. {front}) couldn't be completed due to the queue being empty.\n     */\n    error Empty();\n\n    /**\n     * @dev An operation (e.g. {at}) couldn't be completed due to an index being out of bounds.\n     */\n    error OutOfBounds();\n\n    /**\n     * @dev Indices are signed integers because the queue can grow in any direction. They are 128 bits so begin and end\n     * are packed in a single storage slot for efficient access. Since the items are added one at a time we can safely\n     * assume that these 128-bit indices will not overflow, and use unchecked arithmetic.\n     *\n     * Struct members have an underscore prefix indicating that they are \"private\" and should not be read or written to\n     * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and\n     * lead to unexpected behavior.\n     *\n     * Indices are in the range [begin, end) which means the first item is at data[begin] and the last item is at\n     * data[end - 1].\n     */\n    struct Bytes32Deque {\n        int128 _begin;\n        int128 _end;\n        mapping(int128 => bytes32) _data;\n    }\n\n    /**\n     * @dev Inserts an item at the end of the queue.\n     */\n    function pushBack(Bytes32Deque storage deque, bytes32 value) internal {\n        int128 backIndex = deque._end;\n        deque._data[backIndex] = value;\n        unchecked {\n            deque._end = backIndex + 1;\n        }\n    }\n\n    /**\n     * @dev Removes the item at the end of the queue and returns it.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function popBack(Bytes32Deque storage deque) internal returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 backIndex;\n        unchecked {\n            backIndex = deque._end - 1;\n        }\n        value = deque._data[backIndex];\n        delete deque._data[backIndex];\n        deque._end = backIndex;\n    }\n\n    /**\n     * @dev Inserts an item at the beginning of the queue.\n     */\n    function pushFront(Bytes32Deque storage deque, bytes32 value) internal {\n        int128 frontIndex;\n        unchecked {\n            frontIndex = deque._begin - 1;\n        }\n        deque._data[frontIndex] = value;\n        deque._begin = frontIndex;\n    }\n\n    /**\n     * @dev Removes the item at the beginning of the queue and returns it.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function popFront(Bytes32Deque storage deque) internal returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 frontIndex = deque._begin;\n        value = deque._data[frontIndex];\n        delete deque._data[frontIndex];\n        unchecked {\n            deque._begin = frontIndex + 1;\n        }\n    }\n\n    /**\n     * @dev Returns the item at the beginning of the queue.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function front(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 frontIndex = deque._begin;\n        return deque._data[frontIndex];\n    }\n\n    /**\n     * @dev Returns the item at the end of the queue.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function back(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 backIndex;\n        unchecked {\n            backIndex = deque._end - 1;\n        }\n        return deque._data[backIndex];\n    }\n\n    /**\n     * @dev Return the item at a position in the queue given by `index`, with the first item at 0 and last item at\n     * `length(deque) - 1`.\n     *\n     * Reverts with `OutOfBounds` if the index is out of bounds.\n     */\n    function at(Bytes32Deque storage deque, uint256 index) internal view returns (bytes32 value) {\n        // int256(deque._begin) is a safe upcast\n        int128 idx = SafeCast.toInt128(int256(deque._begin) + SafeCast.toInt256(index));\n        if (idx >= deque._end) revert OutOfBounds();\n        return deque._data[idx];\n    }\n\n    /**\n     * @dev Resets the queue back to being empty.\n     *\n     * NOTE: The current items are left behind in storage. This does not affect the functioning of the queue, but misses\n     * out on potential gas refunds.\n     */\n    function clear(Bytes32Deque storage deque) internal {\n        deque._begin = 0;\n        deque._end = 0;\n    }\n\n    /**\n     * @dev Returns the number of items in the queue.\n     */\n    function length(Bytes32Deque storage deque) internal view returns (uint256) {\n        // The interface preserves the invariant that begin <= end so we assume this will not overflow.\n        // We also assume there are at most int256.max items in the queue.\n        unchecked {\n            return uint256(int256(deque._end) - int256(deque._begin));\n        }\n    }\n\n    /**\n     * @dev Returns true if the queue is empty.\n     */\n    function empty(Bytes32Deque storage deque) internal view returns (bool) {\n        return deque._end <= deque._begin;\n    }\n}\n","imports":["utils/math/SafeCast.sol"],"references":["mocks/DoubleEndedQueueMock.sol","governance/Governor.sol"],"urls":[]},"utils/structs/EnumerableMap.sol":{"checksum":{"algorithm":"md5","hash":"0xd163f6a1debe598957c196b5bf782cd6"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableMap.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function get(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToUintMap storage map,\n        uint256 key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key)));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToUintMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key), errorMessage));\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        AddressToUintMap storage map,\n        address key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        AddressToUintMap storage map,\n        address key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToUintMap storage map,\n        bytes32 key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (key, uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, key);\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, key));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        Bytes32ToUintMap storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, key, errorMessage));\n    }\n}\n","imports":["utils/structs/EnumerableSet.sol"],"references":["mocks/EnumerableMapMock.sol"],"urls":[]},"utils/structs/EnumerableSet.sol":{"checksum":{"algorithm":"md5","hash":"0xaec6e37069dfaa5e3d5fd66ef2274b0c"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n","imports":[],"references":["utils/structs/EnumerableMap.sol","access/AccessControlEnumerable.sol","mocks/EnumerableSetMock.sol"],"urls":[]},"vendor/amb/IAMB.sol":{"checksum":{"algorithm":"md5","hash":"0xded958860b2fd4572666d478ecf695c6"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (vendor/amb/IAMB.sol)\npragma solidity ^0.8.0;\n\ninterface IAMB {\n    event UserRequestForAffirmation(bytes32 indexed messageId, bytes encodedData);\n    event UserRequestForSignature(bytes32 indexed messageId, bytes encodedData);\n    event AffirmationCompleted(\n        address indexed sender,\n        address indexed executor,\n        bytes32 indexed messageId,\n        bool status\n    );\n    event RelayedMessage(address indexed sender, address indexed executor, bytes32 indexed messageId, bool status);\n\n    function messageSender() external view returns (address);\n\n    function maxGasPerTx() external view returns (uint256);\n\n    function transactionHash() external view returns (bytes32);\n\n    function messageId() external view returns (bytes32);\n\n    function messageSourceChainId() external view returns (bytes32);\n\n    function messageCallStatus(bytes32 _messageId) external view returns (bool);\n\n    function failedMessageDataHash(bytes32 _messageId) external view returns (bytes32);\n\n    function failedMessageReceiver(bytes32 _messageId) external view returns (address);\n\n    function failedMessageSender(bytes32 _messageId) external view returns (address);\n\n    function requireToPassMessage(\n        address _contract,\n        bytes calldata _data,\n        uint256 _gas\n    ) external returns (bytes32);\n\n    function requireToConfirmMessage(\n        address _contract,\n        bytes calldata _data,\n        uint256 _gas\n    ) external returns (bytes32);\n\n    function sourceChainId() external view returns (uint256);\n\n    function destinationChainId() external view returns (uint256);\n}\n","imports":[],"references":["crosschain/amb/LibAMB.sol"],"urls":[]},"vendor/arbitrum/IArbSys.sol":{"checksum":{"algorithm":"md5","hash":"0x8c9cf0f036ddbc72199e06f366acab1e"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (vendor/arbitrum/IArbSys.sol)\npragma solidity >=0.4.21 <0.9.0;\n\n/**\n * @title Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064. Exposes a variety of system-level functionality.\n */\ninterface IArbSys {\n    /**\n     * @notice Get internal version number identifying an ArbOS build\n     * @return version number as int\n     */\n    function arbOSVersion() external pure returns (uint256);\n\n    function arbChainID() external view returns (uint256);\n\n    /**\n     * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\n     * @return block number as int\n     */\n    function arbBlockNumber() external view returns (uint256);\n\n    /**\n     * @notice Send given amount of Eth to dest from sender.\n     * This is a convenience function, which is equivalent to calling sendTxToL1 with empty calldataForL1.\n     * @param destination recipient address on L1\n     * @return unique identifier for this L2-to-L1 transaction.\n     */\n    function withdrawEth(address destination) external payable returns (uint256);\n\n    /**\n     * @notice Send a transaction to L1\n     * @param destination recipient address on L1\n     * @param calldataForL1 (optional) calldata for L1 contract call\n     * @return a unique identifier for this L2-to-L1 transaction.\n     */\n    function sendTxToL1(address destination, bytes calldata calldataForL1) external payable returns (uint256);\n\n    /**\n     * @notice get the number of transactions issued by the given external account or the account sequence number of the given contract\n     * @param account target account\n     * @return the number of transactions issued by the given external account or the account sequence number of the given contract\n     */\n    function getTransactionCount(address account) external view returns (uint256);\n\n    /**\n     * @notice get the value of target L2 storage slot\n     * This function is only callable from address 0 to prevent contracts from being able to call it\n     * @param account target account\n     * @param index target index of storage slot\n     * @return stotage value for the given account at the given index\n     */\n    function getStorageAt(address account, uint256 index) external view returns (uint256);\n\n    /**\n     * @notice check if current call is coming from l1\n     * @return true if the caller of this was called directly from L1\n     */\n    function isTopLevelCall() external view returns (bool);\n\n    /**\n     * @notice check if the caller (of this caller of this) is an aliased L1 contract address\n     * @return true iff the caller's address is an alias for an L1 contract address\n     */\n    function wasMyCallersAddressAliased() external view returns (bool);\n\n    /**\n     * @notice return the address of the caller (of this caller of this), without applying L1 contract address aliasing\n     * @return address of the caller's caller, without applying L1 contract address aliasing\n     */\n    function myCallersAddressWithoutAliasing() external view returns (address);\n\n    /**\n     * @notice map L1 sender contract address to its L2 alias\n     * @param sender sender address\n     * @param dest destination address\n     * @return aliased sender address\n     */\n    function mapL1SenderContractAddressToL2Alias(address sender, address dest) external pure returns (address);\n\n    /**\n     * @notice get the caller's amount of available storage gas\n     * @return amount of storage gas available to the caller\n     */\n    function getStorageGasAvailable() external view returns (uint256);\n\n    event L2ToL1Transaction(\n        address caller,\n        address indexed destination,\n        uint256 indexed uniqueId,\n        uint256 indexed batchNumber,\n        uint256 indexInBatch,\n        uint256 arbBlockNum,\n        uint256 ethBlockNum,\n        uint256 timestamp,\n        uint256 callvalue,\n        bytes data\n    );\n}\n","imports":[],"references":["crosschain/arbitrum/LibArbitrumL2.sol"],"urls":[]},"vendor/arbitrum/IBridge.sol":{"checksum":{"algorithm":"md5","hash":"0x0d19344e6cbf5f0461c39ff9c0fe04f3"},"content":"// SPDX-License-Identifier: Apache-2.0\n// OpenZeppelin Contracts (last updated v4.6.0) (vendor/arbitrum/IBridge.sol)\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\ninterface IBridge {\n    event MessageDelivered(\n        uint256 indexed messageIndex,\n        bytes32 indexed beforeInboxAcc,\n        address inbox,\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    );\n\n    event BridgeCallTriggered(address indexed outbox, address indexed destAddr, uint256 amount, bytes data);\n\n    event InboxToggle(address indexed inbox, bool enabled);\n\n    event OutboxToggle(address indexed outbox, bool enabled);\n\n    function deliverMessageToInbox(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) external payable returns (uint256);\n\n    function executeCall(\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool success, bytes memory returnData);\n\n    // These are only callable by the admin\n    function setInbox(address inbox, bool enabled) external;\n\n    function setOutbox(address inbox, bool enabled) external;\n\n    // View functions\n\n    function activeOutbox() external view returns (address);\n\n    function allowedInboxes(address inbox) external view returns (bool);\n\n    function allowedOutboxes(address outbox) external view returns (bool);\n\n    function inboxAccs(uint256 index) external view returns (bytes32);\n\n    function messageCount() external view returns (uint256);\n}\n","imports":[],"references":["crosschain/arbitrum/LibArbitrumL1.sol"],"urls":[]},"vendor/arbitrum/IInbox.sol":{"checksum":{"algorithm":"md5","hash":"0x363dee5563a8ec21c45d0d3e287783a2"},"content":"// SPDX-License-Identifier: Apache-2.0\n// OpenZeppelin Contracts (last updated v4.6.0) (vendor/arbitrum/IInbox.sol)\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"./IMessageProvider.sol\";\n\ninterface IInbox is IMessageProvider {\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\n\n    function sendUnsignedTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 nonce,\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function sendContractTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function sendL1FundedUnsignedTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 nonce,\n        address destAddr,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function sendL1FundedContractTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        address destAddr,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function createRetryableTicket(\n        address destAddr,\n        uint256 arbTxCallValue,\n        uint256 maxSubmissionCost,\n        address submissionRefundAddress,\n        address valueRefundAddress,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function createRetryableTicketNoRefundAliasRewrite(\n        address destAddr,\n        uint256 arbTxCallValue,\n        uint256 maxSubmissionCost,\n        address submissionRefundAddress,\n        address valueRefundAddress,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function depositEth(uint256 maxSubmissionCost) external payable returns (uint256);\n\n    function bridge() external view returns (address);\n\n    function pauseCreateRetryables() external;\n\n    function unpauseCreateRetryables() external;\n\n    function startRewriteAddress() external;\n\n    function stopRewriteAddress() external;\n}\n","imports":["vendor/arbitrum/IMessageProvider.sol"],"references":["crosschain/arbitrum/LibArbitrumL1.sol"],"urls":[]},"vendor/arbitrum/IMessageProvider.sol":{"checksum":{"algorithm":"md5","hash":"0x79a4e338093785694816c9fb7acb86f3"},"content":"// SPDX-License-Identifier: Apache-2.0\n// OpenZeppelin Contracts (last updated v4.6.0) (vendor/arbitrum/IMessageProvider.sol)\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\ninterface IMessageProvider {\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\n\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\n}\n","imports":[],"references":["vendor/arbitrum/IInbox.sol"],"urls":[]},"vendor/arbitrum/IOutbox.sol":{"checksum":{"algorithm":"md5","hash":"0x1162f1accaab6665595446a993ae89e1"},"content":"// SPDX-License-Identifier: Apache-2.0\n// OpenZeppelin Contracts (last updated v4.6.0) (vendor/arbitrum/IOutbox.sol)\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\ninterface IOutbox {\n    event OutboxEntryCreated(\n        uint256 indexed batchNum,\n        uint256 outboxEntryIndex,\n        bytes32 outputRoot,\n        uint256 numInBatch\n    );\n    event OutBoxTransactionExecuted(\n        address indexed destAddr,\n        address indexed l2Sender,\n        uint256 indexed outboxEntryIndex,\n        uint256 transactionIndex\n    );\n\n    function l2ToL1Sender() external view returns (address);\n\n    function l2ToL1Block() external view returns (uint256);\n\n    function l2ToL1EthBlock() external view returns (uint256);\n\n    function l2ToL1Timestamp() external view returns (uint256);\n\n    function l2ToL1BatchNum() external view returns (uint256);\n\n    function l2ToL1OutputId() external view returns (bytes32);\n\n    function processOutgoingMessages(bytes calldata sendsData, uint256[] calldata sendLengths) external;\n\n    function outboxEntryExists(uint256 batchNum) external view returns (bool);\n}\n","imports":[],"references":["crosschain/arbitrum/LibArbitrumL1.sol"],"urls":[]},"vendor/compound/ICompoundTimelock.sol":{"checksum":{"algorithm":"md5","hash":"0x0aa957092da3c691ed6bf15e56aedc3b"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (vendor/compound/ICompoundTimelock.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * https://github.com/compound-finance/compound-protocol/blob/master/contracts/Timelock.sol[Compound's timelock] interface\n */\ninterface ICompoundTimelock {\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint256 indexed newDelay);\n    event CancelTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event ExecuteTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event QueueTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n\n    receive() external payable;\n\n    // solhint-disable-next-line func-name-mixedcase\n    function GRACE_PERIOD() external view returns (uint256);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function MINIMUM_DELAY() external view returns (uint256);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function MAXIMUM_DELAY() external view returns (uint256);\n\n    function admin() external view returns (address);\n\n    function pendingAdmin() external view returns (address);\n\n    function delay() external view returns (uint256);\n\n    function queuedTransactions(bytes32) external view returns (bool);\n\n    function setDelay(uint256) external;\n\n    function acceptAdmin() external;\n\n    function setPendingAdmin(address) external;\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) external returns (bytes32);\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) external;\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) external payable returns (bytes memory);\n}\n","imports":[],"references":["governance/extensions/GovernorTimelockCompound.sol"],"urls":[]},"vendor/optimism/ICrossDomainMessenger.sol":{"checksum":{"algorithm":"md5","hash":"0xdbd555bcf18d405690d5d9766af03be2"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (vendor/optimism/ICrossDomainMessenger.sol)\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title ICrossDomainMessenger\n */\ninterface ICrossDomainMessenger {\n    /**********\n     * Events *\n     **********/\n\n    event SentMessage(address indexed target, address sender, bytes message, uint256 messageNonce, uint256 gasLimit);\n    event RelayedMessage(bytes32 indexed msgHash);\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /*************\n     * Variables *\n     *************/\n\n    function xDomainMessageSender() external view returns (address);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sends a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _message Message to send to the target.\n     * @param _gasLimit Gas limit for the provided message.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _gasLimit\n    ) external;\n}\n","imports":[],"references":["crosschain/optimism/LibOptimism.sol"],"urls":[]},"vendor/polygon/IFxMessageProcessor.sol":{"checksum":{"algorithm":"md5","hash":"0x708bc9315349e0b19949e5eefce243e9"},"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (vendor/polygon/IFxMessageProcessor.sol)\npragma solidity ^0.8.0;\n\ninterface IFxMessageProcessor {\n    function processMessageFromRoot(\n        uint256 stateId,\n        address rootMessageSender,\n        bytes calldata data\n    ) external;\n}\n","imports":[],"references":["crosschain/polygon/CrossChainEnabledPolygonChild.sol","mocks/crosschain/bridges.sol"],"urls":[]}},"version":"4.7.1"}